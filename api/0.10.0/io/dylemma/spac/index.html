<!DOCTYPE html ><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/><title></title><meta content="" name="description"/><meta content="" name="keywords"/><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><link href="../../../lib/index.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../../lib/template.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../../lib/print.css" media="print" type="text/css" rel="stylesheet"/><link href="../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css"/><script type="text/javascript" src="../../../lib/jquery.min.js"></script><script type="text/javascript" src="../../../lib/index.js"></script><script type="text/javascript" src="../../../index.js"></script><script type="text/javascript" src="../../../lib/scheduler.js"></script><script type="text/javascript" src="../../../lib/template.js"></script><script type="text/javascript">/* this variable can be used by the JS to determine the path to the root document */
var toRoot = '../../../';</script></head><body><div id="search"><span id="doc-title"><span id="doc-version"></span></span> <span class="close-results"><span class="left">&lt;</span> Back</span><div id="textfilter"><span class="input"><input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/"/><i class="clear material-icons"></i><i id="search-icon" class="material-icons"></i></span></div></div><div id="search-results"><div id="search-progress"><div id="progress-fill"></div></div><div id="results-content"><div id="entity-results"></div><div id="member-results"></div></div></div><div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;"><div id="content-container" style="-webkit-overflow-scrolling: touch;"><div id="subpackage-spacer"><div id="packages"><h1>Packages</h1><ul><li class="indented0 " name="_root_.root" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="_root_" class="anchorToMember"></a><a id="root:_root_" class="anchorToMember"></a> <span class="permalink"><a href="../../../index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../../index.html" title=""><span class="name">root</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented1 " name="_root_.io" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="io" class="anchorToMember"></a><a id="io:io" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../index.html" title=""><span class="name">io</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented2 " name="io.dylemma" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="dylemma" class="anchorToMember"></a><a id="dylemma:dylemma" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../index.html" title=""><span class="name">dylemma</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../index.html" name="io" id="io" class="extype">io</a></dd></dl></div></li><li class="indented3 current" name="io.dylemma.spac" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="spac" class="anchorToMember"></a><a id="spac:spac" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><span class="name">spac</span></span><p class="shortcomment cmt">SPaC (short for "<strong>S</strong>treaming <strong>Pa</strong>rser <strong>C</strong>ombinators")
is a library for building stream consumers in a declarative style, specialized for tree-like data
types like XML and JSON.</p><div class="fullcomment"><div class="comment cmt"><p>SPaC (short for "<strong>S</strong>treaming <strong>Pa</strong>rser <strong>C</strong>ombinators")
is a library for building stream consumers in a declarative style, specialized for tree-like data
types like XML and JSON.</p><p>Many utilities for handling XML and JSON data involve parsing the entire "document" to some DOM model,
then inspecting and transforming that model to extract information.
The downside to these utilities is that when the document is very large, the DOM may not fit in memory.
The workaround for this type of problem is to treat the document as a stream of "events",
e.g. "StartElement" and "EndElement" for XML, or "StartObject" and "EndObject" for JSON.
The downside to this workaround is that writing code to handle these streams can be complicated and
error-prone, especially when the DOM is complicated.</p><p>SPaC's goal is to drastically simplify the process of creating code to handle these streams.</p><p>This package contains the "core" SPaC traits; <code>Parser</code>, <code>Transformer</code>, <code>Splitter</code>, and <code>ContextMatcher</code>.</p><p>See the <code>xml</code> and <code>json</code> subpackages (provided by the <code>xml-spac</code> and <code>json-spac</code> libraries respectively)
for specific utilities related to handling XML and JSON event streams.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="io.dylemma" id="io.dylemma" class="extype">dylemma</a></dd></dl></div></li><li class="indented4 " name="io.dylemma.spac.interop" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="interop" class="anchorToMember"></a><a id="interop:interop" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/interop/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="interop/index.html" title=""><span class="name">interop</span></a></span></li><li class="indented4 " name="io.dylemma.spac.json" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="json" class="anchorToMember"></a><a id="json:json" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/json/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="json/index.html" title="This package provides extensions to the core &quot;spac&quot; library which allow for the handling of JSON data."><span class="name">json</span></a></span><p class="shortcomment cmt">This package provides extensions to the core "spac" library which allow for the handling of JSON data.</p><div class="fullcomment"><div class="comment cmt"><p>This package provides extensions to the core "spac" library which allow for the handling of JSON data.</p><p>Rather than creating explicit classes that extend <code>Parser</code>, <code>Transformer</code>, and <code>Splitter</code>,
this package provides type aliases and implicit extensions.
For example, <code>JsonParser[A]</code> is just a type alias for <code>Parser[JsonEvent, A]</code>,
and <code>JsonParser</code> is just a call to <code>Parser[JsonEvent]</code>.</p><p>Implicit JsonParsers are available for each of the JSON primitive types:</p><ul><li><code>string</code></li><li><code>number</code> (expressed as <code>Int</code>, <code>Long</code>, <code>Float</code>, or <code>Double</code>)</li><li><code>boolean</code></li><li><code>null</code> (expressed as <code>None.type</code>)</li></ul><p>Helpers are available for parsing JSON arrays and objects:</p><ul><li><code>JsonParser.listOf[A]</code> to parse an <code>array</code><code> where each value is an </code>A<code></code></li><li><code>JsonParser.objectOf[A]</code> to parse an <code>object</code> where the value for each field an <code>A</code></li><li><code>JsonParser.objectOfNullable[A]</code> to parse an <code>object</code> where the value for each field is either <code>null</code> or an <code>A</code>, filtering out the <code>null</code>s</li><li><code>JsonParser.fieldOf[A](fieldName)</code> to parse a specific field from an object</li></ul><p>A DSL for creating json-specific ContextMatchers is provided to make it more convenient to call <code>Splitter.json</code>.
For example:</p><pre>Splitter.json(<span class="lit">"foo"</span> \ <span class="lit">"bar"</span>).as[<span class="std">String</span>].parseFirst</pre><p>Can be used to capture <code>rootJson.foo.bar</code> as a String in</p><pre>{
  <span class="lit">"foo"</span>: {
    <span class="lit">"bar"</span>: <span class="lit">"hello"</span>
  }
}</pre><p>To "split" values inside arrays, index-related context matchers are available, e.g.</p><pre>Splitter.json(<span class="lit">"foo"</span> \ anyIndex).as[<span class="std">Int</span>].parseToList</pre><p>Can be used to capture each of the numbers in the "foo" array in</p><pre>{
  <span class="lit">"foo"</span>: [<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>]
}</pre><p>A note about JsonEvents in spac:
JSON doesn't have any explicit markers for when a field ends, or when an array index starts or ends;
those context changes are essentially inferred by the presence of some other event.
For example, instead of a "field end" event, typically there will be either a new "field start" or a token representing the end of the current object.
With spac, splitters and context matchers generally operate under the assumption that a "stack push" event (like a field start) will eventually be
followed by a corresponding "stack pop" event (i.e. field end).</p><p>To allow for this, these "inferred" events (FieldEnd, IndexStart, IndexEnd) are explicitly represented as JsonEvents in the stream being parsed.
Keep this in mind when creating JSON ContextMatchers:</p><ul><li><code>field</code>-related matchers will match a stack like <code>case ObjectStart :: FieldStart(_) :: _</code></li><li><code>index</code>-related matchers will match a stack like <code>case ArrayStart :: IndexStart(_) :: _</code>
</li></ul></div></div></li><li class="indented4 " name="io.dylemma.spac.xml" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="xml" class="anchorToMember"></a><a id="xml:xml" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/xml/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="xml/index.html" title="This package provides extensions to the core &quot;spac&quot; library which allow for the handling of XML data."><span class="name">xml</span></a></span><p class="shortcomment cmt">This package provides extensions to the core "spac" library which allow for the handling of XML data.</p><div class="fullcomment"><div class="comment cmt"><p>This package provides extensions to the core "spac" library which allow for the handling of XML data.</p><p>Rather than creating explicit classes that extend <code>Parser</code>, <code>Transformer</code>, and <code>Splitter</code>,
this package provides type aliases and implicit extensions.
For example, <code>XmlParser[A]</code> is just a type alias for <code>Parser[XmlEvent, A]</code>,
and <code>XmlParser</code> is just a call to <code>Parser[XmlEvent]</code>.</p><p>Three main Parser methods are added to <code>Parser[XmlEvent]</code> via the <code>XmlParserApplyOps</code> implicit class:</p><ul><li><code>XmlParser.forText</code> - for capturing raw text</li><li><code>XmlParser.attr</code> - for capturing mandatory attributes from elements</li><li><code>XmlParser.attrOpt</code> - for capturing optional attributes from elements</li></ul><p>One main Splitter constructor method is added to <code>Splitter</code> via the <code>XmlSplitterApplyOps</code> implicit class:</p><ul><li><code>Splitter.xml</code> - for creating splitters based on an inspection of an "element stack"</li></ul><p>Three main Splitter member methods are added to <code>Splitter[XmlEvent, C]</code> via the <code>XmlSplitterOps</code> implicit class:</p><ul><li><code>.attr</code> - alias for <code>.joinBy(XmlParser.attr(...))</code></li><li><code>.attrOpt</code> - alias for <code>.joinBy(XmlParser.attrOpt(...))</code></li><li><code>.text</code> - alias for <code>.joinBy(XmlParser.forText)</code></li></ul><p>A DSL for creating xml-specific ContextMatchers is provided to make it more convenient to call <code>Splitter.xml</code>.
For example:</p><pre>Splitter.xml(<span class="lit">"things"</span> \ <span class="lit">"thing"</span>).attr(<span class="lit">"foo"</span>).parseToList</pre><p>Can be used to capture a list of the "foo" attributes in the <code>&lt;thing&gt;</code> elements in</p><pre>&lt;things&gt;
   &lt;thing foo=<span class="lit">"hello"</span> /&gt;
   &lt;thing foo=<span class="lit">"Goodbye"</span>&gt;
      &lt;extra&gt;junk&lt;/extra&gt;
   &lt;/thing&gt;
&lt;/thing&gt;</pre></div></div></li><li class="current-entities indented3"><a href="CallerPos$.html" title="" class="object"></a> <a href="CallerPos.html" title="Represents a location in code that called a method." class="class"></a><a href="CallerPos.html" title="Represents a location in code that called a method.">CallerPos</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="ContextChange.html" title="Represents either entering (ContextPush) or exiting (ContextPop) some matched context within a stream of inputs." class="trait"></a><a href="ContextChange.html" title="Represents either entering (ContextPush) or exiting (ContextPop) some matched context within a stream of inputs.">ContextChange</a></li><li class="current-entities indented3"><a href="ContextLocation$.html" title="" class="object"></a> <a href="ContextLocation.html" title="A map-like representation of some location in a stream, used like stack trace elements for reporting errors in stream processing." class="trait"></a><a href="ContextLocation.html" title="A map-like representation of some location in a stream, used like stack trace elements for reporting errors in stream processing.">ContextLocation</a></li><li class="current-entities indented3"><a href="ContextMatcher$.html" title="" class="object"></a> <a href="ContextMatcher.html" title="An object responsible for inspecting a stack of StartElement events and determining if they correspond to some &quot;context&quot; value of type A." class="trait"></a><a href="ContextMatcher.html" title="An object responsible for inspecting a stack of StartElement events and determining if they correspond to some &quot;context&quot; value of type A.">ContextMatcher</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="ContextPop$.html" title="" class="object"></a><a href="ContextPop$.html" title="">ContextPop</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="ContextPush.html" title="" class="class"></a><a href="ContextPush.html" title="">ContextPush</a></li><li class="current-entities indented3"><a href="ContextTrace$.html" title="" class="object"></a> <a href="ContextTrace.html" title="" class="class"></a><a href="ContextTrace.html" title="">ContextTrace</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="HasLocation.html" title="Marker trait used by SpacTraceElement.InInput to extract location information from inputs that cause parsing exceptions." class="trait"></a><a href="HasLocation.html" title="Marker trait used by SpacTraceElement.InInput to extract location information from inputs that cause parsing exceptions.">HasLocation</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="LowPriorityTypeReduceImplicits.html" title="" class="trait"></a><a href="LowPriorityTypeReduceImplicits.html" title="">LowPriorityTypeReduceImplicits</a></li><li class="current-entities indented3"><a href="Parser$.html" title="" class="object"></a> <a href="Parser.html" title="Primary &quot;spac&quot; abstraction which represents a sink for data events." class="trait"></a><a href="Parser.html" title="Primary &quot;spac&quot; abstraction which represents a sink for data events.">Parser</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="ParserApplyWithBoundInput.html" title="Convenience version of the Parser companion object, which provides parser constructors with the In type already specified." class="class"></a><a href="ParserApplyWithBoundInput.html" title="Convenience version of the Parser companion object, which provides parser constructors with the In type already specified.">ParserApplyWithBoundInput</a></li><li class="current-entities indented3"><a href="Signal$.html" title="" class="object"></a> <a href="Signal.html" title="Value used by Transformer.Handler to indicate to its upstream producer whether or not the handler wants to continue receiving values." class="trait"></a><a href="Signal.html" title="Value used by Transformer.Handler to indicate to its upstream producer whether or not the handler wants to continue receiving values.">Signal</a></li><li class="current-entities indented3"><a href="SingleItemContextMatcher$.html" title="" class="object"></a> <a href="SingleItemContextMatcher.html" title="Specialization of ContextMatcher which only checks the first element in the stack for matching operations." class="trait"></a><a href="SingleItemContextMatcher.html" title="Specialization of ContextMatcher which only checks the first element in the stack for matching operations.">SingleItemContextMatcher</a></li><li class="current-entities indented3"><a href="Source$.html" title="Note: this companion object provides a few very basic Source-constructor helpers, but the real useful functionality is provided by the &quot;parser backend&quot; modules like xml-spac-javax and json-spac-jackson, via JavaxSource and JacksonSource." class="object"></a> <a href="Source.html" title="A Source[A] is like an Iterable[A] but with a built-in assumption that the iterator may be closeable, intended for use as a convenient argument to a Parser's parse method." class="trait"></a><a href="Source.html" title="A Source[A] is like an Iterable[A] but with a built-in assumption that the iterator may be closeable, intended for use as a convenient argument to a Parser's parse method.">Source</a></li><li class="current-entities indented3"><a href="SpacException$.html" title="" class="object"></a> <a href="SpacException.html" title="Base class for all exceptions thrown by Spac parsers." class="class"></a><a href="SpacException.html" title="Base class for all exceptions thrown by Spac parsers.">SpacException</a></li><li class="current-entities indented3"><a href="SpacTraceElement$.html" title="" class="object"></a> <a href="SpacTraceElement.html" title="A play on words vs StackTraceElement, a *Spac* trace element represents some contextual location inside the logic of a spac Parser, or the location of an input to that parser." class="trait"></a><a href="SpacTraceElement.html" title="A play on words vs StackTraceElement, a *Spac* trace element represents some contextual location inside the logic of a spac Parser, or the location of an input to that parser.">SpacTraceElement</a></li><li class="current-entities indented3"><a href="Splitter$.html" title="" class="object"></a> <a href="Splitter.html" title="Primary &quot;spac&quot; abstraction that acts as a selector for sub-streams within a single input stream." class="trait"></a><a href="Splitter.html" title="Primary &quot;spac&quot; abstraction that acts as a selector for sub-streams within a single input stream.">Splitter</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="SplitterApplyWithBoundInput.html" title="" class="class"></a><a href="SplitterApplyWithBoundInput.html" title="">SplitterApplyWithBoundInput</a></li><li class="current-entities indented3"><a href="StackInterpretation$.html" title="" class="object"></a> <a href="StackInterpretation.html" title="Outcome of a StackLike[In, Elem], indicating whether a given input was a stack push/pop, and whether that push/pop should be treated as happening before or after the input that caused it." class="trait"></a><a href="StackInterpretation.html" title="Outcome of a StackLike[In, Elem], indicating whether a given input was a stack push/pop, and whether that push/pop should be treated as happening before or after the input that caused it.">StackInterpretation</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="StackLike.html" title="Typeclass that perceives a subset of In values as either &quot;stack push&quot; or &quot;stack pop&quot; events." class="trait"></a><a href="StackLike.html" title="Typeclass that perceives a subset of In values as either &quot;stack push&quot; or &quot;stack pop&quot; events.">StackLike</a></li><li class="current-entities indented3"><a href="Transformer$.html" title="" class="object"></a> <a href="Transformer.html" title="Primary &quot;spac&quot; abstraction which represents a transformation stage for a stream of data events" class="trait"></a><a href="Transformer.html" title="Primary &quot;spac&quot; abstraction which represents a transformation stage for a stream of data events">Transformer</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="TransformerApplyWithBoundInput.html" title="Convenience version of the Transformer companion object, which provides transformer constructors with the In type already specified." class="class"></a><a href="TransformerApplyWithBoundInput.html" title="Convenience version of the Transformer companion object, which provides transformer constructors with the In type already specified.">TransformerApplyWithBoundInput</a></li><li class="current-entities indented3"><a href="TypeReduce$.html" title="" class="object"></a> <a href="TypeReduce.html" title="Type-level tuple reduction function that treats Unit as an Identity." class="trait"></a><a href="TypeReduce.html" title="Type-level tuple reduction function that treats Unit as an Identity.">TypeReduce</a></li><li class="current-entities indented3"><a href="Unconsable$.html" title="" class="object"></a> <a href="Unconsable.html" title="Typeclass for collections that can be efficiently split into a head element and a tail collection as long as they are not empty." class="trait"></a><a href="Unconsable.html" title="Typeclass for collections that can be efficiently split into a head element and a tail collection as long as they are not empty.">Unconsable</a></li></ul></div></div><div id="content"><body class="package value"><div id="definition"><div class="big-circle package">p</div><p id="owner"><a href="../../index.html" name="io" id="io" class="extype">io</a>.<a href="../index.html" name="io.dylemma" id="io.dylemma" class="extype">dylemma</a></p><h1>spac<span class="permalink"><a href="../../../io/dylemma/spac/index.html" title="Permalink"><i class="material-icons"></i></a></span></h1></div><h4 id="signature" class="signature"><span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><span class="name">spac</span></span></h4><div id="comment" class="fullcommenttop"><div class="comment cmt"><p>SPaC (short for "<strong>S</strong>treaming <strong>Pa</strong>rser <strong>C</strong>ombinators")
is a library for building stream consumers in a declarative style, specialized for tree-like data
types like XML and JSON.</p><p>Many utilities for handling XML and JSON data involve parsing the entire "document" to some DOM model,
then inspecting and transforming that model to extract information.
The downside to these utilities is that when the document is very large, the DOM may not fit in memory.
The workaround for this type of problem is to treat the document as a stream of "events",
e.g. "StartElement" and "EndElement" for XML, or "StartObject" and "EndObject" for JSON.
The downside to this workaround is that writing code to handle these streams can be complicated and
error-prone, especially when the DOM is complicated.</p><p>SPaC's goal is to drastically simplify the process of creating code to handle these streams.</p><p>This package contains the "core" SPaC traits; <code>Parser</code>, <code>Transformer</code>, <code>Splitter</code>, and <code>ContextMatcher</code>.</p><p>See the <code>xml</code> and <code>json</code> subpackages (provided by the <code>xml-spac</code> and <code>json-spac</code> libraries respectively)
for specific utilities related to handling XML and JSON event streams.
</p></div><dl class="attributes block"><dt>Source</dt><dd><a href="https://github.com/dylemma/xml-spac/tree/0.10.0/core/src/main/scala/io/dylemma/spac/package.scala" target="_blank">package.scala</a></dd></dl><div class="toggleContainer"><div class="toggle block"><span>Linear Supertypes</span><div class="superTypes hiddenContent"><span name="scala.AnyRef" class="extype">AnyRef</span>, <span name="scala.Any" class="extype">Any</span></div></div></div></div><div id="mbrsel"><div class="toggle"></div><div id="memberfilter"><i class="material-icons arrow"></i><span class="input"><input placeholder="Filter all members" id="mbrsel-input" type="text" accesskey="/"/></span><i class="clear material-icons"></i></div><div id="filterby"><div id="order"><span class="filtertype">Ordering</span><ol><li class="group out"><span>Grouped</span></li><li class="alpha in"><span>Alphabetic</span></li><li class="inherit out"><span>By Inheritance</span></li></ol></div><div class="ancestors"><span class="filtertype">Inherited<br/></span><ol id="linearization"><li class="in" name="io.dylemma.spac"><span>spac</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li></ol></div><div class="ancestors"><span class="filtertype"></span><ol><li class="hideall out"><span>Hide All</span></li><li class="showall in"><span>Show All</span></li></ol></div><div id="visbl"><span class="filtertype">Visibility</span><ol><li class="public in"><span>Public</span></li><li class="protected out"><span>Protected</span></li></ol></div></div></div><div id="template"><div id="allMembers"><div id="packages" class="package members"><h3>Package Members</h3><ol><li class="indented0 " name="io.dylemma.spac.interop" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="interop" class="anchorToMember"></a><a id="interop:interop" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/interop/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="interop/index.html" title=""><span class="name">interop</span></a></span></li><li class="indented0 " name="io.dylemma.spac.json" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="json" class="anchorToMember"></a><a id="json:json" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/json/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="json/index.html" title="This package provides extensions to the core &quot;spac&quot; library which allow for the handling of JSON data."><span class="name">json</span></a></span><p class="shortcomment cmt">This package provides extensions to the core "spac" library which allow for the handling of JSON data.</p><div class="fullcomment"><div class="comment cmt"><p>This package provides extensions to the core "spac" library which allow for the handling of JSON data.</p><p>Rather than creating explicit classes that extend <code>Parser</code>, <code>Transformer</code>, and <code>Splitter</code>,
this package provides type aliases and implicit extensions.
For example, <code>JsonParser[A]</code> is just a type alias for <code>Parser[JsonEvent, A]</code>,
and <code>JsonParser</code> is just a call to <code>Parser[JsonEvent]</code>.</p><p>Implicit JsonParsers are available for each of the JSON primitive types:</p><ul><li><code>string</code></li><li><code>number</code> (expressed as <code>Int</code>, <code>Long</code>, <code>Float</code>, or <code>Double</code>)</li><li><code>boolean</code></li><li><code>null</code> (expressed as <code>None.type</code>)</li></ul><p>Helpers are available for parsing JSON arrays and objects:</p><ul><li><code>JsonParser.listOf[A]</code> to parse an <code>array</code><code> where each value is an </code>A<code></code></li><li><code>JsonParser.objectOf[A]</code> to parse an <code>object</code> where the value for each field an <code>A</code></li><li><code>JsonParser.objectOfNullable[A]</code> to parse an <code>object</code> where the value for each field is either <code>null</code> or an <code>A</code>, filtering out the <code>null</code>s</li><li><code>JsonParser.fieldOf[A](fieldName)</code> to parse a specific field from an object</li></ul><p>A DSL for creating json-specific ContextMatchers is provided to make it more convenient to call <code>Splitter.json</code>.
For example:</p><pre>Splitter.json(<span class="lit">"foo"</span> \ <span class="lit">"bar"</span>).as[<span class="std">String</span>].parseFirst</pre><p>Can be used to capture <code>rootJson.foo.bar</code> as a String in</p><pre>{
  <span class="lit">"foo"</span>: {
    <span class="lit">"bar"</span>: <span class="lit">"hello"</span>
  }
}</pre><p>To "split" values inside arrays, index-related context matchers are available, e.g.</p><pre>Splitter.json(<span class="lit">"foo"</span> \ anyIndex).as[<span class="std">Int</span>].parseToList</pre><p>Can be used to capture each of the numbers in the "foo" array in</p><pre>{
  <span class="lit">"foo"</span>: [<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>]
}</pre><p>A note about JsonEvents in spac:
JSON doesn't have any explicit markers for when a field ends, or when an array index starts or ends;
those context changes are essentially inferred by the presence of some other event.
For example, instead of a "field end" event, typically there will be either a new "field start" or a token representing the end of the current object.
With spac, splitters and context matchers generally operate under the assumption that a "stack push" event (like a field start) will eventually be
followed by a corresponding "stack pop" event (i.e. field end).</p><p>To allow for this, these "inferred" events (FieldEnd, IndexStart, IndexEnd) are explicitly represented as JsonEvents in the stream being parsed.
Keep this in mind when creating JSON ContextMatchers:</p><ul><li><code>field</code>-related matchers will match a stack like <code>case ObjectStart :: FieldStart(_) :: _</code></li><li><code>index</code>-related matchers will match a stack like <code>case ArrayStart :: IndexStart(_) :: _</code>
</li></ul></div></div></li><li class="indented0 " name="io.dylemma.spac.xml" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="xml" class="anchorToMember"></a><a id="xml:xml" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/xml/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="xml/index.html" title="This package provides extensions to the core &quot;spac&quot; library which allow for the handling of XML data."><span class="name">xml</span></a></span><p class="shortcomment cmt">This package provides extensions to the core "spac" library which allow for the handling of XML data.</p><div class="fullcomment"><div class="comment cmt"><p>This package provides extensions to the core "spac" library which allow for the handling of XML data.</p><p>Rather than creating explicit classes that extend <code>Parser</code>, <code>Transformer</code>, and <code>Splitter</code>,
this package provides type aliases and implicit extensions.
For example, <code>XmlParser[A]</code> is just a type alias for <code>Parser[XmlEvent, A]</code>,
and <code>XmlParser</code> is just a call to <code>Parser[XmlEvent]</code>.</p><p>Three main Parser methods are added to <code>Parser[XmlEvent]</code> via the <code>XmlParserApplyOps</code> implicit class:</p><ul><li><code>XmlParser.forText</code> - for capturing raw text</li><li><code>XmlParser.attr</code> - for capturing mandatory attributes from elements</li><li><code>XmlParser.attrOpt</code> - for capturing optional attributes from elements</li></ul><p>One main Splitter constructor method is added to <code>Splitter</code> via the <code>XmlSplitterApplyOps</code> implicit class:</p><ul><li><code>Splitter.xml</code> - for creating splitters based on an inspection of an "element stack"</li></ul><p>Three main Splitter member methods are added to <code>Splitter[XmlEvent, C]</code> via the <code>XmlSplitterOps</code> implicit class:</p><ul><li><code>.attr</code> - alias for <code>.joinBy(XmlParser.attr(...))</code></li><li><code>.attrOpt</code> - alias for <code>.joinBy(XmlParser.attrOpt(...))</code></li><li><code>.text</code> - alias for <code>.joinBy(XmlParser.forText)</code></li></ul><p>A DSL for creating xml-specific ContextMatchers is provided to make it more convenient to call <code>Splitter.xml</code>.
For example:</p><pre>Splitter.xml(<span class="lit">"things"</span> \ <span class="lit">"thing"</span>).attr(<span class="lit">"foo"</span>).parseToList</pre><p>Can be used to capture a list of the "foo" attributes in the <code>&lt;thing&gt;</code> elements in</p><pre>&lt;things&gt;
   &lt;thing foo=<span class="lit">"hello"</span> /&gt;
   &lt;thing foo=<span class="lit">"Goodbye"</span>&gt;
      &lt;extra&gt;junk&lt;/extra&gt;
   &lt;/thing&gt;
&lt;/thing&gt;</pre></div></div></li></ol></div><div id="types" class="types members"><h3>Type Members</h3><ol><li class="indented0 " name="io.dylemma.spac.CallerPos" group="errors" fullComment="yes" data-isabs="false" visbl="pub"><a id="CallerPosextendsProductwithSerializable" class="anchorToMember"></a><a id="CallerPos:CallerPos" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/CallerPos.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">case class</span></span> <span class="symbol"><a href="CallerPos.html" title="Represents a location in code that called a method."><span class="name">CallerPos</span></a><span class="params">(<span name="filename">filename: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="line">line: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result"> extends <span name="scala.Product" class="extype">Product</span> with <span name="scala.Serializable" class="extype">Serializable</span></span></span><p class="shortcomment cmt">Represents a location in code that called a method.</p><div class="fullcomment"><div class="comment cmt"><p>Represents a location in code that called a method.
An implicit instance of this class will be automatically derived by a macro on-demand.
CallerPos's ultimate purpose is to be present in certain <code>SpacTraceElement</code> classes,
helping to point to specific splitters or <code>parse</code> calls in the event of a parsing error.
</p></div></div></li><li class="indented0 " name="io.dylemma.spac.ContextChange" group="context" fullComment="yes" data-isabs="true" visbl="pub"><a id="ContextChange[+In,+C]extendsAnyRef" class="anchorToMember"></a><a id="ContextChange[+In,+C]:ContextChange[In,C]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/ContextChange.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">sealed </span> <span class="kind">trait</span></span> <span class="symbol"><a href="ContextChange.html" title="Represents either entering (ContextPush) or exiting (ContextPop) some matched context within a stream of inputs."><span class="name">ContextChange</span></a><span class="tparams">[<span name="In">+In</span>, <span name="C">+C</span>]</span><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">Represents either entering (<code>ContextPush</code>) or exiting (<code>ContextPop</code>) some matched context within a stream of inputs.</p><div class="fullcomment"><div class="comment cmt"><p>Represents either entering (<code>ContextPush</code>) or exiting (<code>ContextPop</code>) some matched context within a stream of inputs.</p><p>ContextChanges will generally be used to designate "sub-stream" boundaries, i.e. a selection of xml elements from within a stream,
but may be used more generally to attach a stack-like state to stream transformers.
</p></div><dl class="paramcmts block"><dt class="tparam">In</dt><dd class="cmt"><p>The value type of the elements in the stream being inspected</p></dd><dt class="tparam">C</dt><dd class="cmt"><p>The type of the matched context</p></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.ContextLocation" group="context" fullComment="no" data-isabs="true" visbl="pub"><a id="ContextLocationextendsAnyRef" class="anchorToMember"></a><a id="ContextLocation:ContextLocation" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/ContextLocation.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="ContextLocation.html" title="A map-like representation of some location in a stream, used like stack trace elements for reporting errors in stream processing."><span class="name">ContextLocation</span></a><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">A map-like representation of some location in a stream,
used like stack trace elements for reporting errors in stream processing.</p></li><li class="indented0 " name="io.dylemma.spac.ContextMatcher" group="context" fullComment="yes" data-isabs="true" visbl="pub"><a id="ContextMatcher[Elem,+A]extendsAnyRef" class="anchorToMember"></a><a id="ContextMatcher[Elem,+A]:ContextMatcher[Elem,A]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/ContextMatcher.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="ContextMatcher.html" title="An object responsible for inspecting a stack of StartElement events and determining if they correspond to some &quot;context&quot; value of type A."><span class="name">ContextMatcher</span></a><span class="tparams">[<span name="Elem">Elem</span>, <span name="A">+A</span>]</span><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">An object responsible for inspecting a stack of <code>StartElement</code> events and determining if they correspond
to some "context" value of type <code>A</code>.</p><div class="fullcomment"><div class="comment cmt"><p>An object responsible for inspecting a stack of <code>StartElement</code> events and determining if they correspond
to some "context" value of type <code>A</code>.</p><p><code>ContextMatcher</code>s play a primary role in splitting an XML event stream into "substreams", i.e. each
substream is defined as the series of consecutive events during which the XML tag stack matches a context.</p><p><code>ContextMatcher</code>s are intended to be transformed and combined with each other in order to build up
more complex matching functionality. See also: <code>SingleElementContextMatcher</code>, which contains additional
combination methods and some specialized transformation methods.
</p></div><dl class="paramcmts block"><dt class="tparam">A</dt><dd class="cmt"><p>The type of the matched context.</p></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.ContextPush" group="context" fullComment="no" data-isabs="false" visbl="pub"><a id="ContextPush[+In,+C]extendsContextChange[In,C]withProductwithSerializable" class="anchorToMember"></a><a id="ContextPush[+In,+C]:ContextPush[In,C]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/ContextPush.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">case class</span></span> <span class="symbol"><a href="ContextPush.html" title=""><span class="name">ContextPush</span></a><span class="tparams">[<span name="In">+In</span>, <span name="C">+C</span>]</span><span class="params">(<span name="location">location: <a href="ContextTrace.html" name="io.dylemma.spac.ContextTrace" id="io.dylemma.spac.ContextTrace" class="extype">ContextTrace</a>[<span name="io.dylemma.spac.ContextPush.In" class="extype">In</span>]</span>, <span name="context">context: <span name="io.dylemma.spac.ContextPush.C" class="extype">C</span></span>)</span><span class="result"> extends <a href="ContextChange.html" name="io.dylemma.spac.ContextChange" id="io.dylemma.spac.ContextChange" class="extype">ContextChange</a>[<span name="io.dylemma.spac.ContextPush.In" class="extype">In</span>, <span name="io.dylemma.spac.ContextPush.C" class="extype">C</span>] with <span name="scala.Product" class="extype">Product</span> with <span name="scala.Serializable" class="extype">Serializable</span></span></span><p class="shortcomment cmt"></p></li><li class="indented0 " name="io.dylemma.spac.ContextTrace" group="context" fullComment="no" data-isabs="false" visbl="pub"><a id="ContextTrace[+A]extendsProductwithSerializable" class="anchorToMember"></a><a id="ContextTrace[+A]:ContextTrace[A]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/ContextTrace.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">case class</span></span> <span class="symbol"><a href="ContextTrace.html" title=""><span class="name">ContextTrace</span></a><span class="tparams">[<span name="A">+A</span>]</span><span class="params">(<span name="elems">elems: <span name="cats.data.Chain" class="extype">Chain</span>[(<a href="ContextLocation.html" name="io.dylemma.spac.ContextLocation" id="io.dylemma.spac.ContextLocation" class="extype">ContextLocation</a>, <span name="io.dylemma.spac.ContextTrace.A" class="extype">A</span>)]</span>)</span><span class="result"> extends <span name="scala.Product" class="extype">Product</span> with <span name="scala.Serializable" class="extype">Serializable</span></span></span><p class="shortcomment cmt"></p></li><li class="indented0 " name="io.dylemma.spac.HasLocation" group="errors" fullComment="no" data-isabs="true" visbl="pub"><a id="HasLocationextendsAnyRef" class="anchorToMember"></a><a id="HasLocation:HasLocation" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/HasLocation.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="HasLocation.html" title="Marker trait used by SpacTraceElement.InInput to extract location information from inputs that cause parsing exceptions."><span class="name">HasLocation</span></a><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">Marker trait used by <code>SpacTraceElement.InInput</code> to extract location information from inputs that cause parsing exceptions.</p></li><li class="indented0 " name="io.dylemma.spac.LowPriorityTypeReduceImplicits" group="util" fullComment="no" data-isabs="true" visbl="pub"><a id="LowPriorityTypeReduceImplicitsextendsAnyRef" class="anchorToMember"></a><a id="LowPriorityTypeReduceImplicits:LowPriorityTypeReduceImplicits" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/LowPriorityTypeReduceImplicits.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="LowPriorityTypeReduceImplicits.html" title=""><span class="name">LowPriorityTypeReduceImplicits</span></a><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt"></p></li><li class="indented0 " name="io.dylemma.spac.Parser" group="primary" fullComment="yes" data-isabs="true" visbl="pub"><a id="Parser[-In,+Out]extendsAnyRef" class="anchorToMember"></a><a id="Parser[-In,+Out]:Parser[In,Out]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="Parser.html" title="Primary &quot;spac&quot; abstraction which represents a sink for data events."><span class="name">Parser</span></a><span class="tparams">[<span name="In">-In</span>, <span name="Out">+Out</span>]</span><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">Primary "spac" abstraction which represents a sink for data events.</p><div class="fullcomment"><div class="comment cmt"><p>Primary "spac" abstraction which represents a sink for data events.</p><p>Parsers are responsible for interpreting a stream of <code>In</code> events as a single result of type <code>Out</code>.
The actual interpretation is performed by a <code>Parser.Handler</code> which the Parser is responsible for constructing.
Handlers may be internally-mutable, and so they are generally only constructed by the <code>parse</code> helper methods or by other handlers.
Parsers themselves are immutable, acting as "handler factories", and so they may be freely reused.</p><p>A parser differs from typical "fold" operations in that it may choose to abort early with a result,
leaving the remainder of the data stream untouched.
</p></div><dl class="paramcmts block"><dt class="tparam">In</dt><dd class="cmt"><p>event/input type</p></dd><dt class="tparam">Out</dt><dd class="cmt"><p>result type</p></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.ParserApplyWithBoundInput" group="util" fullComment="yes" data-isabs="false" visbl="pub"><a id="ParserApplyWithBoundInput[In]extendsAnyRef" class="anchorToMember"></a><a id="ParserApplyWithBoundInput[In]:ParserApplyWithBoundInput[In]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/ParserApplyWithBoundInput.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">class</span></span> <span class="symbol"><a href="ParserApplyWithBoundInput.html" title="Convenience version of the Parser companion object, which provides parser constructors with the In type already specified."><span class="name">ParserApplyWithBoundInput</span></a><span class="tparams">[<span name="In">In</span>]</span><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">Convenience version of the <code>Parser</code> companion object, which provides parser constructors with the <code>In</code> type already specified.</p><div class="fullcomment"><div class="comment cmt"><p>Convenience version of the <code>Parser</code> companion object, which provides parser constructors with the <code>In</code> type already specified.
Integrations for XML and JSON will generally create implicit classes to add methods to this class for <code>In = XmlEvent</code> and <code>In = JsonEvent</code> respectively.
</p></div></div></li><li class="indented0 " name="io.dylemma.spac.Signal" group="util" fullComment="no" data-isabs="true" visbl="pub"><a id="SignalextendsAnyRef" class="anchorToMember"></a><a id="Signal:Signal" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Signal.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">sealed </span> <span class="kind">trait</span></span> <span class="symbol"><a href="Signal.html" title="Value used by Transformer.Handler to indicate to its upstream producer whether or not the handler wants to continue receiving values."><span class="name">Signal</span></a><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">Value used by <code>Transformer.Handler</code> to indicate to its upstream producer
whether or not the handler wants to continue receiving values.</p></li><li class="indented0 " name="io.dylemma.spac.SingleItemContextMatcher" group="context" fullComment="yes" data-isabs="true" visbl="pub"><a id="SingleItemContextMatcher[Item,+A]extendsContextMatcher[Item,A]" class="anchorToMember"></a><a id="SingleItemContextMatcher[Item,+A]:SingleItemContextMatcher[Item,A]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/SingleItemContextMatcher.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="SingleItemContextMatcher.html" title="Specialization of ContextMatcher which only checks the first element in the stack for matching operations."><span class="name">SingleItemContextMatcher</span></a><span class="tparams">[<span name="Item">Item</span>, <span name="A">+A</span>]</span><span class="result"> extends <a href="ContextMatcher.html" name="io.dylemma.spac.ContextMatcher" id="io.dylemma.spac.ContextMatcher" class="extype">ContextMatcher</a>[<span name="io.dylemma.spac.SingleItemContextMatcher.Item" class="extype">Item</span>, <span name="io.dylemma.spac.SingleItemContextMatcher.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Specialization of ContextMatcher which only checks the first element in the stack for matching operations.</p><div class="fullcomment"><div class="comment cmt"><p>Specialization of ContextMatcher which only checks the first element in the stack for matching operations.
Transformation operations on single-element matchers will yield other single-element matchers (rather than
the base ContextMatcher type). Combination operations involving other single-element matchers will also
yield single-element matchers.
SingleElementContextMatchers form the building blocks of more complex matchers.
</p></div><dl class="paramcmts block"><dt class="tparam">A</dt><dd class="cmt"><p>The type of the matched context.</p></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Source" group="util" fullComment="yes" data-isabs="true" visbl="pub"><a id="Source[+A]extendsAnyRef" class="anchorToMember"></a><a id="Source[+A]:Source[A]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Source.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="Source.html" title="A Source[A] is like an Iterable[A] but with a built-in assumption that the iterator may be closeable, intended for use as a convenient argument to a Parser's parse method."><span class="name">Source</span></a><span class="tparams">[<span name="A">+A</span>]</span><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">A <code>Source[A]</code> is like an <code>Iterable[A]</code> but with a built-in assumption that the iterator may be closeable,
intended for use as a convenient argument to a <code>Parser</code>'s <code>parse</code> method.</p><div class="fullcomment"><div class="comment cmt"><p>A <code>Source[A]</code> is like an <code>Iterable[A]</code> but with a built-in assumption that the iterator may be closeable,
intended for use as a convenient argument to a <code>Parser</code>'s <code>parse</code> method.</p><p>The spac core library avoids depending on Cats-Effect and FS2 (to avoid introducing "dependency hell"
situations for projects that must depend on pre-3.0 versions of those projects), so this class acts as
a stand-in for both <code>cats.effect.Resource</code> and <code>fs2.Stream</code> for non-async usage.
</p></div><dl class="paramcmts block"><dt class="tparam">A</dt><dd class="cmt"><p>Type of item emitted by Iterators from this Source</p></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.SpacException" group="errors" fullComment="yes" data-isabs="true" visbl="pub"><a id="SpacException[Self&lt;:io.dylemma.spac.SpacException[Self]]extendsExceptionwithNoStackTrace" class="anchorToMember"></a><a id="SpacException[Self&lt;:SpacException[Self]]:SpacException[Self]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/SpacException.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">class</span></span> <span class="symbol"><a href="SpacException.html" title="Base class for all exceptions thrown by Spac parsers."><span class="name">SpacException</span></a><span class="tparams">[<span name="Self">Self &lt;: <a href="SpacException.html" name="io.dylemma.spac.SpacException" id="io.dylemma.spac.SpacException" class="extype">SpacException</a>[<span name="io.dylemma.spac.SpacException.Self" class="extype">Self</span>]</span>]</span><span class="result"> extends <span name="scala.Exception" class="extype">Exception</span> with <span name="scala.util.control.NoStackTrace" class="extype">NoStackTrace</span></span></span><p class="shortcomment cmt">Base class for all exceptions thrown by Spac parsers.</p><div class="fullcomment"><div class="comment cmt"><p>Base class for all exceptions thrown by Spac parsers.
A <code>SpacException</code> holds a <code>spacTrace</code>, which is similar to a *stack* trace, but uses a specialized element type
to hold helpful debug information about the cause and context of the exception, and the input that caused it.</p><p>SpacException uses <code>NoStackTrace</code> to suppress the usual stack trace, since exceptions thrown by a Parser
will not have useful stack trace information for end users of the Spac framework.
</p></div><dl class="paramcmts block"><dt class="tparam">Self</dt><dd class="cmt"><p>self-type used in the type signature of <code>withSpacTrace</code></p></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.SpacTraceElement" group="errors" fullComment="yes" data-isabs="true" visbl="pub"><a id="SpacTraceElementextendsAnyRef" class="anchorToMember"></a><a id="SpacTraceElement:SpacTraceElement" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/SpacTraceElement.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="SpacTraceElement.html" title="A play on words vs StackTraceElement, a *Spac* trace element represents some contextual location inside the logic of a spac Parser, or the location of an input to that parser."><span class="name">SpacTraceElement</span></a><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">A play on words vs StackTraceElement, a *Spac* trace element represents some contextual location inside the logic of a spac Parser,
or the location of an input to that parser.</p><div class="fullcomment"><div class="comment cmt"><p>A play on words vs StackTraceElement, a *Spac* trace element represents some contextual location inside the logic of a spac Parser,
or the location of an input to that parser.
<code>SpacTraceElement</code>s are used by <code>SpacException</code> to provide useful debugging information for when a Parser fails.
</p></div></div></li><li class="indented0 " name="io.dylemma.spac.Splitter" group="primary" fullComment="yes" data-isabs="true" visbl="pub"><a id="Splitter[In,+C]extendsAnyRef" class="anchorToMember"></a><a id="Splitter[In,+C]:Splitter[In,C]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Splitter.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="Splitter.html" title="Primary &quot;spac&quot; abstraction that acts as a selector for sub-streams within a single input stream."><span class="name">Splitter</span></a><span class="tparams">[<span name="In">In</span>, <span name="C">+C</span>]</span><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">Primary "spac" abstraction that acts as a selector for sub-streams within a single input stream.</p><div class="fullcomment"><div class="comment cmt"><p>Primary "spac" abstraction that acts as a selector for sub-streams within a single input stream.</p><p>A "sub-stream" is some series of consecutive values from the original stream, identified by a "context" value.
Sub-streams do not overlap with each other.</p><p>For example, when handling a stream of XML events, you might want to create a Splitter that identifies
the events representing elements at a specific location within the XML; something like an XPATH that operates on streams.
When using <code>xml-spac</code>, you might construct a splitter like <code>Splitter.xml("rootElem" \ "things" \ "thing")</code>.
This would identify a new sub-stream for each <code>&lt;thing&gt;</code> element that appears inside a <code>&lt;things&gt;</code> element, inside the <code>&lt;rootElem&gt;</code> element.
An example sub-stream for a <code>&lt;thing&gt;</code> element might be <code>ElemStart("thing"), Text("hello"), ElemEnd("thing")</code>.</p><p>A Splitter's general goal is to attach a Parser or Transformer to each sub-stream, passing the contents of that sub-stream
through the attached Parser or Transformer in order to get an interpretation of that sub-stream (i.e. the Parser's result,
or some emitted outputs from a Transformer).
With the <code>&lt;thing&gt;</code> example above, you might attach a parser that concatenates the context all Text events it sees.
I.e. <code>XmlParser.forText</code>. Since a separate parser handler will run for each sub-stream, this becomes something like
"A stream of Strings which each represent the concatenated text from an individual <code>&lt;thing&gt;</code> element".
</p></div><dl class="paramcmts block"><dt class="tparam">In</dt><dd class="cmt"><p>Data event type for the input stream</p></dd><dt class="tparam">C</dt><dd class="cmt"><p>Context type used to identify each sub-stream</p></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.SplitterApplyWithBoundInput" group="util" fullComment="no" data-isabs="false" visbl="pub"><a id="SplitterApplyWithBoundInput[In]extendsAnyRef" class="anchorToMember"></a><a id="SplitterApplyWithBoundInput[In]:SplitterApplyWithBoundInput[In]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/SplitterApplyWithBoundInput.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">class</span></span> <span class="symbol"><a href="SplitterApplyWithBoundInput.html" title=""><span class="name">SplitterApplyWithBoundInput</span></a><span class="tparams">[<span name="In">In</span>]</span><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt"></p></li><li class="indented0 " name="io.dylemma.spac.StackInterpretation" group="util" fullComment="no" data-isabs="true" visbl="pub"><a id="StackInterpretation[+In,+Elem]extendsAnyRef" class="anchorToMember"></a><a id="StackInterpretation[+In,+Elem]:StackInterpretation[In,Elem]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/StackInterpretation.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">sealed </span> <span class="kind">trait</span></span> <span class="symbol"><a href="StackInterpretation.html" title="Outcome of a StackLike[In, Elem], indicating whether a given input was a stack push/pop, and whether that push/pop should be treated as happening before or after the input that caused it."><span class="name">StackInterpretation</span></a><span class="tparams">[<span name="In">+In</span>, <span name="Elem">+Elem</span>]</span><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">Outcome of a <code>StackLike[In, Elem]</code>, indicating whether a given input was a stack push/pop,
and whether that push/pop should be treated as happening before or after the input that caused it.</p></li><li class="indented0 " name="io.dylemma.spac.StackLike" group="util" fullComment="yes" data-isabs="true" visbl="pub"><a id="StackLike[In,+Elem]extendsAnyRef" class="anchorToMember"></a><a id="StackLike[In,+Elem]:StackLike[In,Elem]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/StackLike.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="StackLike.html" title="Typeclass that perceives a subset of In values as either &quot;stack push&quot; or &quot;stack pop&quot; events."><span class="name">StackLike</span></a><span class="tparams">[<span name="In">In</span>, <span name="Elem">+Elem</span>]</span><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">Typeclass that perceives a subset of <code>In</code> values as either "stack push" or "stack pop" events.</p><div class="fullcomment"><div class="comment cmt"><p>Typeclass that perceives a subset of <code>In</code> values as either "stack push" or "stack pop" events.
For example, with XML, an <code>ElemStart</code> event can be perceived as a "stack push", and a corresponding
<code>ElemEnd</code> event can be preceived as a "stack pop".
</p></div></div></li><li class="indented0 " name="io.dylemma.spac.Transformer" group="primary" fullComment="yes" data-isabs="true" visbl="pub"><a id="Transformer[-In,+Out]extendsAnyRef" class="anchorToMember"></a><a id="Transformer[-In,+Out]:Transformer[In,Out]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Transformer.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="Transformer.html" title="Primary &quot;spac&quot; abstraction which represents a transformation stage for a stream of data events"><span class="name">Transformer</span></a><span class="tparams">[<span name="In">-In</span>, <span name="Out">+Out</span>]</span><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">Primary "spac" abstraction which represents a transformation stage for a stream of data events</p><div class="fullcomment"><div class="comment cmt"><p>Primary "spac" abstraction which represents a transformation stage for a stream of data events</p><p>Transformers effectively transform a stream of <code>In</code> events into a stream of <code>Out</code> events.
The actual stream handling logic is defined by a <code>Transformer.Handler</code>, which a <code>Transformer</code> is responsible for constructing.
Handlers may be internally-mutable, and so they are generally only constructed by other handlers.
Transformers themselves are immutable, acting as "handler factories", and so they may be freely reused.</p><p>A transformer may choose to abort in response to any input event,
as well as emit any number of outputs in response to an input event or the EOF signal.
</p></div><dl class="paramcmts block"><dt class="tparam">In</dt><dd class="cmt"><p>The incoming event type</p></dd><dt class="tparam">Out</dt><dd class="cmt"><p>The outgoing event type</p></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.TransformerApplyWithBoundInput" group="util" fullComment="no" data-isabs="false" visbl="pub"><a id="TransformerApplyWithBoundInput[In]extendsAnyRef" class="anchorToMember"></a><a id="TransformerApplyWithBoundInput[In]:TransformerApplyWithBoundInput[In]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/TransformerApplyWithBoundInput.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">class</span></span> <span class="symbol"><a href="TransformerApplyWithBoundInput.html" title="Convenience version of the Transformer companion object, which provides transformer constructors with the In type already specified."><span class="name">TransformerApplyWithBoundInput</span></a><span class="tparams">[<span name="In">In</span>]</span><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">Convenience version of the <code>Transformer</code> companion object,
which provides transformer constructors with the <code>In</code> type already specified.</p></li><li class="indented0 " name="io.dylemma.spac.TypeReduce" group="util" fullComment="yes" data-isabs="true" visbl="pub"><a id="TypeReduce[-In1,-In2]extendsAnyRef" class="anchorToMember"></a><a id="TypeReduce[-In1,-In2]:TypeReduce[In1,In2]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/TypeReduce.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="TypeReduce.html" title="Type-level tuple reduction function that treats Unit as an Identity."><span class="name">TypeReduce</span></a><span class="tparams">[<span name="In1">-In1</span>, <span name="In2">-In2</span>]</span><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">Type-level tuple reduction function that treats <code>Unit</code> as an Identity.</p><div class="fullcomment"><div class="comment cmt"><p>Type-level tuple reduction function that treats <code>Unit</code> as an Identity.
For example:</p><pre>TypeReduce[(<span class="std">Unit</span>, <span class="std">Unit</span>)]{ <span class="kw">type</span> Out = <span class="std">Unit</span> }
TypeReduce[(T, <span class="std">Unit</span>)]{ <span class="kw">type</span> Out = T }
TypeReduce[(<span class="std">Unit</span>, T)]{ <span class="kw">type</span> Out = T }
TypeReduce[(L, R)]{ <span class="kw">type</span> Out = (L, R) }</pre></div></div></li><li class="indented0 " name="io.dylemma.spac.Unconsable" group="util" fullComment="no" data-isabs="true" visbl="pub"><a id="Unconsable[C[_]]extendsAnyRef" class="anchorToMember"></a><a id="Unconsable[C[_]]:Unconsable[C]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Unconsable.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="Unconsable.html" title="Typeclass for collections that can be efficiently split into a head element and a tail collection as long as they are not empty."><span class="name">Unconsable</span></a><span class="tparams">[<span name="C">C<span class="tparams">[<span name="_">_</span>]</span></span>]</span><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">Typeclass for collections that can be efficiently split into a
<code>head</code> element and a <code>tail</code> collection as long as they are not empty.</p></li></ol></div><div class="values members"><h3>Value Members</h3><ol><li class="indented0 " name="io.dylemma.spac.CallerPos" group="errors" fullComment="no" data-isabs="false" visbl="pub"><a id="CallerPos" class="anchorToMember"></a><a id="CallerPos:CallerPos" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/CallerPos$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="CallerPos$.html" title=""><span class="name">CallerPos</span></a><span class="result"> extends <a href="https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html#java.io.Serializable" name="java.io.Serializable" id="java.io.Serializable" class="extype">Serializable</a></span></span><p class="shortcomment cmt"></p></li><li class="indented0 " name="io.dylemma.spac.ContextLocation" group="context" fullComment="no" data-isabs="false" visbl="pub"><a id="ContextLocation" class="anchorToMember"></a><a id="ContextLocation:ContextLocation" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/ContextLocation$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="ContextLocation$.html" title=""><span class="name">ContextLocation</span></a></span><p class="shortcomment cmt"></p></li><li class="indented0 " name="io.dylemma.spac.ContextMatcher" group="context" fullComment="no" data-isabs="false" visbl="pub"><a id="ContextMatcher" class="anchorToMember"></a><a id="ContextMatcher:ContextMatcher" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/ContextMatcher$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="ContextMatcher$.html" title=""><span class="name">ContextMatcher</span></a></span><p class="shortcomment cmt"></p></li><li class="indented0 " name="io.dylemma.spac.ContextPop" group="context" fullComment="no" data-isabs="false" visbl="pub"><a id="ContextPop" class="anchorToMember"></a><a id="ContextPop:ContextPop" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/ContextPop$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">case object</span></span> <span class="symbol"><a href="ContextPop$.html" title=""><span class="name">ContextPop</span></a><span class="result"> extends <a href="ContextChange.html" name="io.dylemma.spac.ContextChange" id="io.dylemma.spac.ContextChange" class="extype">ContextChange</a>[<span name="scala.Nothing" class="extype">Nothing</span>, <span name="scala.Nothing" class="extype">Nothing</span>] with <span name="scala.Product" class="extype">Product</span> with <span name="scala.Serializable" class="extype">Serializable</span></span></span><p class="shortcomment cmt"></p></li><li class="indented0 " name="io.dylemma.spac.ContextTrace" group="context" fullComment="no" data-isabs="false" visbl="pub"><a id="ContextTrace" class="anchorToMember"></a><a id="ContextTrace:ContextTrace" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/ContextTrace$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="ContextTrace$.html" title=""><span class="name">ContextTrace</span></a><span class="result"> extends <a href="https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html#java.io.Serializable" name="java.io.Serializable" id="java.io.Serializable" class="extype">Serializable</a></span></span><p class="shortcomment cmt"></p></li><li class="indented0 " name="io.dylemma.spac.Parser" group="primary" fullComment="no" data-isabs="false" visbl="pub"><a id="Parser" class="anchorToMember"></a><a id="Parser:Parser" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="Parser$.html" title=""><span class="name">Parser</span></a></span><p class="shortcomment cmt"></p></li><li class="indented0 " name="io.dylemma.spac.Signal" group="util" fullComment="no" data-isabs="false" visbl="pub"><a id="Signal" class="anchorToMember"></a><a id="Signal:Signal" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Signal$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="Signal$.html" title=""><span class="name">Signal</span></a></span><p class="shortcomment cmt"></p></li><li class="indented0 " name="io.dylemma.spac.SingleItemContextMatcher" group="context" fullComment="no" data-isabs="false" visbl="pub"><a id="SingleItemContextMatcher" class="anchorToMember"></a><a id="SingleItemContextMatcher:SingleItemContextMatcher" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/SingleItemContextMatcher$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="SingleItemContextMatcher$.html" title=""><span class="name">SingleItemContextMatcher</span></a></span><p class="shortcomment cmt"></p></li><li class="indented0 " name="io.dylemma.spac.Source" group="util" fullComment="no" data-isabs="false" visbl="pub"><a id="Source" class="anchorToMember"></a><a id="Source:Source" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Source$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="Source$.html" title="Note: this companion object provides a few very basic Source-constructor helpers, but the real useful functionality is provided by the &quot;parser backend&quot; modules like xml-spac-javax and json-spac-jackson, via JavaxSource and JacksonSource."><span class="name">Source</span></a></span><p class="shortcomment cmt">Note: this companion object provides a few very basic Source-constructor helpers,
but the real useful functionality is provided by the "parser backend" modules like
<code>xml-spac-javax</code> and <code>json-spac-jackson</code>, via <code>JavaxSource</code> and <code>JacksonSource</code>.</p></li><li class="indented0 " name="io.dylemma.spac.SpacException" group="errors" fullComment="no" data-isabs="false" visbl="pub"><a id="SpacException" class="anchorToMember"></a><a id="SpacException:SpacException" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/SpacException$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="SpacException$.html" title=""><span class="name">SpacException</span></a><span class="result"> extends <a href="https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html#java.io.Serializable" name="java.io.Serializable" id="java.io.Serializable" class="extype">Serializable</a></span></span><p class="shortcomment cmt"></p></li><li class="indented0 " name="io.dylemma.spac.SpacTraceElement" group="errors" fullComment="no" data-isabs="false" visbl="pub"><a id="SpacTraceElement" class="anchorToMember"></a><a id="SpacTraceElement:SpacTraceElement" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/SpacTraceElement$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="SpacTraceElement$.html" title=""><span class="name">SpacTraceElement</span></a></span><p class="shortcomment cmt"></p></li><li class="indented0 " name="io.dylemma.spac.Splitter" group="primary" fullComment="no" data-isabs="false" visbl="pub"><a id="Splitter" class="anchorToMember"></a><a id="Splitter:Splitter" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Splitter$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="Splitter$.html" title=""><span class="name">Splitter</span></a></span><p class="shortcomment cmt"></p></li><li class="indented0 " name="io.dylemma.spac.StackInterpretation" group="util" fullComment="no" data-isabs="false" visbl="pub"><a id="StackInterpretation" class="anchorToMember"></a><a id="StackInterpretation:StackInterpretation" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/StackInterpretation$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="StackInterpretation$.html" title=""><span class="name">StackInterpretation</span></a></span><p class="shortcomment cmt"></p></li><li class="indented0 " name="io.dylemma.spac.Transformer" group="primary" fullComment="no" data-isabs="false" visbl="pub"><a id="Transformer" class="anchorToMember"></a><a id="Transformer:Transformer" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Transformer$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="Transformer$.html" title=""><span class="name">Transformer</span></a></span><p class="shortcomment cmt"></p></li><li class="indented0 " name="io.dylemma.spac.TypeReduce" group="util" fullComment="no" data-isabs="false" visbl="pub"><a id="TypeReduce" class="anchorToMember"></a><a id="TypeReduce:TypeReduce" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/TypeReduce$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="TypeReduce$.html" title=""><span class="name">TypeReduce</span></a><span class="result"> extends <a href="LowPriorityTypeReduceImplicits.html" name="io.dylemma.spac.LowPriorityTypeReduceImplicits" id="io.dylemma.spac.LowPriorityTypeReduceImplicits" class="extype">LowPriorityTypeReduceImplicits</a></span></span><p class="shortcomment cmt"></p></li><li class="indented0 " name="io.dylemma.spac.Unconsable" group="util" fullComment="no" data-isabs="false" visbl="pub"><a id="Unconsable" class="anchorToMember"></a><a id="Unconsable:Unconsable" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Unconsable$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="Unconsable$.html" title=""><span class="name">Unconsable</span></a></span><p class="shortcomment cmt"></p></li></ol></div></div><div id="inheritedMembers"><div name="scala.AnyRef" class="parent"><h3>Inherited from <span name="scala.AnyRef" class="extype">AnyRef</span></h3></div><div name="scala.Any" class="parent"><h3>Inherited from <span name="scala.Any" class="extype">Any</span></h3></div></div><div id="groupedMembers"><div name="primary" class="group"><h3>Main Concepts</h3><div class="comment cmt"><p>All event consumers in SPaC are defined in terms of <code>Parser</code>, <code>Splitter</code>, and <code>Transformer</code>.
           Each of these three classes are interrelated, but with the eventual goal of producing one or more
           interpreted values given an incoming stream of event data.</p></div></div><div name="errors" class="group"><h3>Error Handling</h3><div class="comment cmt"><p>SPaC parsers should only ever throw <code>SpacException</code> from their <code>parse</code> and <code>parseF</code> methods.
           SpacException is a specialized exception type which uses "Spac Trace" elements instead of the usual
           "Stack Trace"; these provide more useful information like what part of the parser failed, some
           contextual information about what event caused the parser to fail.</p></div></div><div name="context" class="group"><h3>Capturing Context Data</h3><div class="comment cmt"><p>When dealing with tree-like documents, it is often important to be able to express a relative
           location in that data, or to produce some value based on the current location within the tree.
           SPaC refers to these locations as "context".</p></div></div><div name="util" class="group"><h3>Utility and Supporting Classes</h3><div class="comment cmt"><p>Most of these classes and traits are typeclasses that the primary types operate in terms of.
           Generally you don't directly interact with these.</p></div></div><div name="Ungrouped" class="group"><h3>Ungrouped</h3></div></div></div><div id="tooltip"></div><div id="footer"></div></body></div></div></div></body></html>

<!DOCTYPE html ><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/><title></title><meta content="" name="description"/><meta content="" name="keywords"/><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><link href="../../../lib/index.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../../lib/template.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../../lib/print.css" media="print" type="text/css" rel="stylesheet"/><link href="../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css"/><script type="text/javascript" src="../../../lib/jquery.min.js"></script><script type="text/javascript" src="../../../lib/index.js"></script><script type="text/javascript" src="../../../index.js"></script><script type="text/javascript" src="../../../lib/scheduler.js"></script><script type="text/javascript" src="../../../lib/template.js"></script><script type="text/javascript">/* this variable can be used by the JS to determine the path to the root document */
var toRoot = '../../../';</script></head><body><div id="search"><span id="doc-title"><span id="doc-version"></span></span> <span class="close-results"><span class="left">&lt;</span> Back</span><div id="textfilter"><span class="input"><input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/"/><i class="clear material-icons"></i><i id="search-icon" class="material-icons"></i></span></div></div><div id="search-results"><div id="search-progress"><div id="progress-fill"></div></div><div id="results-content"><div id="entity-results"></div><div id="member-results"></div></div></div><div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;"><div id="content-container" style="-webkit-overflow-scrolling: touch;"><div id="subpackage-spacer"><div id="packages"><h1>Packages</h1><ul><li class="indented0 " name="_root_.root" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="_root_" class="anchorToMember"></a><a id="root:_root_" class="anchorToMember"></a> <span class="permalink"><a href="../../../index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../../index.html" title=""><span class="name">root</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented1 " name="_root_.io" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="io" class="anchorToMember"></a><a id="io:io" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../index.html" title=""><span class="name">io</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented2 " name="io.dylemma" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="dylemma" class="anchorToMember"></a><a id="dylemma:dylemma" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../index.html" title=""><span class="name">dylemma</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../index.html" name="io" id="io" class="extype">io</a></dd></dl></div></li><li class="indented3 " name="io.dylemma.spac" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="spac" class="anchorToMember"></a><a id="spac:spac" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="index.html" title="SPaC (short for &quot;Streaming Parser Combinators&quot;) is a library for building stream consumers in a declarative style, specialized for tree-like data types like XML and JSON."><span class="name">spac</span></a></span><p class="shortcomment cmt">SPaC (short for "<strong>S</strong>treaming <strong>Pa</strong>rser <strong>C</strong>ombinators")
is a library for building stream consumers in a declarative style, specialized for tree-like data
types like XML and JSON.</p><div class="fullcomment"><div class="comment cmt"><p>SPaC (short for "<strong>S</strong>treaming <strong>Pa</strong>rser <strong>C</strong>ombinators")
is a library for building stream consumers in a declarative style, specialized for tree-like data
types like XML and JSON.</p><p>Many utilities for handling XML and JSON data involve parsing the entire "document" to some DOM model,
then inspecting and transforming that model to extract information.
The downside to these utilities is that when the document is very large, the DOM may not fit in memory.
The workaround for this type of problem is to treat the document as a stream of "events",
e.g. "StartElement" and "EndElement" for XML, or "StartObject" and "EndObject" for JSON.
The downside to this workaround is that writing code to handle these streams can be complicated and
error-prone, especially when the DOM is complicated.</p><p>SPaC's goal is to drastically simplify the process of creating code to handle these streams.</p><p>This package contains the "core" SPaC traits; <code>Parser</code>, <code>Transformer</code>, <code>Splitter</code>, and <code>ContextMatcher</code>.</p><p>See the <code>xml</code> and <code>json</code> subpackages (provided by the <code>xml-spac</code> and <code>json-spac</code> libraries respectively)
for specific utilities related to handling XML and JSON event streams.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="io.dylemma" id="io.dylemma" class="extype">dylemma</a></dd></dl></div></li><li class="indented4 " name="io.dylemma.spac.interop" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="interop" class="anchorToMember"></a><a id="interop:interop" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/interop/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="interop/index.html" title=""><span class="name">interop</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="index.html" name="io.dylemma.spac" id="io.dylemma.spac" class="extype">spac</a></dd></dl></div></li><li class="indented4 " name="io.dylemma.spac.json" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="json" class="anchorToMember"></a><a id="json:json" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/json/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="json/index.html" title="This package provides extensions to the core &quot;spac&quot; library which allow for the handling of JSON data."><span class="name">json</span></a></span><p class="shortcomment cmt">This package provides extensions to the core "spac" library which allow for the handling of JSON data.</p><div class="fullcomment"><div class="comment cmt"><p>This package provides extensions to the core "spac" library which allow for the handling of JSON data.</p><p>Rather than creating explicit classes that extend <code>Parser</code>, <code>Transformer</code>, and <code>Splitter</code>,
this package provides type aliases and implicit extensions.
For example, <code>JsonParser[A]</code> is just a type alias for <code>Parser[JsonEvent, A]</code>,
and <code>JsonParser</code> is just a call to <code>Parser[JsonEvent]</code>.</p><p>Implicit JsonParsers are available for each of the JSON primitive types:</p><ul><li><code>string</code></li><li><code>number</code> (expressed as <code>Int</code>, <code>Long</code>, <code>Float</code>, or <code>Double</code>)</li><li><code>boolean</code></li><li><code>null</code> (expressed as <code>None.type</code>)</li></ul><p>Helpers are available for parsing JSON arrays and objects:</p><ul><li><code>JsonParser.listOf[A]</code> to parse an <code>array</code><code> where each value is an </code>A<code></code></li><li><code>JsonParser.objectOf[A]</code> to parse an <code>object</code> where the value for each field an <code>A</code></li><li><code>JsonParser.objectOfNullable[A]</code> to parse an <code>object</code> where the value for each field is either <code>null</code> or an <code>A</code>, filtering out the <code>null</code>s</li><li><code>JsonParser.fieldOf[A](fieldName)</code> to parse a specific field from an object</li></ul><p>A DSL for creating json-specific ContextMatchers is provided to make it more convenient to call <code>Splitter.json</code>.
For example:</p><pre>Splitter.json(<span class="lit">"foo"</span> \ <span class="lit">"bar"</span>).as[<span class="std">String</span>].parseFirst</pre><p>Can be used to capture <code>rootJson.foo.bar</code> as a String in</p><pre>{
  <span class="lit">"foo"</span>: {
    <span class="lit">"bar"</span>: <span class="lit">"hello"</span>
  }
}</pre><p>To "split" values inside arrays, index-related context matchers are available, e.g.</p><pre>Splitter.json(<span class="lit">"foo"</span> \ anyIndex).as[<span class="std">Int</span>].parseToList</pre><p>Can be used to capture each of the numbers in the "foo" array in</p><pre>{
  <span class="lit">"foo"</span>: [<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>]
}</pre><p>A note about JsonEvents in spac:
JSON doesn't have any explicit markers for when a field ends, or when an array index starts or ends;
those context changes are essentially inferred by the presence of some other event.
For example, instead of a "field end" event, typically there will be either a new "field start" or a token representing the end of the current object.
With spac, splitters and context matchers generally operate under the assumption that a "stack push" event (like a field start) will eventually be
followed by a corresponding "stack pop" event (i.e. field end).</p><p>To allow for this, these "inferred" events (FieldEnd, IndexStart, IndexEnd) are explicitly represented as JsonEvents in the stream being parsed.
Keep this in mind when creating JSON ContextMatchers:</p><ul><li><code>field</code>-related matchers will match a stack like <code>case ObjectStart :: FieldStart(_) :: _</code></li><li><code>index</code>-related matchers will match a stack like <code>case ArrayStart :: IndexStart(_) :: _</code>
</li></ul></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="index.html" name="io.dylemma.spac" id="io.dylemma.spac" class="extype">spac</a></dd></dl></div></li><li class="indented4 " name="io.dylemma.spac.xml" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="xml" class="anchorToMember"></a><a id="xml:xml" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/xml/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="xml/index.html" title="This package provides extensions to the core &quot;spac&quot; library which allow for the handling of XML data."><span class="name">xml</span></a></span><p class="shortcomment cmt">This package provides extensions to the core "spac" library which allow for the handling of XML data.</p><div class="fullcomment"><div class="comment cmt"><p>This package provides extensions to the core "spac" library which allow for the handling of XML data.</p><p>Rather than creating explicit classes that extend <code>Parser</code>, <code>Transformer</code>, and <code>Splitter</code>,
this package provides type aliases and implicit extensions.
For example, <code>XmlParser[A]</code> is just a type alias for <code>Parser[XmlEvent, A]</code>,
and <code>XmlParser</code> is just a call to <code>Parser[XmlEvent]</code>.</p><p>Three main Parser methods are added to <code>Parser[XmlEvent]</code> via the <code>XmlParserApplyOps</code> implicit class:</p><ul><li><code>XmlParser.forText</code> - for capturing raw text</li><li><code>XmlParser.attr</code> - for capturing mandatory attributes from elements</li><li><code>XmlParser.attrOpt</code> - for capturing optional attributes from elements</li></ul><p>One main Splitter constructor method is added to <code>Splitter</code> via the <code>XmlSplitterApplyOps</code> implicit class:</p><ul><li><code>Splitter.xml</code> - for creating splitters based on an inspection of an "element stack"</li></ul><p>Three main Splitter member methods are added to <code>Splitter[XmlEvent, C]</code> via the <code>XmlSplitterOps</code> implicit class:</p><ul><li><code>.attr</code> - alias for <code>.joinBy(XmlParser.attr(...))</code></li><li><code>.attrOpt</code> - alias for <code>.joinBy(XmlParser.attrOpt(...))</code></li><li><code>.text</code> - alias for <code>.joinBy(XmlParser.forText)</code></li></ul><p>A DSL for creating xml-specific ContextMatchers is provided to make it more convenient to call <code>Splitter.xml</code>.
For example:</p><pre>Splitter.xml(<span class="lit">"things"</span> \ <span class="lit">"thing"</span>).attr(<span class="lit">"foo"</span>).parseToList</pre><p>Can be used to capture a list of the "foo" attributes in the <code>&lt;thing&gt;</code> elements in</p><pre>&lt;things&gt;
   &lt;thing foo=<span class="lit">"hello"</span> /&gt;
   &lt;thing foo=<span class="lit">"Goodbye"</span>&gt;
      &lt;extra&gt;junk&lt;/extra&gt;
   &lt;/thing&gt;
&lt;/thing&gt;</pre></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="index.html" name="io.dylemma.spac" id="io.dylemma.spac" class="extype">spac</a></dd></dl></div></li><li class="current-entities indented3"><a href="CallerPos$.html" title="" class="object"></a> <a href="CallerPos.html" title="Represents a location in code that called a method." class="class"></a><a href="CallerPos.html" title="Represents a location in code that called a method.">CallerPos</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="ContextChange.html" title="Represents either entering (ContextPush) or exiting (ContextPop) some matched context within a stream of inputs." class="trait"></a><a href="ContextChange.html" title="Represents either entering (ContextPush) or exiting (ContextPop) some matched context within a stream of inputs.">ContextChange</a></li><li class="current-entities indented3"><a href="ContextLocation$.html" title="" class="object"></a> <a href="ContextLocation.html" title="A map-like representation of some location in a stream, used like stack trace elements for reporting errors in stream processing." class="trait"></a><a href="ContextLocation.html" title="A map-like representation of some location in a stream, used like stack trace elements for reporting errors in stream processing.">ContextLocation</a></li><li class="current-entities indented3"><a href="ContextMatcher$.html" title="" class="object"></a> <a href="ContextMatcher.html" title="An object responsible for inspecting a stack of StartElement events and determining if they correspond to some &quot;context&quot; value of type A." class="trait"></a><a href="ContextMatcher.html" title="An object responsible for inspecting a stack of StartElement events and determining if they correspond to some &quot;context&quot; value of type A.">ContextMatcher</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="ContextPop$.html" title="" class="object"></a><a href="ContextPop$.html" title="">ContextPop</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="ContextPush.html" title="" class="class"></a><a href="ContextPush.html" title="">ContextPush</a></li><li class="current-entities indented3"><a href="ContextTrace$.html" title="" class="object"></a> <a href="ContextTrace.html" title="" class="class"></a><a href="ContextTrace.html" title="">ContextTrace</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="HasLocation.html" title="Marker trait used by SpacTraceElement.InInput to extract location information from inputs that cause parsing exceptions." class="trait"></a><a href="HasLocation.html" title="Marker trait used by SpacTraceElement.InInput to extract location information from inputs that cause parsing exceptions.">HasLocation</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="LowPriorityTypeReduceImplicits.html" title="" class="trait"></a><a href="LowPriorityTypeReduceImplicits.html" title="">LowPriorityTypeReduceImplicits</a></li><li class="current-entities indented3"><a href="" title="" class="object"></a> <a href="Parser.html" title="Primary &quot;spac&quot; abstraction which represents a sink for data events." class="trait"></a><a href="Parser.html" title="Primary &quot;spac&quot; abstraction which represents a sink for data events.">Parser</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="ParserApplyWithBoundInput.html" title="Convenience version of the Parser companion object, which provides parser constructors with the In type already specified." class="class"></a><a href="ParserApplyWithBoundInput.html" title="Convenience version of the Parser companion object, which provides parser constructors with the In type already specified.">ParserApplyWithBoundInput</a></li><li class="current-entities indented3"><a href="Signal$.html" title="" class="object"></a> <a href="Signal.html" title="Value used by Transformer.Handler to indicate to its upstream producer whether or not the handler wants to continue receiving values." class="trait"></a><a href="Signal.html" title="Value used by Transformer.Handler to indicate to its upstream producer whether or not the handler wants to continue receiving values.">Signal</a></li><li class="current-entities indented3"><a href="SingleItemContextMatcher$.html" title="" class="object"></a> <a href="SingleItemContextMatcher.html" title="Specialization of ContextMatcher which only checks the first element in the stack for matching operations." class="trait"></a><a href="SingleItemContextMatcher.html" title="Specialization of ContextMatcher which only checks the first element in the stack for matching operations.">SingleItemContextMatcher</a></li><li class="current-entities indented3"><a href="Source$.html" title="Note: this companion object provides a few very basic Source-constructor helpers, but the real useful functionality is provided by the &quot;parser backend&quot; modules like xml-spac-javax and json-spac-jackson, via JavaxSource and JacksonSource." class="object"></a> <a href="Source.html" title="A Source[A] is like an Iterable[A] but with a built-in assumption that the iterator may be closeable, intended for use as a convenient argument to a Parser's parse method." class="trait"></a><a href="Source.html" title="A Source[A] is like an Iterable[A] but with a built-in assumption that the iterator may be closeable, intended for use as a convenient argument to a Parser's parse method.">Source</a></li><li class="current-entities indented3"><a href="SpacException$.html" title="" class="object"></a> <a href="SpacException.html" title="Base class for all exceptions thrown by Spac parsers." class="class"></a><a href="SpacException.html" title="Base class for all exceptions thrown by Spac parsers.">SpacException</a></li><li class="current-entities indented3"><a href="SpacTraceElement$.html" title="" class="object"></a> <a href="SpacTraceElement.html" title="A play on words vs StackTraceElement, a *Spac* trace element represents some contextual location inside the logic of a spac Parser, or the location of an input to that parser." class="trait"></a><a href="SpacTraceElement.html" title="A play on words vs StackTraceElement, a *Spac* trace element represents some contextual location inside the logic of a spac Parser, or the location of an input to that parser.">SpacTraceElement</a></li><li class="current-entities indented3"><a href="Splitter$.html" title="" class="object"></a> <a href="Splitter.html" title="Primary &quot;spac&quot; abstraction that acts as a selector for sub-streams within a single input stream." class="trait"></a><a href="Splitter.html" title="Primary &quot;spac&quot; abstraction that acts as a selector for sub-streams within a single input stream.">Splitter</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="SplitterApplyWithBoundInput.html" title="" class="class"></a><a href="SplitterApplyWithBoundInput.html" title="">SplitterApplyWithBoundInput</a></li><li class="current-entities indented3"><a href="StackInterpretation$.html" title="" class="object"></a> <a href="StackInterpretation.html" title="Outcome of a StackLike[In, Elem], indicating whether a given input was a stack push/pop, and whether that push/pop should be treated as happening before or after the input that caused it." class="trait"></a><a href="StackInterpretation.html" title="Outcome of a StackLike[In, Elem], indicating whether a given input was a stack push/pop, and whether that push/pop should be treated as happening before or after the input that caused it.">StackInterpretation</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="StackLike.html" title="Typeclass that perceives a subset of In values as either &quot;stack push&quot; or &quot;stack pop&quot; events." class="trait"></a><a href="StackLike.html" title="Typeclass that perceives a subset of In values as either &quot;stack push&quot; or &quot;stack pop&quot; events.">StackLike</a></li><li class="current-entities indented3"><a href="Transformer$.html" title="" class="object"></a> <a href="Transformer.html" title="Primary &quot;spac&quot; abstraction which represents a transformation stage for a stream of data events" class="trait"></a><a href="Transformer.html" title="Primary &quot;spac&quot; abstraction which represents a transformation stage for a stream of data events">Transformer</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="TransformerApplyWithBoundInput.html" title="Convenience version of the Transformer companion object, which provides transformer constructors with the In type already specified." class="class"></a><a href="TransformerApplyWithBoundInput.html" title="Convenience version of the Transformer companion object, which provides transformer constructors with the In type already specified.">TransformerApplyWithBoundInput</a></li><li class="current-entities indented3"><a href="TypeReduce$.html" title="" class="object"></a> <a href="TypeReduce.html" title="Type-level tuple reduction function that treats Unit as an Identity." class="trait"></a><a href="TypeReduce.html" title="Type-level tuple reduction function that treats Unit as an Identity.">TypeReduce</a></li><li class="current-entities indented3"><a href="Unconsable$.html" title="" class="object"></a> <a href="Unconsable.html" title="Typeclass for collections that can be efficiently split into a head element and a tail collection as long as they are not empty." class="trait"></a><a href="Unconsable.html" title="Typeclass for collections that can be efficiently split into a head element and a tail collection as long as they are not empty.">Unconsable</a></li></ul></div></div><div id="content"><body class="object value"><div id="definition"><a href="Parser.html" title="See companion trait"><div class="big-circle object-companion-trait">o</div></a><p id="owner"><a href="../../index.html" name="io" id="io" class="extype">io</a>.<a href="../index.html" name="io.dylemma" id="io.dylemma" class="extype">dylemma</a>.<a href="index.html" name="io.dylemma.spac" id="io.dylemma.spac" class="extype">spac</a></p><h1><a href="Parser.html" title="See companion trait">Parser</a><span class="permalink"><a href="../../../io/dylemma/spac/Parser$.html" title="Permalink"><i class="material-icons"></i></a></span></h1><h3><span class="morelinks"><div>Companion <a href="Parser.html" title="See companion trait">trait Parser</a></div></span></h3></div><h4 id="signature" class="signature"><span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><span class="name">Parser</span></span></h4><div id="comment" class="fullcommenttop"><div class="comment cmt"></div><dl class="attributes block"><dt>Source</dt><dd><a href="https://github.com/dylemma/xml-spac/tree/0.10.0/core/src/main/scala/io/dylemma/spac/Parser.scala" target="_blank">Parser.scala</a></dd></dl><div class="toggleContainer"><div class="toggle block"><span>Linear Supertypes</span><div class="superTypes hiddenContent"><span name="scala.AnyRef" class="extype">AnyRef</span>, <span name="scala.Any" class="extype">Any</span></div></div></div></div><div id="mbrsel"><div class="toggle"></div><div id="memberfilter"><i class="material-icons arrow"></i><span class="input"><input placeholder="Filter all members" id="mbrsel-input" type="text" accesskey="/"/></span><i class="clear material-icons"></i></div><div id="filterby"><div id="order"><span class="filtertype">Ordering</span><ol><li class="alpha in"><span>Alphabetic</span></li><li class="inherit out"><span>By Inheritance</span></li></ol></div><div class="ancestors"><span class="filtertype">Inherited<br/></span><ol id="linearization"><li class="in" name="io.dylemma.spac.Parser"><span>Parser</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li></ol></div><div class="ancestors"><span class="filtertype"></span><ol><li class="hideall out"><span>Hide All</span></li><li class="showall in"><span>Show All</span></li></ol></div><div id="visbl"><span class="filtertype">Visibility</span><ol><li class="public in"><span>Public</span></li><li class="protected out"><span>Protected</span></li></ol></div></div></div><div id="template"><div id="allMembers"><div id="types" class="types members"><h3>Type Members</h3><ol><li class="indented0 " name="io.dylemma.spac.Parser.FollowedBy" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="FollowedBy[In,+A,M[-_,+_]]extendsAnyRef" class="anchorToMember"></a><a id="FollowedBy[In,+A,M[-_,+_]]:FollowedBy[In,A,M]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$FollowedBy.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="Parser$$FollowedBy.html" title="An intermediate object for creating sequence-based combination methods for a Parser or Consumer."><span class="name">FollowedBy</span></a><span class="tparams">[<span name="In">In</span>, <span name="A">+A</span>, <span name="M">M<span class="tparams">[<span name="_">-_</span>, <span name="_">+_</span>]</span></span>]</span><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">An intermediate object for creating sequence-based combination methods for a Parser or Consumer.</p><div class="fullcomment"><div class="comment cmt"><p>An intermediate object for creating sequence-based combination methods for a Parser or Consumer.
</p></div><dl class="paramcmts block"><dt class="tparam">A</dt><dd class="cmt"><p>Output type for the "first" parser/consumer; using the combination methods in this trait
          will result in an instance of T1 being used to create a "second" parser/consumer/transformer
          to be run sequentially after the first.</p></dd><dt class="tparam">M</dt><dd class="cmt"><p>Type constructor for the parser/consumer of a given output type</p></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser.Handler" group="Ungrouped" fullComment="no" data-isabs="true" visbl="pub"><a id="Handler[-In,+Out]extendsAnyRef" class="anchorToMember"></a><a id="Handler[-In,+Out]:Handler[In,Out]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Handler.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="Parser$$Handler.html" title="An internally-mutable representation of a Parser, which reacts to inputs from a data stream and eventually produces a result."><span class="name">Handler</span></a><span class="tparams">[<span name="In">-In</span>, <span name="Out">+Out</span>]</span><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">An internally-mutable representation of a Parser, which reacts to inputs from a data stream and eventually produces a result.</p></li><li class="indented0 " name="io.dylemma.spac.Parser.ParserFlatten" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="ParserFlatten[In,A,F[_]]extendsAnyVal" class="anchorToMember"></a><a id="ParserFlatten[In,A,F[_]]:ParserFlatten[In,A,F]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$ParserFlatten.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">implicit final </span> <span class="kind">class</span></span> <span class="symbol"><a href="Parser$$ParserFlatten.html" title=""><span class="name">ParserFlatten</span></a><span class="tparams">[<span name="In">In</span>, <span name="A">A</span>, <span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>]</span><span class="result"> extends <span name="scala.AnyVal" class="extype">AnyVal</span></span></span></li><li class="indented0 " name="io.dylemma.spac.Parser.ParserFollowedByOps" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="ParserFollowedByOps[In,A]extendsAnyRef" class="anchorToMember"></a><a id="ParserFollowedByOps[In,A]:ParserFollowedByOps[In,A]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$ParserFollowedByOps.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">implicit </span> <span class="kind">class</span></span> <span class="symbol"><a href="Parser$$ParserFollowedByOps.html" title="Adds followedBy and followedByStream to Parser (they aren't defined in the Parser trait due to the In type needing to be invariant here)"><span class="name">ParserFollowedByOps</span></a><span class="tparams">[<span name="In">In</span>, <span name="A">A</span>]</span><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">Adds <code>followedBy</code> and <code>followedByStream</code> to Parser (they aren't defined in the Parser trait due to the <code>In</code> type needing to be invariant here)</p></li><li class="indented0 " name="io.dylemma.spac.Parser.Stateless" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="Stateless[-In,+Out]extendsParser[In,Out]withParser.Handler[In,Out]" class="anchorToMember"></a><a id="Stateless[-In,+Out]:Stateless[In,Out]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="Parser$$Stateless.html" title="Specialization for Parsers which require no mutable state."><span class="name">Stateless</span></a><span class="tparams">[<span name="In">-In</span>, <span name="Out">+Out</span>]</span><span class="result"> extends <a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>] with <a href="Parser$$Handler.html" name="io.dylemma.spac.Parser.Handler" id="io.dylemma.spac.Parser.Handler" class="extype">Handler</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>]</span></span><p class="shortcomment cmt">Specialization for Parsers which require no mutable state.</p><div class="fullcomment"><div class="comment cmt"><p>Specialization for Parsers which require no mutable state.
A "stateless" parser acts as its own handler.
</p></div></div></li></ol></div><div class="values members"><h3>Value Members</h3><ol><li class="indented0 " name="scala.AnyRef#!=" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="!=(x$1:Any):Boolean" class="anchorToMember"></a><a id="!=(Any):Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$.html#!=(x$1:Any):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $bang$eq">!=</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef###" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="##:Int" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$.html###:Int" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $hash$hash">##</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#==" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="==(x$1:Any):Boolean" class="anchorToMember"></a><a id="==(Any):Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$.html#==(x$1:Any):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $eq$eq">==</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser#apply" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="apply[In]:io.dylemma.spac.ParserApplyWithBoundInput[In]" class="anchorToMember"></a><a id="apply[In]:ParserApplyWithBoundInput[In]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$.html#apply[In]:io.dylemma.spac.ParserApplyWithBoundInput[In]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">apply</span><span class="tparams">[<span name="In">In</span>]</span><span class="result">: <a href="ParserApplyWithBoundInput.html" name="io.dylemma.spac.ParserApplyWithBoundInput" id="io.dylemma.spac.ParserApplyWithBoundInput" class="extype">ParserApplyWithBoundInput</a>[<span name="io.dylemma.spac.Parser.apply.In" class="extype">In</span>]</span></span><p class="shortcomment cmt">Convenience for creating parsers whose input type is bound to <code>In</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Convenience for creating parsers whose input type is bound to <code>In</code>.</p><p>This is particularly nice when the <code>Out</code> type can be inferred by the compiler, e.g.</p><pre>Parser[<span class="std">Int</span>].fold(<span class="num">1</span>)(_ + _)
<span class="cmt">// versus</span>
Parser.fold[<span class="std">Int</span>, <span class="std">Int</span>](<span class="num">1</span>)(_ + _)</pre></div></div></li><li class="indented0 " name="scala.Any#asInstanceOf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="asInstanceOf[T0]:T0" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$.html#asInstanceOf[T0]:T0" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span name="scala.Any.asInstanceOf.T0" class="extype">T0</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser#catsApplicativeForParser" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="catsApplicativeForParser[In](implicitcallerPos:io.dylemma.spac.CallerPos):cats.Applicative[[A]io.dylemma.spac.Parser[In,A]]" class="anchorToMember"></a><a id="catsApplicativeForParser[In](CallerPos):Applicative[[A]Parser[In,A]]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$.html#catsApplicativeForParser[In](implicitcallerPos:io.dylemma.spac.CallerPos):cats.Applicative[[A]io.dylemma.spac.Parser[In,A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">implicit </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">catsApplicativeForParser</span><span class="tparams">[<span name="In">In</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="callerPos">callerPos: <a href="CallerPos.html" name="io.dylemma.spac.CallerPos" id="io.dylemma.spac.CallerPos" class="extype">CallerPos</a></span>)</span><span class="result">: <span name="cats.Applicative" class="extype">Applicative</span>[[A]<a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.catsApplicativeForParser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.&lt;refinement&gt;.F.&lt;local F&gt;.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Applicative for Parser with a fixed <code>In</code> type.</p></li><li class="indented0 " name="scala.AnyRef#clone" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="clone():Object" class="anchorToMember"></a><a id="clone():AnyRef" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$.html#clone():Object" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clone</span><span class="params">()</span><span class="result">: <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Attributes</dt><dd>protected[<span name="java.lang" class="extype">lang</span>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.CloneNotSupportedException]</span></span>)</span> <span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser#defer" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="defer[In,Out](p:=&gt;io.dylemma.spac.Parser[In,Out]):io.dylemma.spac.Parser[In,Out]" class="anchorToMember"></a><a id="defer[In,Out](=&gt;Parser[In,Out]):Parser[In,Out]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$.html#defer[In,Out](p:=&gt;io.dylemma.spac.Parser[In,Out]):io.dylemma.spac.Parser[In,Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">defer</span><span class="tparams">[<span name="In">In</span>, <span name="Out">Out</span>]</span><span class="params">(<span name="p">p: =&gt; <a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.defer.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.defer.Out" class="extype">Out</span>]</span>)</span><span class="result">: <a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.defer.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.defer.Out" class="extype">Out</span>]</span></span><p class="shortcomment cmt">Creates a parser which delegates to the given call-by-name <code>p</code> parser.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a parser which delegates to the given call-by-name <code>p</code> parser.
The <code>p</code> expression isn't evaluated until a handler created by this parser is created - that handler will be <code>p</code>'s handler.
The underlying parser is not memoized, so if a new handler is constructed, the <code>p</code> expression will be re-evaluated.
</p></div><dl class="paramcmts block"><dt class="tparam">In</dt><dd class="cmt"><p>The parser's input type</p></dd><dt class="tparam">Out</dt><dd class="cmt"><p>The parser's output type</p></dd><dt class="param">p</dt><dd class="cmt"><p>A call-by-name expression which returns a Parser</p></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser#deferHandler" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="deferHandler[In,Out](h:=&gt;io.dylemma.spac.Parser.Handler[In,Out]):io.dylemma.spac.Parser[In,Out]" class="anchorToMember"></a><a id="deferHandler[In,Out](=&gt;Handler[In,Out]):Parser[In,Out]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$.html#deferHandler[In,Out](h:=&gt;io.dylemma.spac.Parser.Handler[In,Out]):io.dylemma.spac.Parser[In,Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">deferHandler</span><span class="tparams">[<span name="In">In</span>, <span name="Out">Out</span>]</span><span class="params">(<span name="h">h: =&gt; <a href="Parser$$Handler.html" name="io.dylemma.spac.Parser.Handler" id="io.dylemma.spac.Parser.Handler" class="extype">Handler</a>[<span name="io.dylemma.spac.Parser.deferHandler.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.deferHandler.Out" class="extype">Out</span>]</span>)</span><span class="result">: <a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.deferHandler.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.deferHandler.Out" class="extype">Out</span>]</span></span><p class="shortcomment cmt">Creates a parser from a call-by-name handler construction expression.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a parser from a call-by-name handler construction expression.
This is effectively doing</p><pre><span class="kw">new</span> Parser[In, Out] {
  <span class="kw">def</span> newHandler = h
}</pre></div></div></li><li class="indented0 " name="io.dylemma.spac.Parser#delay" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="delay[Out](value:=&gt;Out):io.dylemma.spac.Parser[Any,Out]" class="anchorToMember"></a><a id="delay[Out](=&gt;Out):Parser[Any,Out]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$.html#delay[Out](value:=&gt;Out):io.dylemma.spac.Parser[Any,Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">delay</span><span class="tparams">[<span name="Out">Out</span>]</span><span class="params">(<span name="value">value: =&gt; <span name="io.dylemma.spac.Parser.delay.Out" class="extype">Out</span></span>)</span><span class="result">: <a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="scala.Any" class="extype">Any</span>, <span name="io.dylemma.spac.Parser.delay.Out" class="extype">Out</span>]</span></span><p class="shortcomment cmt">Creates a parser which evaluates the call-by-name <code>value</code> expression.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a parser which evaluates the call-by-name <code>value</code> expression.
The <code>value</code> expression won't be evaluated until a handler created by this parser is asked to <code>step</code> or <code>finish</code>.
The value is not memoized, so if a new handler is created, that handler will re-evaluate the value.
</p></div><dl class="paramcmts block"><dt class="tparam">Out</dt><dd class="cmt"><p>the result type</p></dd><dt class="param">value</dt><dd class="cmt"><p>A call-by-name expression which will be evaluated by the returned parser's <code>Handler</code></p></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser#drain" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="drain:io.dylemma.spac.Parser[Any,Unit]" class="anchorToMember"></a><a id="drain:Parser[Any,Unit]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$.html#drain:io.dylemma.spac.Parser[Any,Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">drain</span><span class="result">: <a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="scala.Any" class="extype">Any</span>, <span name="scala.Unit" class="extype">Unit</span>]</span></span><p class="shortcomment cmt">Create a parser which will consume the entire input stream, ignoring each value, yielding a Unit result when the stream ends.</p></li><li class="indented0 " name="scala.AnyRef#eq" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="eq(x$1:AnyRef):Boolean" class="anchorToMember"></a><a id="eq(AnyRef):Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$.html#eq(x$1:AnyRef):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">eq</span><span class="params">(<span name="arg0">arg0: <span name="scala.AnyRef" class="extype">AnyRef</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#equals" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="equals(x$1:Object):Boolean" class="anchorToMember"></a><a id="equals(AnyRef):Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$.html#equals(x$1:Object):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span name="scala.AnyRef" class="extype">AnyRef</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#finalize" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="finalize():Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$.html#finalize():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">finalize</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Attributes</dt><dd>protected[<span name="java.lang" class="extype">lang</span>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="symbol">classOf[java.lang.Throwable]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser#find" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="find[In](predicate:In=&gt;Boolean):io.dylemma.spac.Parser[In,Option[In]]" class="anchorToMember"></a><a id="find[In]((In)=&gt;Boolean):Parser[In,Option[In]]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$.html#find[In](predicate:In=&gt;Boolean):io.dylemma.spac.Parser[In,Option[In]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">find</span><span class="tparams">[<span name="In">In</span>]</span><span class="params">(<span name="predicate">predicate: (<span name="io.dylemma.spac.Parser.find.In" class="extype">In</span>) =&gt; <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.find.In" class="extype">In</span>, <span name="scala.Option" class="extype">Option</span>[<span name="io.dylemma.spac.Parser.find.In" class="extype">In</span>]]</span></span><p class="shortcomment cmt">Creates a parser which returns the first input for which the <code>predicate</code> function returns true.</p></li><li class="indented0 " name="io.dylemma.spac.Parser#first" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="first[In](implicitevidence$1:org.tpolecat.typename.TypeName[In]):io.dylemma.spac.Parser[In,In]" class="anchorToMember"></a><a id="first[In](TypeName[In]):Parser[In,In]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$.html#first[In](implicitevidence$1:org.tpolecat.typename.TypeName[In]):io.dylemma.spac.Parser[In,In]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">first</span><span class="tparams">[<span name="In">In</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <span name="org.tpolecat.typename.TypeName" class="extype">TypeName</span>[<span name="io.dylemma.spac.Parser.first.In" class="extype">In</span>]</span>)</span><span class="result">: <a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.first.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.first.In" class="extype">In</span>]</span></span><p class="shortcomment cmt">Creates a parser which returns the first input it receives, or throws a <code>SpacException.MissingFirstException</code> when handling an empty stream.</p></li><li class="indented0 " name="io.dylemma.spac.Parser#firstOpt" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="firstOpt[In]:io.dylemma.spac.Parser[In,Option[In]]" class="anchorToMember"></a><a id="firstOpt[In]:Parser[In,Option[In]]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$.html#firstOpt[In]:io.dylemma.spac.Parser[In,Option[In]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">firstOpt</span><span class="tparams">[<span name="In">In</span>]</span><span class="result">: <a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.firstOpt.In" class="extype">In</span>, <span name="scala.Option" class="extype">Option</span>[<span name="io.dylemma.spac.Parser.firstOpt.In" class="extype">In</span>]]</span></span><p class="shortcomment cmt">Creates a parser which returns the first input it receives, or None when handling an empty stream.</p></li><li class="indented0 " name="io.dylemma.spac.Parser#fold" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="fold[In,Out](init:Out)(op:(Out,In)=&gt;Out):io.dylemma.spac.Parser[In,Out]" class="anchorToMember"></a><a id="fold[In,Out](Out)((Out,In)=&gt;Out):Parser[In,Out]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$.html#fold[In,Out](init:Out)(op:(Out,In)=&gt;Out):io.dylemma.spac.Parser[In,Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">fold</span><span class="tparams">[<span name="In">In</span>, <span name="Out">Out</span>]</span><span class="params">(<span name="init">init: <span name="io.dylemma.spac.Parser.fold.Out" class="extype">Out</span></span>)</span><span class="params">(<span name="op">op: (<span name="io.dylemma.spac.Parser.fold.Out" class="extype">Out</span>, <span name="io.dylemma.spac.Parser.fold.In" class="extype">In</span>) =&gt; <span name="io.dylemma.spac.Parser.fold.Out" class="extype">Out</span></span>)</span><span class="result">: <a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.fold.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.fold.Out" class="extype">Out</span>]</span></span><p class="shortcomment cmt">Creates a parser which folds inputs into its state according to the <code>op</code> function, returning its final state when the input stream ends.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a parser which folds inputs into its state according to the <code>op</code> function, returning its final state when the input stream ends.
</p></div><dl class="paramcmts block"><dt class="param">init</dt><dd class="cmt"><p>The initial state</p></dd><dt class="param">op</dt><dd class="cmt"><p>state update function</p></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser#fromBuilder" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="fromBuilder[In,Out](b:=&gt;scala.collection.mutable.Builder[In,Out]):io.dylemma.spac.Parser[In,Out]" class="anchorToMember"></a><a id="fromBuilder[In,Out](=&gt;Builder[In,Out]):Parser[In,Out]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$.html#fromBuilder[In,Out](b:=&gt;scala.collection.mutable.Builder[In,Out]):io.dylemma.spac.Parser[In,Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">fromBuilder</span><span class="tparams">[<span name="In">In</span>, <span name="Out">Out</span>]</span><span class="params">(<span name="b">b: =&gt; <span name="scala.collection.mutable.Builder" class="extype">Builder</span>[<span name="io.dylemma.spac.Parser.fromBuilder.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.fromBuilder.Out" class="extype">Out</span>]</span>)</span><span class="result">: <a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.fromBuilder.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.fromBuilder.Out" class="extype">Out</span>]</span></span><p class="shortcomment cmt">Creates a parser whose handlers which will construct a new builder via the call-by-name <code>b</code> expression.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a parser whose handlers which will construct a new builder via the call-by-name <code>b</code> expression.
The builder's result will be used as the result of the handler.
</p></div></div></li><li class="indented0 " name="scala.AnyRef#getClass" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="getClass():Class[_]" class="anchorToMember"></a><a id="getClass():Class[_&lt;:AnyRef]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$.html#getClass():Class[_]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getClass</span><span class="params">()</span><span class="result">: <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#java.lang.Class" name="java.lang.Class" id="java.lang.Class" class="extype">Class</a>[_ &lt;: <span name="scala.AnyRef" class="extype">AnyRef</span>]</span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#hashCode" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="hashCode():Int" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$.html#hashCode():Int" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">hashCode</span><span class="params">()</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.Any#isInstanceOf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="isInstanceOf[T0]:Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$.html#isInstanceOf[T0]:Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#ne" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ne(x$1:AnyRef):Boolean" class="anchorToMember"></a><a id="ne(AnyRef):Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$.html#ne(x$1:AnyRef):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">ne</span><span class="params">(<span name="arg0">arg0: <span name="scala.AnyRef" class="extype">AnyRef</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#notify" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="notify():Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$.html#notify():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">notify</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#notifyAll" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="notifyAll():Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$.html#notifyAll():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser#oneOf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="oneOf[In,Out](parsers:io.dylemma.spac.Parser[In,Out]*):io.dylemma.spac.Parser[In,Out]" class="anchorToMember"></a><a id="oneOf[In,Out](Parser[In,Out]*):Parser[In,Out]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$.html#oneOf[In,Out](parsers:io.dylemma.spac.Parser[In,Out]*):io.dylemma.spac.Parser[In,Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">oneOf</span><span class="tparams">[<span name="In">In</span>, <span name="Out">Out</span>]</span><span class="params">(<span name="parsers">parsers: <a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.oneOf.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.oneOf.Out" class="extype">Out</span>]*</span>)</span><span class="result">: <a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.oneOf.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.oneOf.Out" class="extype">Out</span>]</span></span><p class="shortcomment cmt">Create a single parser which will attempt to run each of the given <code>parsers</code> in parallel,
yielding the result from the first of the <code>parsers</code> that successfully completes.</p><div class="fullcomment"><div class="comment cmt"><p>Create a single parser which will attempt to run each of the given <code>parsers</code> in parallel,
yielding the result from the first of the <code>parsers</code> that successfully completes.
If multiple <code>parsers</code> return a result for the same input, priority is determined by
their order when given to this method.
If all of the <code>parsers</code> fail by throwing exceptions, all but the latest exception
will be swallowed, and the last exception will be rethrown.
</p></div><dl class="paramcmts block"><dt class="param">parsers</dt><dd class="cmt"><p>A collection of Parsers which will be run in parallel.</p></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser#pure" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="pure[Out](value:Out):io.dylemma.spac.Parser[Any,Out]" class="anchorToMember"></a><a id="pure[Out](Out):Parser[Any,Out]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$.html#pure[Out](value:Out):io.dylemma.spac.Parser[Any,Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">pure</span><span class="tparams">[<span name="Out">Out</span>]</span><span class="params">(<span name="value">value: <span name="io.dylemma.spac.Parser.pure.Out" class="extype">Out</span></span>)</span><span class="result">: <a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="scala.Any" class="extype">Any</span>, <span name="io.dylemma.spac.Parser.pure.Out" class="extype">Out</span>]</span></span><p class="shortcomment cmt">Creates a parser which always results in <code>value</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a parser which always results in <code>value</code>.
</p></div><dl class="paramcmts block"><dt class="param">value</dt><dd class="cmt"><p>the result of the parser</p></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#synchronized" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="synchronized[T0](x$1:=&gt;T0):T0" class="anchorToMember"></a><a id="synchronized[T0](=&gt;T0):T0" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$.html#synchronized[T0](x$1:=&gt;T0):T0" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: =&gt; <span name="java.lang.AnyRef.synchronized.T0" class="extype">T0</span></span>)</span><span class="result">: <span name="java.lang.AnyRef.synchronized.T0" class="extype">T0</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser#tap" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="tap[In](f:In=&gt;Unit):io.dylemma.spac.Parser[In,Unit]" class="anchorToMember"></a><a id="tap[In]((In)=&gt;Unit):Parser[In,Unit]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$.html#tap[In](f:In=&gt;Unit):io.dylemma.spac.Parser[In,Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">tap</span><span class="tparams">[<span name="In">In</span>]</span><span class="params">(<span name="f">f: (<span name="io.dylemma.spac.Parser.tap.In" class="extype">In</span>) =&gt; <span name="scala.Unit" class="extype">Unit</span></span>)</span><span class="result">: <a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.tap.In" class="extype">In</span>, <span name="scala.Unit" class="extype">Unit</span>]</span></span><p class="shortcomment cmt">Create a parser which runs the side-effecting function <code>f</code> for each input it receives, yielding a Unit result.</p></li><li class="indented0 " name="io.dylemma.spac.Parser#toChain" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="toChain[In]:io.dylemma.spac.Parser[In,cats.data.Chain[In]]" class="anchorToMember"></a><a id="toChain[In]:Parser[In,Chain[In]]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$.html#toChain[In]:io.dylemma.spac.Parser[In,cats.data.Chain[In]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">toChain</span><span class="tparams">[<span name="In">In</span>]</span><span class="result">: <a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.toChain.In" class="extype">In</span>, <span name="cats.data.Chain" class="extype">Chain</span>[<span name="io.dylemma.spac.Parser.toChain.In" class="extype">In</span>]]</span></span><p class="shortcomment cmt">Creates a parser that builds a <code>cats.data.Chain</code> from the inputs it receives.</p></li><li class="indented0 " name="io.dylemma.spac.Parser#toList" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="toList[In]:io.dylemma.spac.Parser[In,List[In]]" class="anchorToMember"></a><a id="toList[In]:Parser[In,List[In]]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$.html#toList[In]:io.dylemma.spac.Parser[In,List[In]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">toList</span><span class="tparams">[<span name="In">In</span>]</span><span class="result">: <a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.toList.In" class="extype">In</span>, <span name="scala.List" class="extype">List</span>[<span name="io.dylemma.spac.Parser.toList.In" class="extype">In</span>]]</span></span><p class="shortcomment cmt">Creates a parser that builds a List from the inputs it receives.</p></li><li class="indented0 " name="io.dylemma.spac.Parser#toMap" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="toMap[K,V]:io.dylemma.spac.Parser[(K,V),Map[K,V]]" class="anchorToMember"></a><a id="toMap[K,V]:Parser[(K,V),Map[K,V]]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$.html#toMap[K,V]:io.dylemma.spac.Parser[(K,V),Map[K,V]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">toMap</span><span class="tparams">[<span name="K">K</span>, <span name="V">V</span>]</span><span class="result">: <a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[(<span name="io.dylemma.spac.Parser.toMap.K" class="extype">K</span>, <span name="io.dylemma.spac.Parser.toMap.V" class="extype">V</span>), <span name="scala.Predef.Map" class="extype">Map</span>[<span name="io.dylemma.spac.Parser.toMap.K" class="extype">K</span>, <span name="io.dylemma.spac.Parser.toMap.V" class="extype">V</span>]]</span></span><p class="shortcomment cmt">Creates a parser that builds a Map from the <code>(key, value)</code> tuple inputs it receives.</p></li><li class="indented0 " name="scala.AnyRef#toString" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="toString():String" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$.html#toString():String" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">toString</span><span class="params">()</span><span class="result">: <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#java.lang.String" name="java.lang.String" id="java.lang.String" class="extype">String</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait():Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$.html#wait():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait(x$1:Long,x$2:Int):Unit" class="anchorToMember"></a><a id="wait(Long,Int):Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$.html#wait(x$1:Long,x$2:Int):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>, <span name="arg1">arg1: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait(x$1:Long):Unit" class="anchorToMember"></a><a id="wait(Long):Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$.html#wait(x$1:Long):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> <span class="name">@native</span><span class="args">()</span> </dd></dl></div></li></ol></div><div class="values members"><h3>Deprecated Value Members</h3><ol><li class="indented0 " name="io.dylemma.spac.Parser#constant" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="constant[Out](value:Out):io.dylemma.spac.Parser[Any,Out]" class="anchorToMember"></a><a id="constant[Out](Out):Parser[Any,Out]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$.html#constant[Out](value:Out):io.dylemma.spac.Parser[Any,Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name deprecated" title="Deprecated: (Since version v0.9) use .pure instead">constant</span><span class="tparams">[<span name="Out">Out</span>]</span><span class="params">(<span name="value">value: <span name="io.dylemma.spac.Parser.constant.Out" class="extype">Out</span></span>)</span><span class="result">: <a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="scala.Any" class="extype">Any</span>, <span name="io.dylemma.spac.Parser.constant.Out" class="extype">Out</span>]</span></span><div class="fullcomment"><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@deprecated</span> </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version v0.9)</i> use <code>.pure</code> instead</p></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser#firstOption" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="firstOption[In]:io.dylemma.spac.Parser[In,Option[In]]" class="anchorToMember"></a><a id="firstOption[In]:Parser[In,Option[In]]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$.html#firstOption[In]:io.dylemma.spac.Parser[In,Option[In]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name deprecated" title="Deprecated: (Since version v0.9) Use firstOpt instead">firstOption</span><span class="tparams">[<span name="In">In</span>]</span><span class="result">: <a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.firstOption.In" class="extype">In</span>, <span name="scala.Option" class="extype">Option</span>[<span name="io.dylemma.spac.Parser.firstOption.In" class="extype">In</span>]]</span></span><div class="fullcomment"><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@deprecated</span> </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version v0.9)</i> Use <code>firstOpt</code> instead</p></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser#foreach" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="foreach[In](f:In=&gt;Any):io.dylemma.spac.Parser[In,Unit]" class="anchorToMember"></a><a id="foreach[In]((In)=&gt;Any):Parser[In,Unit]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$.html#foreach[In](f:In=&gt;Any):io.dylemma.spac.Parser[In,Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name deprecated" title="Deprecated: (Since version v0.9) Use tap instead">foreach</span><span class="tparams">[<span name="In">In</span>]</span><span class="params">(<span name="f">f: (<span name="io.dylemma.spac.Parser.foreach.In" class="extype">In</span>) =&gt; <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.foreach.In" class="extype">In</span>, <span name="scala.Unit" class="extype">Unit</span>]</span></span><div class="fullcomment"><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@deprecated</span> </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version v0.9)</i> Use <code>tap</code> instead</p></dd></dl></div></li></ol></div></div><div id="inheritedMembers"><div name="scala.AnyRef" class="parent"><h3>Inherited from <span name="scala.AnyRef" class="extype">AnyRef</span></h3></div><div name="scala.Any" class="parent"><h3>Inherited from <span name="scala.Any" class="extype">Any</span></h3></div></div><div id="groupedMembers"><div name="Ungrouped" class="group"><h3>Ungrouped</h3></div></div></div><div id="tooltip"></div><div id="footer"></div></body></div></div></div></body></html>

<!DOCTYPE html ><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/><title></title><meta content="" name="description"/><meta content="" name="keywords"/><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><link href="../../../../lib/index.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../../../lib/template.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../../../lib/print.css" media="print" type="text/css" rel="stylesheet"/><link href="../../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css"/><script type="text/javascript" src="../../../../lib/jquery.min.js"></script><script type="text/javascript" src="../../../../lib/index.js"></script><script type="text/javascript" src="../../../../index.js"></script><script type="text/javascript" src="../../../../lib/scheduler.js"></script><script type="text/javascript" src="../../../../lib/template.js"></script><script type="text/javascript">/* this variable can be used by the JS to determine the path to the root document */
var toRoot = '../../../../';</script></head><body><div id="search"><span id="doc-title"><span id="doc-version"></span></span> <span class="close-results"><span class="left">&lt;</span> Back</span><div id="textfilter"><span class="input"><input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/"/><i class="clear material-icons"></i><i id="search-icon" class="material-icons"></i></span></div></div><div id="search-results"><div id="search-progress"><div id="progress-fill"></div></div><div id="results-content"><div id="entity-results"></div><div id="member-results"></div></div></div><div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;"><div id="content-container" style="-webkit-overflow-scrolling: touch;"><div id="subpackage-spacer"><div id="packages"><h1>Packages</h1><ul><li class="indented0 " name="_root_.root" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="_root_" class="anchorToMember"></a><a id="root:_root_" class="anchorToMember"></a> <span class="permalink"><a href="../../../../index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../../../index.html" title=""><span class="name">root</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented1 " name="_root_.io" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="io" class="anchorToMember"></a><a id="io:io" class="anchorToMember"></a> <span class="permalink"><a href="../../../../io/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../../index.html" title=""><span class="name">io</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented2 " name="io.dylemma" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="dylemma" class="anchorToMember"></a><a id="dylemma:dylemma" class="anchorToMember"></a> <span class="permalink"><a href="../../../../io/dylemma/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../index.html" title=""><span class="name">dylemma</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../../index.html" name="io" id="io" class="extype">io</a></dd></dl></div></li><li class="indented3 " name="io.dylemma.spac" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="spac" class="anchorToMember"></a><a id="spac:spac" class="anchorToMember"></a> <span class="permalink"><a href="../../../../io/dylemma/spac/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../index.html" title="SPaC (short for &quot;Streaming Parser Combinators&quot;) is a library for building stream consumers in a declarative style, specialized for tree-like data types like XML and JSON."><span class="name">spac</span></a></span><p class="shortcomment cmt">SPaC (short for "<strong>S</strong>treaming <strong>Pa</strong>rser <strong>C</strong>ombinators")
is a library for building stream consumers in a declarative style, specialized for tree-like data
types like XML and JSON.</p><div class="fullcomment"><div class="comment cmt"><p>SPaC (short for "<strong>S</strong>treaming <strong>Pa</strong>rser <strong>C</strong>ombinators")
is a library for building stream consumers in a declarative style, specialized for tree-like data
types like XML and JSON.</p><p>Many utilities for handling XML and JSON data involve parsing the entire "document" to some DOM model,
then inspecting and transforming that model to extract information.
The downside to these utilities is that when the document is very large, the DOM may not fit in memory.
The workaround for this type of problem is to treat the document as a stream of "events",
e.g. "StartElement" and "EndElement" for XML, or "StartObject" and "EndObject" for JSON.
The downside to this workaround is that writing code to handle these streams can be complicated and
error-prone, especially when the DOM is complicated.</p><p>SPaC's goal is to drastically simplify the process of creating code to handle these streams.</p><p>This package contains the "core" SPaC traits; <code>Parser</code>, <code>Transformer</code>, <code>Splitter</code>, and <code>ContextMatcher</code>.</p><p>See the <code>xml</code> and <code>json</code> subpackages (provided by the <code>xml-spac</code> and <code>json-spac</code> libraries respectively)
for specific utilities related to handling XML and JSON event streams.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../index.html" name="io.dylemma" id="io.dylemma" class="extype">dylemma</a></dd></dl></div></li><li class="indented4 " name="io.dylemma.spac.json" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="json" class="anchorToMember"></a><a id="json:json" class="anchorToMember"></a> <span class="permalink"><a href="../../../../io/dylemma/spac/json/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="index.html" title="This package provides extensions to the core &quot;spac&quot; library which allow for the handling of JSON data."><span class="name">json</span></a></span><p class="shortcomment cmt">This package provides extensions to the core "spac" library which allow for the handling of JSON data.</p><div class="fullcomment"><div class="comment cmt"><p>This package provides extensions to the core "spac" library which allow for the handling of JSON data.</p><p>Rather than creating explicit classes that extend <code>Parser</code>, <code>Transformer</code>, and <code>Splitter</code>,
this package provides type aliases and implicit extensions.
For example, <code>JsonParser[A]</code> is just a type alias for <code>Parser[JsonEvent, A]</code>,
and <code>JsonParser</code> is just a call to <code>Parser[JsonEvent]</code>.</p><p>Implicit JsonParsers are available for each of the JSON primitive types:</p><ul><li><code>string</code></li><li><code>number</code> (expressed as <code>Int</code>, <code>Long</code>, <code>Float</code>, or <code>Double</code>)</li><li><code>boolean</code></li><li><code>null</code> (expressed as <code>None.type</code>)</li></ul><p>Helpers are available for parsing JSON arrays and objects:</p><ul><li><code>JsonParser.listOf[A]</code> to parse an <code>array</code><code> where each value is an </code>A<code></code></li><li><code>JsonParser.objectOf[A]</code> to parse an <code>object</code> where the value for each field an <code>A</code></li><li><code>JsonParser.objectOfNullable[A]</code> to parse an <code>object</code> where the value for each field is either <code>null</code> or an <code>A</code>, filtering out the <code>null</code>s</li><li><code>JsonParser.fieldOf[A](fieldName)</code> to parse a specific field from an object</li></ul><p>A DSL for creating json-specific ContextMatchers is provided to make it more convenient to call <code>Splitter.json</code>.
For example:</p><pre>Splitter.json(<span class="lit">"foo"</span> \ <span class="lit">"bar"</span>).as[<span class="std">String</span>].parseFirst</pre><p>Can be used to capture <code>rootJson.foo.bar</code> as a String in</p><pre>{
  <span class="lit">"foo"</span>: {
    <span class="lit">"bar"</span>: <span class="lit">"hello"</span>
  }
}</pre><p>To "split" values inside arrays, index-related context matchers are available, e.g.</p><pre>Splitter.json(<span class="lit">"foo"</span> \ anyIndex).as[<span class="std">Int</span>].parseToList</pre><p>Can be used to capture each of the numbers in the "foo" array in</p><pre>{
  <span class="lit">"foo"</span>: [<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>]
}</pre><p>A note about JsonEvents in spac:
JSON doesn't have any explicit markers for when a field ends, or when an array index starts or ends;
those context changes are essentially inferred by the presence of some other event.
For example, instead of a "field end" event, typically there will be either a new "field start" or a token representing the end of the current object.
With spac, splitters and context matchers generally operate under the assumption that a "stack push" event (like a field start) will eventually be
followed by a corresponding "stack pop" event (i.e. field end).</p><p>To allow for this, these "inferred" events (FieldEnd, IndexStart, IndexEnd) are explicitly represented as JsonEvents in the stream being parsed.
Keep this in mind when creating JSON ContextMatchers:</p><ul><li><code>field</code>-related matchers will match a stack like <code>case ObjectStart :: FieldStart(_) :: _</code></li><li><code>index</code>-related matchers will match a stack like <code>case ArrayStart :: IndexStart(_) :: _</code>
</li></ul></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="io.dylemma.spac" id="io.dylemma.spac" class="extype">spac</a></dd></dl></div></li><li class="current-entities indented4"><span class="separator"></span> <a href="Fs2DataSource$.html" title="Provides helpers for creating FS2 streams of io.dylemma.spac.json.JsonEvent, using fs2-data-json as the underlying event provider." class="object"></a><a href="Fs2DataSource$.html" title="Provides helpers for creating FS2 streams of io.dylemma.spac.json.JsonEvent, using fs2-data-json as the underlying event provider.">Fs2DataSource</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="JacksonSource$.html" title="Provides helpers for creating fs2.Stream and Iterator instances of JsonEvent from various underlying event sources, using the Jackson library as the underlying event parser." class="object"></a><a href="JacksonSource$.html" title="Provides helpers for creating fs2.Stream and Iterator instances of JsonEvent from various underlying event sources, using the Jackson library as the underlying event parser.">JacksonSource</a></li><li class="current-entities indented4"><a href="JsonEvent$.html" title="" class="object"></a> <a href="JsonEvent.html" title="ADT for tokens in a JSON stream." class="trait"></a><a href="JsonEvent.html" title="ADT for tokens in a JSON stream.">JsonEvent</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="" title="Provides JSON-specific Parser constructor methods to the JsonParser object, for example JsonParser.fieldOf." class="class"></a><a href="" title="Provides JSON-specific Parser constructor methods to the JsonParser object, for example JsonParser.fieldOf.">JsonParserApplyOps</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="package$$JsonSplitterApplyOps.html" title="Adds Splitter.json, for constructing json context matcher-based JsonSplitters" class="class"></a><a href="package$$JsonSplitterApplyOps.html" title="Adds Splitter.json, for constructing json context matcher-based JsonSplitters">JsonSplitterApplyOps</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="package$$JsonSplitterOps.html" title="Adds splitter.asNullable[A], for handling possibly-null values in a JSON substream" class="class"></a><a href="package$$JsonSplitterOps.html" title="Adds splitter.asNullable[A], for handling possibly-null values in a JSON substream">JsonSplitterOps</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="JsonStackElem.html" title="Subset of JsonEvents that constitute a &quot;context stack push&quot;." class="trait"></a><a href="JsonStackElem.html" title="Subset of JsonEvents that constitute a &quot;context stack push&quot;.">JsonStackElem</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="JsonStackPop.html" title="Subset of JsonEvents that constitute a &quot;context stack pop&quot;." class="trait"></a><a href="JsonStackPop.html" title="Subset of JsonEvents that constitute a &quot;context stack pop&quot;.">JsonStackPop</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="JsonValueEvent.html" title="Subset of JsonEvents that represent a primitive values" class="trait"></a><a href="JsonValueEvent.html" title="Subset of JsonEvents that represent a primitive values">JsonValueEvent</a></li></ul></div></div><div id="content"><body class="class type"><div id="definition"><div class="big-circle class">c</div><p id="owner"><a href="../../../index.html" name="io" id="io" class="extype">io</a>.<a href="../../index.html" name="io.dylemma" id="io.dylemma" class="extype">dylemma</a>.<a href="../index.html" name="io.dylemma.spac" id="io.dylemma.spac" class="extype">spac</a>.<a href="index.html" name="io.dylemma.spac.json" id="io.dylemma.spac.json" class="extype">json</a></p><h1>JsonParserApplyOps<span class="permalink"><a href="../../../../io/dylemma/spac/json/package$$JsonParserApplyOps.html" title="Permalink"><i class="material-icons"></i></a></span></h1><h3><span class="morelinks"></span></h3></div><h4 id="signature" class="signature"><span class="modifier_kind"><span class="modifier">implicit final </span> <span class="kind">class</span></span> <span class="symbol"><span class="name">JsonParserApplyOps</span><span class="result"> extends <span name="scala.AnyVal" class="extype">AnyVal</span></span></span></h4><div id="comment" class="fullcommenttop"><div class="comment cmt"><p>Provides JSON-specific Parser constructor methods to the <code>JsonParser</code> object, for example <code>JsonParser.fieldOf</code>.</p><p>Technically <code>JsonParser</code> is not a companion object, it is a partially-applied version of the <code>Parser</code> companion
object which binds the input type to <code>JsonEvent</code>, so "companion methods" must instead be added as extension methods.
</p></div><dl class="attributes block"><dt>Source</dt><dd><a href="https://github.com/dylemma/xml-spac/tree/0.10.0/json/src/main/scala/io/dylemma/spac/json/package.scala" target="_blank">package.scala</a></dd></dl><div class="toggleContainer"><div class="toggle block"><span>Linear Supertypes</span><div class="superTypes hiddenContent"><span name="scala.AnyVal" class="extype">AnyVal</span>, <span name="scala.Any" class="extype">Any</span></div></div></div></div><div id="mbrsel"><div class="toggle"></div><div id="memberfilter"><i class="material-icons arrow"></i><span class="input"><input placeholder="Filter all members" id="mbrsel-input" type="text" accesskey="/"/></span><i class="clear material-icons"></i></div><div id="filterby"><div id="order"><span class="filtertype">Ordering</span><ol><li class="group out"><span>Grouped</span></li><li class="alpha in"><span>Alphabetic</span></li><li class="inherit out"><span>By Inheritance</span></li></ol></div><div class="ancestors"><span class="filtertype">Inherited<br/></span><ol id="linearization"><li class="in" name="io.dylemma.spac.json.JsonParserApplyOps"><span>JsonParserApplyOps</span></li><li class="in" name="scala.AnyVal"><span>AnyVal</span></li><li class="in" name="scala.Any"><span>Any</span></li></ol></div><div class="ancestors"><span class="filtertype">Implicitly<br/></span><ol id="implicits"><li class="in" name="scala.Predef.any2stringadd" data-hidden="true"><span>by any2stringadd</span></li><li class="in" name="scala.Predef.StringFormat" data-hidden="true"><span>by StringFormat</span></li><li class="in" name="scala.Predef.Ensuring" data-hidden="true"><span>by Ensuring</span></li><li class="in" name="scala.Predef.ArrowAssoc" data-hidden="true"><span>by ArrowAssoc</span></li></ol></div><div class="ancestors"><span class="filtertype"></span><ol><li class="hideall out"><span>Hide All</span></li><li class="showall in"><span>Show All</span></li></ol></div><div id="visbl"><span class="filtertype">Visibility</span><ol><li class="public in"><span>Public</span></li><li class="protected out"><span>Protected</span></li></ol></div></div></div><div id="template"><div id="allMembers"><div id="constructors" class="members"><h3>Instance Constructors</h3><ol><li class="indented0 " name="io.dylemma.spac.json.JsonParserApplyOps#&lt;init&gt;" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="&lt;init&gt;(parserApply:io.dylemma.spac.ParserApplyWithBoundInput[io.dylemma.spac.json.JsonEvent]):io.dylemma.spac.json.package.JsonParserApplyOps" class="anchorToMember"></a><a id="&lt;init&gt;:JsonParserApplyOps" class="anchorToMember"></a> <span class="permalink"><a href="../../../../io/dylemma/spac/json/package$$JsonParserApplyOps.html#&lt;init&gt;(parserApply:io.dylemma.spac.ParserApplyWithBoundInput[io.dylemma.spac.json.JsonEvent]):io.dylemma.spac.json.package.JsonParserApplyOps" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">new</span></span> <span class="symbol"><span class="name">JsonParserApplyOps</span><span class="params">(<span name="parserApply">parserApply: <a href="../ParserApplyWithBoundInput.html" name="io.dylemma.spac.ParserApplyWithBoundInput" id="io.dylemma.spac.ParserApplyWithBoundInput" class="extype">ParserApplyWithBoundInput</a>[<a href="JsonEvent.html" name="io.dylemma.spac.json.JsonEvent" id="io.dylemma.spac.json.JsonEvent" class="extype">JsonEvent</a>]</span>)</span></span></li></ol></div><div class="values members"><h3>Value Members</h3><ol><li class="indented0 " name="scala.Any#!=" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="!=(x$1:Any):Boolean" class="anchorToMember"></a><a id="!=(Any):Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../../../io/dylemma/spac/json/package$$JsonParserApplyOps.html#!=(x$1:Any):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $bang$eq">!=</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="scala.Any###" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="##:Int" class="anchorToMember"></a> <span class="permalink"><a href="../../../../io/dylemma/spac/json/package$$JsonParserApplyOps.html###:Int" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $hash$hash">##</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="scala.Predef.any2stringadd#+" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="+(other:String):String" class="anchorToMember"></a><a id="+(String):String" class="anchorToMember"></a> <span class="permalink"><a href="../../../../io/dylemma/spac/json/package$$JsonParserApplyOps.html#+(other:String):String" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit" title="gt4s: $plus">+</span><span class="params">(<span name="other">other: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <span name="scala.Predef.String" class="extype">String</span></span></span><div class="fullcomment"><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="io.dylemma.spac.json.JsonParserApplyOps" id="io.dylemma.spac.json.JsonParserApplyOps" class="extype">JsonParserApplyOps</a> to<span name="scala.Predef.any2stringadd" class="extype">any2stringadd</span>[<a href="" name="io.dylemma.spac.json.JsonParserApplyOps" id="io.dylemma.spac.json.JsonParserApplyOps" class="extype">JsonParserApplyOps</a>] performed by method any2stringadd in scala.Predef.</dd><dt>Definition Classes</dt><dd>any2stringadd</dd></dl></div></li><li class="indented0 " name="scala.Predef.ArrowAssoc#-&gt;" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="-&gt;[B](y:B):(A,B)" class="anchorToMember"></a><a id="-&gt;[B](B):(JsonParserApplyOps,B)" class="anchorToMember"></a> <span class="permalink"><a href="../../../../io/dylemma/spac/json/package$$JsonParserApplyOps.html#-&gt;[B](y:B):(A,B)" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit" title="gt4s: $minus$greater">-&gt;</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="y">y: <span name="scala.Predef.ArrowAssoc.-&gt;.B" class="extype">B</span></span>)</span><span class="result">: (<a href="" name="io.dylemma.spac.json.JsonParserApplyOps" id="io.dylemma.spac.json.JsonParserApplyOps" class="extype">JsonParserApplyOps</a>, <span name="scala.Predef.ArrowAssoc.-&gt;.B" class="extype">B</span>)</span></span><div class="fullcomment"><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="io.dylemma.spac.json.JsonParserApplyOps" id="io.dylemma.spac.json.JsonParserApplyOps" class="extype">JsonParserApplyOps</a> to<span name="scala.Predef.ArrowAssoc" class="extype">ArrowAssoc</span>[<a href="" name="io.dylemma.spac.json.JsonParserApplyOps" id="io.dylemma.spac.json.JsonParserApplyOps" class="extype">JsonParserApplyOps</a>] performed by method ArrowAssoc in scala.Predef.</dd><dt>Definition Classes</dt><dd>ArrowAssoc</dd><dt>Annotations</dt><dd><span class="name">@inline</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.Any#==" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="==(x$1:Any):Boolean" class="anchorToMember"></a><a id="==(Any):Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../../../io/dylemma/spac/json/package$$JsonParserApplyOps.html#==(x$1:Any):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $eq$eq">==</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="scala.Any#asInstanceOf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="asInstanceOf[T0]:T0" class="anchorToMember"></a> <span class="permalink"><a href="../../../../io/dylemma/spac/json/package$$JsonParserApplyOps.html#asInstanceOf[T0]:T0" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span name="scala.Any.asInstanceOf.T0" class="extype">T0</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="scala.Predef.Ensuring#ensuring" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ensuring(cond:A=&gt;Boolean,msg:=&gt;Any):A" class="anchorToMember"></a><a id="ensuring((JsonParserApplyOps)=&gt;Boolean,=&gt;Any):JsonParserApplyOps" class="anchorToMember"></a> <span class="permalink"><a href="../../../../io/dylemma/spac/json/package$$JsonParserApplyOps.html#ensuring(cond:A=&gt;Boolean,msg:=&gt;Any):A" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">ensuring</span><span class="params">(<span name="cond">cond: (<a href="" name="io.dylemma.spac.json.JsonParserApplyOps" id="io.dylemma.spac.json.JsonParserApplyOps" class="extype">JsonParserApplyOps</a>) =&gt; <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="msg">msg: =&gt; <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <a href="" name="io.dylemma.spac.json.JsonParserApplyOps" id="io.dylemma.spac.json.JsonParserApplyOps" class="extype">JsonParserApplyOps</a></span></span><div class="fullcomment"><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="io.dylemma.spac.json.JsonParserApplyOps" id="io.dylemma.spac.json.JsonParserApplyOps" class="extype">JsonParserApplyOps</a> to<span name="scala.Predef.Ensuring" class="extype">Ensuring</span>[<a href="" name="io.dylemma.spac.json.JsonParserApplyOps" id="io.dylemma.spac.json.JsonParserApplyOps" class="extype">JsonParserApplyOps</a>] performed by method Ensuring in scala.Predef.</dd><dt>Definition Classes</dt><dd>Ensuring</dd></dl></div></li><li class="indented0 " name="scala.Predef.Ensuring#ensuring" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ensuring(cond:A=&gt;Boolean):A" class="anchorToMember"></a><a id="ensuring((JsonParserApplyOps)=&gt;Boolean):JsonParserApplyOps" class="anchorToMember"></a> <span class="permalink"><a href="../../../../io/dylemma/spac/json/package$$JsonParserApplyOps.html#ensuring(cond:A=&gt;Boolean):A" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">ensuring</span><span class="params">(<span name="cond">cond: (<a href="" name="io.dylemma.spac.json.JsonParserApplyOps" id="io.dylemma.spac.json.JsonParserApplyOps" class="extype">JsonParserApplyOps</a>) =&gt; <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <a href="" name="io.dylemma.spac.json.JsonParserApplyOps" id="io.dylemma.spac.json.JsonParserApplyOps" class="extype">JsonParserApplyOps</a></span></span><div class="fullcomment"><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="io.dylemma.spac.json.JsonParserApplyOps" id="io.dylemma.spac.json.JsonParserApplyOps" class="extype">JsonParserApplyOps</a> to<span name="scala.Predef.Ensuring" class="extype">Ensuring</span>[<a href="" name="io.dylemma.spac.json.JsonParserApplyOps" id="io.dylemma.spac.json.JsonParserApplyOps" class="extype">JsonParserApplyOps</a>] performed by method Ensuring in scala.Predef.</dd><dt>Definition Classes</dt><dd>Ensuring</dd></dl></div></li><li class="indented0 " name="scala.Predef.Ensuring#ensuring" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ensuring(cond:Boolean,msg:=&gt;Any):A" class="anchorToMember"></a><a id="ensuring(Boolean,=&gt;Any):JsonParserApplyOps" class="anchorToMember"></a> <span class="permalink"><a href="../../../../io/dylemma/spac/json/package$$JsonParserApplyOps.html#ensuring(cond:Boolean,msg:=&gt;Any):A" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">ensuring</span><span class="params">(<span name="cond">cond: <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="msg">msg: =&gt; <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <a href="" name="io.dylemma.spac.json.JsonParserApplyOps" id="io.dylemma.spac.json.JsonParserApplyOps" class="extype">JsonParserApplyOps</a></span></span><div class="fullcomment"><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="io.dylemma.spac.json.JsonParserApplyOps" id="io.dylemma.spac.json.JsonParserApplyOps" class="extype">JsonParserApplyOps</a> to<span name="scala.Predef.Ensuring" class="extype">Ensuring</span>[<a href="" name="io.dylemma.spac.json.JsonParserApplyOps" id="io.dylemma.spac.json.JsonParserApplyOps" class="extype">JsonParserApplyOps</a>] performed by method Ensuring in scala.Predef.</dd><dt>Definition Classes</dt><dd>Ensuring</dd></dl></div></li><li class="indented0 " name="scala.Predef.Ensuring#ensuring" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ensuring(cond:Boolean):A" class="anchorToMember"></a><a id="ensuring(Boolean):JsonParserApplyOps" class="anchorToMember"></a> <span class="permalink"><a href="../../../../io/dylemma/spac/json/package$$JsonParserApplyOps.html#ensuring(cond:Boolean):A" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">ensuring</span><span class="params">(<span name="cond">cond: <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <a href="" name="io.dylemma.spac.json.JsonParserApplyOps" id="io.dylemma.spac.json.JsonParserApplyOps" class="extype">JsonParserApplyOps</a></span></span><div class="fullcomment"><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="io.dylemma.spac.json.JsonParserApplyOps" id="io.dylemma.spac.json.JsonParserApplyOps" class="extype">JsonParserApplyOps</a> to<span name="scala.Predef.Ensuring" class="extype">Ensuring</span>[<a href="" name="io.dylemma.spac.json.JsonParserApplyOps" id="io.dylemma.spac.json.JsonParserApplyOps" class="extype">JsonParserApplyOps</a>] performed by method Ensuring in scala.Predef.</dd><dt>Definition Classes</dt><dd>Ensuring</dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.json.JsonParserApplyOps#fieldOf" group="high" fullComment="yes" data-isabs="false" visbl="pub"><a id="fieldOf[T](fieldName:String,parser:io.dylemma.spac.json.package.JsonParser[T])(implicitevidence$3:org.tpolecat.typename.TypeName[T],implicitcallerPos:io.dylemma.spac.CallerPos):io.dylemma.spac.json.package.JsonParser[T]" class="anchorToMember"></a><a id="fieldOf[T](String,JsonParser[T])(TypeName[T],CallerPos):JsonParser[T]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../io/dylemma/spac/json/package$$JsonParserApplyOps.html#fieldOf[T](fieldName:String,parser:io.dylemma.spac.json.package.JsonParser[T])(implicitevidence$3:org.tpolecat.typename.TypeName[T],implicitcallerPos:io.dylemma.spac.CallerPos):io.dylemma.spac.json.package.JsonParser[T]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">fieldOf</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="fieldName">fieldName: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="parser">parser: <a href="index.html#JsonParser[+Out]=io.dylemma.spac.Parser[io.dylemma.spac.json.JsonEvent,Out]" name="io.dylemma.spac.json.JsonParser" id="io.dylemma.spac.json.JsonParser" class="extmbr">JsonParser</a>[<span name="io.dylemma.spac.json.JsonParserApplyOps.fieldOf.T" class="extype">T</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <span name="org.tpolecat.typename.TypeName" class="extype">TypeName</span>[<span name="io.dylemma.spac.json.JsonParserApplyOps.fieldOf.T" class="extype">T</span>]</span>, <span name="callerPos">callerPos: <a href="../CallerPos.html" name="io.dylemma.spac.CallerPos" id="io.dylemma.spac.CallerPos" class="extype">CallerPos</a></span>)</span><span class="result">: <a href="index.html#JsonParser[+Out]=io.dylemma.spac.Parser[io.dylemma.spac.json.JsonEvent,Out]" name="io.dylemma.spac.json.JsonParser" id="io.dylemma.spac.json.JsonParser" class="extmbr">JsonParser</a>[<span name="io.dylemma.spac.json.JsonParserApplyOps.fieldOf.T" class="extype">T</span>]</span></span><p class="shortcomment cmt">A JsonParser that parses a JSON object by parsing the given mandatory field with the given <code>JsonParser[T]</code>.</p><div class="fullcomment"><div class="comment cmt"><p>A JsonParser that parses a JSON object by parsing the given mandatory field with the given <code>JsonParser[T]</code>.</p><p>Note that if the given <code>parser</code> is available implicitly, you can use the other <code>fieldOf</code> signature.</p><p>The returned parser will fail if the first event is not an <code>ObjectStart</code>,
or if the expected field does not appear inside the object,
or if the value of the expected field causes the underlying parser to fail.</p><p>This is a shortcut for <code>Splitter.json(fieldName).as[T].parseFirst</code>.</p><p>E.g.</p><pre><span class="kw">val</span> rawJson = <span class="lit">"""{ "foo": 1, "bar": true }"""
val parser = JsonParser.fieldOf[Boolean]("bar")
parser.parse(rawJson) // returns `true`</span></pre></div><dl class="paramcmts block"><dt class="tparam">T</dt><dd class="cmt"><p>The type of the extracted value</p></dd><dt class="param">fieldName</dt><dd class="cmt"><p>The name of the expected field</p></dd><dt class="param">parser</dt><dd class="cmt"><p>The underlying parser used to parse the value inside the expected field in the object</p></dd><dt class="param">callerPos</dt><dd class="cmt"><p>Macro-derived location of the code calling this method, used to form a SpacTraceElement when the returned parser fails</p></dd><dt>returns</dt><dd class="cmt"><p>A JsonParser that parses the given field from a JSON object as a value of type <code>T</code></p></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.json.JsonParserApplyOps#fieldOf" group="high" fullComment="yes" data-isabs="false" visbl="pub"><a id="fieldOf[T](fieldName:String)(implicitevidence$1:org.tpolecat.typename.TypeName[T],implicitevidence$2:io.dylemma.spac.json.package.JsonParser[T],implicitcallerPos:io.dylemma.spac.CallerPos):io.dylemma.spac.json.package.JsonParser[T]" class="anchorToMember"></a><a id="fieldOf[T](String)(TypeName[T],JsonParser[T],CallerPos):JsonParser[T]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../io/dylemma/spac/json/package$$JsonParserApplyOps.html#fieldOf[T](fieldName:String)(implicitevidence$1:org.tpolecat.typename.TypeName[T],implicitevidence$2:io.dylemma.spac.json.package.JsonParser[T],implicitcallerPos:io.dylemma.spac.CallerPos):io.dylemma.spac.json.package.JsonParser[T]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">fieldOf</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="fieldName">fieldName: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <span name="org.tpolecat.typename.TypeName" class="extype">TypeName</span>[<span name="io.dylemma.spac.json.JsonParserApplyOps.fieldOf.T" class="extype">T</span>]</span>, <span name="arg1">arg1: <a href="index.html#JsonParser[+Out]=io.dylemma.spac.Parser[io.dylemma.spac.json.JsonEvent,Out]" name="io.dylemma.spac.json.JsonParser" id="io.dylemma.spac.json.JsonParser" class="extmbr">JsonParser</a>[<span name="io.dylemma.spac.json.JsonParserApplyOps.fieldOf.T" class="extype">T</span>]</span>, <span name="callerPos">callerPos: <a href="../CallerPos.html" name="io.dylemma.spac.CallerPos" id="io.dylemma.spac.CallerPos" class="extype">CallerPos</a></span>)</span><span class="result">: <a href="index.html#JsonParser[+Out]=io.dylemma.spac.Parser[io.dylemma.spac.json.JsonEvent,Out]" name="io.dylemma.spac.json.JsonParser" id="io.dylemma.spac.json.JsonParser" class="extmbr">JsonParser</a>[<span name="io.dylemma.spac.json.JsonParserApplyOps.fieldOf.T" class="extype">T</span>]</span></span><p class="shortcomment cmt">A JsonParser that parses a JSON object by parsing the given mandatory field with the implicitly-available <code>JsonParser[T]</code>.</p><div class="fullcomment"><div class="comment cmt"><p>A JsonParser that parses a JSON object by parsing the given mandatory field with the implicitly-available <code>JsonParser[T]</code>.</p><p>The returned parser will fail if the first event is not an <code>ObjectStart</code>,
or if the expected field does not appear inside the object,
or if the value of the expected field causes the underlying parser to fail.</p><p>This is a shortcut for <code>Splitter.json(fieldName).as[T].parseFirst</code>.</p><p>E.g.</p><pre><span class="kw">val</span> rawJson = <span class="lit">"""{ "foo": 1, "bar": true }"""
val parser = JsonParser.fieldOf[Boolean]("bar")
parser.parse(rawJson) // returns `true`</span></pre></div><dl class="paramcmts block"><dt class="tparam">T</dt><dd class="cmt"><p>The type of the extracted value</p></dd><dt class="param">fieldName</dt><dd class="cmt"><p>The name of the expected field</p></dd><dt class="param">callerPos</dt><dd class="cmt"><p>Macro-derived location of the code calling this method, used to form a SpacTraceElement when the returned parser fails</p></dd><dt>returns</dt><dd class="cmt"><p>A JsonParser that parses the given field from a JSON object as a value of type <code>T</code></p></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.json.JsonParserApplyOps#forBoolean" group="primitive" fullComment="no" data-isabs="false" visbl="pub"><a id="forBoolean:io.dylemma.spac.json.package.JsonParser[Boolean]" class="anchorToMember"></a><a id="forBoolean:JsonParser[Boolean]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../io/dylemma/spac/json/package$$JsonParserApplyOps.html#forBoolean:io.dylemma.spac.json.package.JsonParser[Boolean]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">forBoolean</span><span class="result">: <a href="index.html#JsonParser[+Out]=io.dylemma.spac.Parser[io.dylemma.spac.json.JsonEvent,Out]" name="io.dylemma.spac.json.JsonParser" id="io.dylemma.spac.json.JsonParser" class="extmbr">JsonParser</a>[<span name="scala.Boolean" class="extype">Boolean</span>]</span></span><p class="shortcomment cmt">A JsonParser that captures the <code>Boolean</code> value from a <code>JBool</code> event, failing if the first event is not a <code>JBool</code>.</p></li><li class="indented0 " name="io.dylemma.spac.json.JsonParserApplyOps#forDouble" group="primitive" fullComment="no" data-isabs="false" visbl="pub"><a id="forDouble:io.dylemma.spac.json.package.JsonParser[Double]" class="anchorToMember"></a><a id="forDouble:JsonParser[Double]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../io/dylemma/spac/json/package$$JsonParserApplyOps.html#forDouble:io.dylemma.spac.json.package.JsonParser[Double]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">forDouble</span><span class="result">: <a href="index.html#JsonParser[+Out]=io.dylemma.spac.Parser[io.dylemma.spac.json.JsonEvent,Out]" name="io.dylemma.spac.json.JsonParser" id="io.dylemma.spac.json.JsonParser" class="extmbr">JsonParser</a>[<span name="scala.Double" class="extype">Double</span>]</span></span><p class="shortcomment cmt">A JsonParser that captures a <code>JDouble</code> event as a <code>Double</code> value, failing if the first event is not a <code>JDouble</code>.</p></li><li class="indented0 " name="io.dylemma.spac.json.JsonParserApplyOps#forFloat" group="primitive" fullComment="no" data-isabs="false" visbl="pub"><a id="forFloat:io.dylemma.spac.json.package.JsonParser[Float]" class="anchorToMember"></a><a id="forFloat:JsonParser[Float]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../io/dylemma/spac/json/package$$JsonParserApplyOps.html#forFloat:io.dylemma.spac.json.package.JsonParser[Float]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">forFloat</span><span class="result">: <a href="index.html#JsonParser[+Out]=io.dylemma.spac.Parser[io.dylemma.spac.json.JsonEvent,Out]" name="io.dylemma.spac.json.JsonParser" id="io.dylemma.spac.json.JsonParser" class="extmbr">JsonParser</a>[<span name="scala.Float" class="extype">Float</span>]</span></span><p class="shortcomment cmt">A JsonParser that captures a <code>JDouble</code> event as a <code>Float</code> value, failing if the first event is not a <code>JDouble</code>.</p></li><li class="indented0 " name="io.dylemma.spac.json.JsonParserApplyOps#forInt" group="primitive" fullComment="no" data-isabs="false" visbl="pub"><a id="forInt:io.dylemma.spac.json.package.JsonParser[Int]" class="anchorToMember"></a><a id="forInt:JsonParser[Int]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../io/dylemma/spac/json/package$$JsonParserApplyOps.html#forInt:io.dylemma.spac.json.package.JsonParser[Int]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">forInt</span><span class="result">: <a href="index.html#JsonParser[+Out]=io.dylemma.spac.Parser[io.dylemma.spac.json.JsonEvent,Out]" name="io.dylemma.spac.json.JsonParser" id="io.dylemma.spac.json.JsonParser" class="extmbr">JsonParser</a>[<span name="scala.Int" class="extype">Int</span>]</span></span><p class="shortcomment cmt">A JsonParser that captures a <code>JLong</code> event as an <code>Int</code> value, failing if the first event is not a <code>JLong</code>.</p></li><li class="indented0 " name="io.dylemma.spac.json.JsonParserApplyOps#forLong" group="primitive" fullComment="no" data-isabs="false" visbl="pub"><a id="forLong:io.dylemma.spac.json.package.JsonParser[Long]" class="anchorToMember"></a><a id="forLong:JsonParser[Long]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../io/dylemma/spac/json/package$$JsonParserApplyOps.html#forLong:io.dylemma.spac.json.package.JsonParser[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">forLong</span><span class="result">: <a href="index.html#JsonParser[+Out]=io.dylemma.spac.Parser[io.dylemma.spac.json.JsonEvent,Out]" name="io.dylemma.spac.json.JsonParser" id="io.dylemma.spac.json.JsonParser" class="extmbr">JsonParser</a>[<span name="scala.Long" class="extype">Long</span>]</span></span><p class="shortcomment cmt">A JsonParser that captures a <code>JLong</code> event as a <code>Long</code> value, failing if the first event is not a <code>JLong</code>.</p></li><li class="indented0 " name="io.dylemma.spac.json.JsonParserApplyOps#forNull" group="primitive" fullComment="no" data-isabs="false" visbl="pub"><a id="forNull:io.dylemma.spac.json.package.JsonParser[None.type]" class="anchorToMember"></a><a id="forNull:JsonParser[None.type]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../io/dylemma/spac/json/package$$JsonParserApplyOps.html#forNull:io.dylemma.spac.json.package.JsonParser[None.type]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">forNull</span><span class="result">: <a href="index.html#JsonParser[+Out]=io.dylemma.spac.Parser[io.dylemma.spac.json.JsonEvent,Out]" name="io.dylemma.spac.json.JsonParser" id="io.dylemma.spac.json.JsonParser" class="extmbr">JsonParser</a>[<span name="scala.None" class="extype">None</span>.type]</span></span><p class="shortcomment cmt">A JsonParser that returns <code>None</code> upon encountering a <code>JNull</code> event, failing upon encountering any other event or an EOF.</p></li><li class="indented0 " name="io.dylemma.spac.json.JsonParserApplyOps#forPrimitive" group="primitive" fullComment="yes" data-isabs="false" visbl="pub"><a id="forPrimitive[A](describePrimitive:String,matchPrimitive:io.dylemma.spac.json.JsonEvent=&gt;Option[A]):io.dylemma.spac.json.package.JsonParser[A]" class="anchorToMember"></a><a id="forPrimitive[A](String,(JsonEvent)=&gt;Option[A]):JsonParser[A]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../io/dylemma/spac/json/package$$JsonParserApplyOps.html#forPrimitive[A](describePrimitive:String,matchPrimitive:io.dylemma.spac.json.JsonEvent=&gt;Option[A]):io.dylemma.spac.json.package.JsonParser[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">forPrimitive</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="describePrimitive">describePrimitive: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="matchPrimitive">matchPrimitive: (<a href="JsonEvent.html" name="io.dylemma.spac.json.JsonEvent" id="io.dylemma.spac.json.JsonEvent" class="extype">JsonEvent</a>) =&gt; <span name="scala.Option" class="extype">Option</span>[<span name="io.dylemma.spac.json.JsonParserApplyOps.forPrimitive.A" class="extype">A</span>]</span>)</span><span class="result">: <a href="index.html#JsonParser[+Out]=io.dylemma.spac.Parser[io.dylemma.spac.json.JsonEvent,Out]" name="io.dylemma.spac.json.JsonParser" id="io.dylemma.spac.json.JsonParser" class="extmbr">JsonParser</a>[<span name="io.dylemma.spac.json.JsonParserApplyOps.forPrimitive.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Creates a JsonParser which captures the first JsonEvent it sees, expecting a primitive that can satisfy the <code>matchPrimitive</code> function.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a JsonParser which captures the first JsonEvent it sees, expecting a primitive that can satisfy the <code>matchPrimitive</code> function.</p><p>This is the low-level method used to implement the <code>forString</code>, <code>forInt</code>, etc parsers.
Its main use outside of those is if you want to create a parser that handles multiple different primitives without resorting to the use of <code>orElse</code>.
</p></div><dl class="paramcmts block"><dt class="tparam">A</dt><dd class="cmt"><p>The type of the extracted value</p></dd><dt class="param">describePrimitive</dt><dd class="cmt"><p>A message describing the type of event that this parser expects. Used to construct a SpacException if the <code>matchPrimitive</code> returns <code>None</code></p></dd><dt class="param">matchPrimitive</dt><dd class="cmt"><p>A function used to extract a value from the first JsonEvent this parser's handler encounters.</p></dd><dt>returns</dt><dd class="cmt"><p>A JsonParser which attempts to extract some value from the first event it encounters, throwing a SpacException if it cannot</p></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.json.JsonParserApplyOps#forString" group="primitive" fullComment="no" data-isabs="false" visbl="pub"><a id="forString:io.dylemma.spac.json.package.JsonParser[String]" class="anchorToMember"></a><a id="forString:JsonParser[String]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../io/dylemma/spac/json/package$$JsonParserApplyOps.html#forString:io.dylemma.spac.json.package.JsonParser[String]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">forString</span><span class="result">: <a href="index.html#JsonParser[+Out]=io.dylemma.spac.Parser[io.dylemma.spac.json.JsonEvent,Out]" name="io.dylemma.spac.json.JsonParser" id="io.dylemma.spac.json.JsonParser" class="extmbr">JsonParser</a>[<span name="scala.Predef.String" class="extype">String</span>]</span></span><p class="shortcomment cmt">A JsonParser that captures the string value from a <code>JsString</code> event, failing if the first event is not a <code>JsString</code>.</p></li><li class="indented0 " name="scala.AnyVal#getClass" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="getClass():Class[_&lt;:AnyVal]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../io/dylemma/spac/json/package$$JsonParserApplyOps.html#getClass():Class[_&lt;:AnyVal]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getClass</span><span class="params">()</span><span class="result">: <span name="scala.Predef.Class" class="extype">Class</span>[_ &lt;: <span name="scala.AnyVal" class="extype">AnyVal</span>]</span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyVal → Any</dd></dl></div></li><li class="indented0 " name="scala.Any#isInstanceOf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="isInstanceOf[T0]:Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../../../io/dylemma/spac/json/package$$JsonParserApplyOps.html#isInstanceOf[T0]:Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.json.JsonParserApplyOps#listOf" group="high" fullComment="yes" data-isabs="false" visbl="pub"><a id="listOf[T](parser:io.dylemma.spac.json.package.JsonParser[T])(implicitevidence$9:org.tpolecat.typename.TypeName[T],implicitcallerPos:io.dylemma.spac.CallerPos):io.dylemma.spac.json.package.JsonParser[List[T]]" class="anchorToMember"></a><a id="listOf[T](JsonParser[T])(TypeName[T],CallerPos):JsonParser[List[T]]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../io/dylemma/spac/json/package$$JsonParserApplyOps.html#listOf[T](parser:io.dylemma.spac.json.package.JsonParser[T])(implicitevidence$9:org.tpolecat.typename.TypeName[T],implicitcallerPos:io.dylemma.spac.CallerPos):io.dylemma.spac.json.package.JsonParser[List[T]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">listOf</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="parser">parser: <a href="index.html#JsonParser[+Out]=io.dylemma.spac.Parser[io.dylemma.spac.json.JsonEvent,Out]" name="io.dylemma.spac.json.JsonParser" id="io.dylemma.spac.json.JsonParser" class="extmbr">JsonParser</a>[<span name="io.dylemma.spac.json.JsonParserApplyOps.listOf.T" class="extype">T</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <span name="org.tpolecat.typename.TypeName" class="extype">TypeName</span>[<span name="io.dylemma.spac.json.JsonParserApplyOps.listOf.T" class="extype">T</span>]</span>, <span name="callerPos">callerPos: <a href="../CallerPos.html" name="io.dylemma.spac.CallerPos" id="io.dylemma.spac.CallerPos" class="extype">CallerPos</a></span>)</span><span class="result">: <a href="index.html#JsonParser[+Out]=io.dylemma.spac.Parser[io.dylemma.spac.json.JsonEvent,Out]" name="io.dylemma.spac.json.JsonParser" id="io.dylemma.spac.json.JsonParser" class="extmbr">JsonParser</a>[<span name="scala.List" class="extype">List</span>[<span name="io.dylemma.spac.json.JsonParserApplyOps.listOf.T" class="extype">T</span>]]</span></span><p class="shortcomment cmt">A JsonParser that parses a JSON array by parsing each item in the array via the given <code>parser</code>,
collecting the values to a List.</p><div class="fullcomment"><div class="comment cmt"><p>A JsonParser that parses a JSON array by parsing each item in the array via the given <code>parser</code>,
collecting the values to a List.</p><p>Note that if the given <code>parser</code> is available implicitly, you can use the other <code>listOf</code> signature instead.</p><p>This is a shortcut for <code>Splitter.json(anyIndex).joinBy(parser).parseToList</code>.</p><p>The returned parser will fail if the first event is not an <code>ArrayStart</code>,
or if any of the values inside the array cause the underlying parser to fail.
E.g. if the underlying parser is <code>JsonParser.forInt</code>, but one of the values in the array is a string,
the exception thrown by <code>JsonParser.forInt</code> will bubble up through the returned parser.</p><p>E.g.</p><pre><span class="kw">val</span> parser = JsonParser.listOf(JsonParser.forInt)
parser.parse(<span class="lit">"[1, 2, 3]"</span>) <span class="cmt">// returns List(1, 2, 3)</span>
parser.parse(<span class="lit">"[]"</span>) <span class="cmt">// returns Nil</span>
parser.parse(<span class="lit">"42"</span>) <span class="cmt">// throws a SpacException</span>
parser.parse(<span class="lit">"[1, 2, false]"</span>) <span class="cmt">// throws a SpacException</span></pre></div><dl class="paramcmts block"><dt class="tparam">T</dt><dd class="cmt"><p>The type of the values inside the array</p></dd><dt class="param">parser</dt><dd class="cmt"><p>The underlying parser to use for each value inside the array</p></dd><dt class="param">callerPos</dt><dd class="cmt"><p>Macro-derived location of the code calling this method, used to form a SpacTraceElement when the returned parser fails</p></dd><dt>returns</dt><dd class="cmt"><p>A JsonParser that parses an array of values as a List[T]</p></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.json.JsonParserApplyOps#listOf" group="high" fullComment="yes" data-isabs="false" visbl="pub"><a id="listOf[T](implicitevidence$7:org.tpolecat.typename.TypeName[T],implicitevidence$8:io.dylemma.spac.json.package.JsonParser[T],implicitcallerPos:io.dylemma.spac.CallerPos):io.dylemma.spac.json.package.JsonParser[List[T]]" class="anchorToMember"></a><a id="listOf[T](TypeName[T],JsonParser[T],CallerPos):JsonParser[List[T]]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../io/dylemma/spac/json/package$$JsonParserApplyOps.html#listOf[T](implicitevidence$7:org.tpolecat.typename.TypeName[T],implicitevidence$8:io.dylemma.spac.json.package.JsonParser[T],implicitcallerPos:io.dylemma.spac.CallerPos):io.dylemma.spac.json.package.JsonParser[List[T]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">listOf</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <span name="org.tpolecat.typename.TypeName" class="extype">TypeName</span>[<span name="io.dylemma.spac.json.JsonParserApplyOps.listOf.T" class="extype">T</span>]</span>, <span name="arg1">arg1: <a href="index.html#JsonParser[+Out]=io.dylemma.spac.Parser[io.dylemma.spac.json.JsonEvent,Out]" name="io.dylemma.spac.json.JsonParser" id="io.dylemma.spac.json.JsonParser" class="extmbr">JsonParser</a>[<span name="io.dylemma.spac.json.JsonParserApplyOps.listOf.T" class="extype">T</span>]</span>, <span name="callerPos">callerPos: <a href="../CallerPos.html" name="io.dylemma.spac.CallerPos" id="io.dylemma.spac.CallerPos" class="extype">CallerPos</a></span>)</span><span class="result">: <a href="index.html#JsonParser[+Out]=io.dylemma.spac.Parser[io.dylemma.spac.json.JsonEvent,Out]" name="io.dylemma.spac.json.JsonParser" id="io.dylemma.spac.json.JsonParser" class="extmbr">JsonParser</a>[<span name="scala.List" class="extype">List</span>[<span name="io.dylemma.spac.json.JsonParserApplyOps.listOf.T" class="extype">T</span>]]</span></span><p class="shortcomment cmt">A JsonParser that parses a JSON array by parsing each item in the array via the implicitly-available <code>JsonParser[T]</code>,
collecting the values to a List.</p><div class="fullcomment"><div class="comment cmt"><p>A JsonParser that parses a JSON array by parsing each item in the array via the implicitly-available <code>JsonParser[T]</code>,
collecting the values to a List.</p><p>This is a shortcut for <code>Splitter.json(anyIndex).as[T].parseToList</code>.</p><p>The returned parser will fail if the first event is not an <code>ArrayStart</code>,
or if any of the values inside the array cause the underlying parser to fail.
E.g. if the underlying parser is <code>JsonParser.forInt</code>, but one of the values in the array is a string,
the exception thrown by <code>JsonParser.forInt</code> will bubble up through the returned parser.</p><p>E.g.</p><pre><span class="kw">val</span> parser = JsonParser.listOf[<span class="std">Int</span>]
parser.parse(<span class="lit">"[1, 2, 3]"</span>) <span class="cmt">// returns List(1, 2, 3)</span>
parser.parse(<span class="lit">"[]"</span>) <span class="cmt">// returns Nil</span>
parser.parse(<span class="lit">"42"</span>) <span class="cmt">// throws a SpacException</span>
parser.parse(<span class="lit">"[1, 2, false]"</span>) <span class="cmt">// throws a SpacException</span></pre></div><dl class="paramcmts block"><dt class="tparam">T</dt><dd class="cmt"><p>The type of the values inside the array</p></dd><dt class="param">callerPos</dt><dd class="cmt"><p>Macro-derived location of the code calling this method, used to form a SpacTraceElement when the returned parser fails</p></dd><dt>returns</dt><dd class="cmt"><p>A JsonParser that parses an array of values as a List[T]</p></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.json.JsonParserApplyOps#nullable" group="primitive" fullComment="yes" data-isabs="false" visbl="pub"><a id="nullable[T](implicitparser:io.dylemma.spac.json.package.JsonParser[T]):io.dylemma.spac.json.package.JsonParser[Option[T]]" class="anchorToMember"></a><a id="nullable[T](JsonParser[T]):JsonParser[Option[T]]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../io/dylemma/spac/json/package$$JsonParserApplyOps.html#nullable[T](implicitparser:io.dylemma.spac.json.package.JsonParser[T]):io.dylemma.spac.json.package.JsonParser[Option[T]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">nullable</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="parser">parser: <a href="index.html#JsonParser[+Out]=io.dylemma.spac.Parser[io.dylemma.spac.json.JsonEvent,Out]" name="io.dylemma.spac.json.JsonParser" id="io.dylemma.spac.json.JsonParser" class="extmbr">JsonParser</a>[<span name="io.dylemma.spac.json.JsonParserApplyOps.nullable.T" class="extype">T</span>]</span>)</span><span class="result">: <a href="index.html#JsonParser[+Out]=io.dylemma.spac.Parser[io.dylemma.spac.json.JsonEvent,Out]" name="io.dylemma.spac.json.JsonParser" id="io.dylemma.spac.json.JsonParser" class="extmbr">JsonParser</a>[<span name="scala.Option" class="extype">Option</span>[<span name="io.dylemma.spac.json.JsonParserApplyOps.nullable.T" class="extype">T</span>]]</span></span><p class="shortcomment cmt">Wraps an existing JsonParser, creating a new JsonParser that will succeed with <code>None</code> if it encounters a <code>null</code>,
or succeed with a <code>Some(t)</code> if the wrapped parser succeeds.</p><div class="fullcomment"><div class="comment cmt"><p>Wraps an existing JsonParser, creating a new JsonParser that will succeed with <code>None</code> if it encounters a <code>null</code>,
or succeed with a <code>Some(t)</code> if the wrapped parser succeeds.</p><p>Used to parse values that may or may not be null.</p><p>Typical usage would be <code>JsonParser.nullable[String]</code>, passing the underlying <code>JsonParser[String]</code> implicitly.
</p></div><dl class="paramcmts block"><dt class="tparam">T</dt><dd class="cmt"><p>The type of the underlying parser's extracted value</p></dd><dt class="param">parser</dt><dd class="cmt"><p>The underlying parser which would typically fail upon encountering a <code>null</code></p></dd><dt>returns</dt><dd class="cmt"><p>A JsonParser which parses <code>null</code> as <code>None</code>, or else delegates to the underlying <code>parser</code></p></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.json.JsonParserApplyOps#nullableFieldOf" group="high" fullComment="yes" data-isabs="false" visbl="pub"><a id="nullableFieldOf[T](fieldName:String,parser:io.dylemma.spac.json.package.JsonParser[T])(implicitevidence$6:org.tpolecat.typename.TypeName[T],implicitcallerPos:io.dylemma.spac.CallerPos):io.dylemma.spac.json.package.JsonParser[Option[T]]" class="anchorToMember"></a><a id="nullableFieldOf[T](String,JsonParser[T])(TypeName[T],CallerPos):JsonParser[Option[T]]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../io/dylemma/spac/json/package$$JsonParserApplyOps.html#nullableFieldOf[T](fieldName:String,parser:io.dylemma.spac.json.package.JsonParser[T])(implicitevidence$6:org.tpolecat.typename.TypeName[T],implicitcallerPos:io.dylemma.spac.CallerPos):io.dylemma.spac.json.package.JsonParser[Option[T]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">nullableFieldOf</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="fieldName">fieldName: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="parser">parser: <a href="index.html#JsonParser[+Out]=io.dylemma.spac.Parser[io.dylemma.spac.json.JsonEvent,Out]" name="io.dylemma.spac.json.JsonParser" id="io.dylemma.spac.json.JsonParser" class="extmbr">JsonParser</a>[<span name="io.dylemma.spac.json.JsonParserApplyOps.nullableFieldOf.T" class="extype">T</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <span name="org.tpolecat.typename.TypeName" class="extype">TypeName</span>[<span name="io.dylemma.spac.json.JsonParserApplyOps.nullableFieldOf.T" class="extype">T</span>]</span>, <span name="callerPos">callerPos: <a href="../CallerPos.html" name="io.dylemma.spac.CallerPos" id="io.dylemma.spac.CallerPos" class="extype">CallerPos</a></span>)</span><span class="result">: <a href="index.html#JsonParser[+Out]=io.dylemma.spac.Parser[io.dylemma.spac.json.JsonEvent,Out]" name="io.dylemma.spac.json.JsonParser" id="io.dylemma.spac.json.JsonParser" class="extmbr">JsonParser</a>[<span name="scala.Option" class="extype">Option</span>[<span name="io.dylemma.spac.json.JsonParserApplyOps.nullableFieldOf.T" class="extype">T</span>]]</span></span><p class="shortcomment cmt">A JsonParser that parses a JSON object by parsing the given optional field with the given <code>parser</code>.</p><div class="fullcomment"><div class="comment cmt"><p>A JsonParser that parses a JSON object by parsing the given optional field with the given <code>parser</code>.</p><p>Note that if the given <code>parser</code> is available implicitly, you can use the other <code>nullableFieldOf</code> signature.</p><p>Unlike with <code>fieldOf</code>, the returned parser will succeed with a <code>None</code> if the expected field is missing,
or if the value in the expected field is null.
However, it will still fail if the first event is not an <code>ObjectStart</code>.</p><p>E.g.</p><pre><span class="kw">val</span> parser = JsonParser.nullableFieldOf(<span class="lit">"foo"</span>, JsonParser.forInt)
parser.parse(<span class="lit">"{}"</span>) <span class="cmt">// returns None</span>
parser.parse(<span class="lit">"12"</span>) <span class="cmt">// throws a SpacException</span>
parser.parse(<span class="lit">"""{ "foo": 42 }""") // returns 42
parser.parse("""{ "foo": null }""") // returns null
parser.parse("""{ "foo": "hello" }""") // throws a SpacException</span></pre></div><dl class="paramcmts block"><dt class="tparam">T</dt><dd class="cmt"><p>The type of the extracted value</p></dd><dt class="param">fieldName</dt><dd class="cmt"><p>The name of the field</p></dd><dt class="param">parser</dt><dd class="cmt"><p>The underlying parser used to parse the value inside the expected field in the object</p></dd><dt class="param">callerPos</dt><dd class="cmt"><p>Macro-derived location of the code calling this method, used to form a SpacTraceElement when the returned parser fails</p></dd><dt>returns</dt><dd class="cmt"><p>A JsonParser that parses the given field from a JSON object, wrapping a successfully-parsed value in <code>Some</code>, and treating null or a missing field as <code>None</code></p></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.json.JsonParserApplyOps#nullableFieldOf" group="high" fullComment="yes" data-isabs="false" visbl="pub"><a id="nullableFieldOf[T](fieldName:String)(implicitevidence$4:org.tpolecat.typename.TypeName[T],implicitevidence$5:io.dylemma.spac.json.package.JsonParser[T],implicitcallerPos:io.dylemma.spac.CallerPos):io.dylemma.spac.json.package.JsonParser[Option[T]]" class="anchorToMember"></a><a id="nullableFieldOf[T](String)(TypeName[T],JsonParser[T],CallerPos):JsonParser[Option[T]]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../io/dylemma/spac/json/package$$JsonParserApplyOps.html#nullableFieldOf[T](fieldName:String)(implicitevidence$4:org.tpolecat.typename.TypeName[T],implicitevidence$5:io.dylemma.spac.json.package.JsonParser[T],implicitcallerPos:io.dylemma.spac.CallerPos):io.dylemma.spac.json.package.JsonParser[Option[T]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">nullableFieldOf</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="fieldName">fieldName: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <span name="org.tpolecat.typename.TypeName" class="extype">TypeName</span>[<span name="io.dylemma.spac.json.JsonParserApplyOps.nullableFieldOf.T" class="extype">T</span>]</span>, <span name="arg1">arg1: <a href="index.html#JsonParser[+Out]=io.dylemma.spac.Parser[io.dylemma.spac.json.JsonEvent,Out]" name="io.dylemma.spac.json.JsonParser" id="io.dylemma.spac.json.JsonParser" class="extmbr">JsonParser</a>[<span name="io.dylemma.spac.json.JsonParserApplyOps.nullableFieldOf.T" class="extype">T</span>]</span>, <span name="callerPos">callerPos: <a href="../CallerPos.html" name="io.dylemma.spac.CallerPos" id="io.dylemma.spac.CallerPos" class="extype">CallerPos</a></span>)</span><span class="result">: <a href="index.html#JsonParser[+Out]=io.dylemma.spac.Parser[io.dylemma.spac.json.JsonEvent,Out]" name="io.dylemma.spac.json.JsonParser" id="io.dylemma.spac.json.JsonParser" class="extmbr">JsonParser</a>[<span name="scala.Option" class="extype">Option</span>[<span name="io.dylemma.spac.json.JsonParserApplyOps.nullableFieldOf.T" class="extype">T</span>]]</span></span><p class="shortcomment cmt">A JsonParser that parses a JSON object by parsing the given optional field with an implicitly-available <code>JsonParser[T]</code>.</p><div class="fullcomment"><div class="comment cmt"><p>A JsonParser that parses a JSON object by parsing the given optional field with an implicitly-available <code>JsonParser[T]</code>.</p><p>Unlike with <code>fieldOf</code>, the returned parser will succeed with a <code>None</code> if the expected field is missing,
or if the value in the expected field is null.
However, it will still fail if the first event is not an <code>ObjectStart</code>.</p><p>E.g.</p><pre><span class="kw">val</span> parser = JsonParser.nullableFieldOf[<span class="std">Int</span>](<span class="lit">"foo"</span>)
parser.parse(<span class="lit">"{}"</span>) <span class="cmt">// returns None</span>
parser.parse(<span class="num">12</span>) <span class="cmt">// throws a SpacException</span>
parser.parse(<span class="lit">"""{ "foo": 42 }""") // returns 42
parser.parse("""{ "foo": null }""") // returns null
parser.parse("""{ "foo": "hello" }""") // throws a SpacException</span></pre></div><dl class="paramcmts block"><dt class="tparam">T</dt><dd class="cmt"><p>The type of the extracted value</p></dd><dt class="param">fieldName</dt><dd class="cmt"><p>The name of the field</p></dd><dt class="param">callerPos</dt><dd class="cmt"><p>Macro-derived location of the code calling this method, used to form a SpacTraceElement when the returned parser fails</p></dd><dt>returns</dt><dd class="cmt"><p>A JsonParser that parses the given field from a JSON object, wrapping a successfully-parsed value in <code>Some</code>, and treating null or a missing field as <code>None</code></p></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.json.JsonParserApplyOps#objectOf" group="high" fullComment="yes" data-isabs="false" visbl="pub"><a id="objectOf[T](parser:io.dylemma.spac.json.package.JsonParser[T])(implicitevidence$12:org.tpolecat.typename.TypeName[T],implicitcallerPos:io.dylemma.spac.CallerPos):io.dylemma.spac.json.package.JsonParser[Map[String,T]]" class="anchorToMember"></a><a id="objectOf[T](JsonParser[T])(TypeName[T],CallerPos):JsonParser[Map[String,T]]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../io/dylemma/spac/json/package$$JsonParserApplyOps.html#objectOf[T](parser:io.dylemma.spac.json.package.JsonParser[T])(implicitevidence$12:org.tpolecat.typename.TypeName[T],implicitcallerPos:io.dylemma.spac.CallerPos):io.dylemma.spac.json.package.JsonParser[Map[String,T]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">objectOf</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="parser">parser: <a href="index.html#JsonParser[+Out]=io.dylemma.spac.Parser[io.dylemma.spac.json.JsonEvent,Out]" name="io.dylemma.spac.json.JsonParser" id="io.dylemma.spac.json.JsonParser" class="extmbr">JsonParser</a>[<span name="io.dylemma.spac.json.JsonParserApplyOps.objectOf.T" class="extype">T</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <span name="org.tpolecat.typename.TypeName" class="extype">TypeName</span>[<span name="io.dylemma.spac.json.JsonParserApplyOps.objectOf.T" class="extype">T</span>]</span>, <span name="callerPos">callerPos: <a href="../CallerPos.html" name="io.dylemma.spac.CallerPos" id="io.dylemma.spac.CallerPos" class="extype">CallerPos</a></span>)</span><span class="result">: <a href="index.html#JsonParser[+Out]=io.dylemma.spac.Parser[io.dylemma.spac.json.JsonEvent,Out]" name="io.dylemma.spac.json.JsonParser" id="io.dylemma.spac.json.JsonParser" class="extmbr">JsonParser</a>[<span name="scala.Predef.Map" class="extype">Map</span>[<span name="scala.Predef.String" class="extype">String</span>, <span name="io.dylemma.spac.json.JsonParserApplyOps.objectOf.T" class="extype">T</span>]]</span></span><p class="shortcomment cmt">A JsonParser that parses a JSON object by interpreting every field as a value of type <code>T</code> using the given <code>parser</code>,
yielding a <code>Map</code> containing the parsed <code>field -&gt; value</code> pairs.</p><div class="fullcomment"><div class="comment cmt"><p>A JsonParser that parses a JSON object by interpreting every field as a value of type <code>T</code> using the given <code>parser</code>,
yielding a <code>Map</code> containing the parsed <code>field -&gt; value</code> pairs.</p><p>Note that if the given <code>parser</code> is available implicitly, you can use the other <code>objectOf</code> signature instead.</p><p>This is a shortcut for <code>Splitter.json(anyField).map(field -&gt; parser.map(field -&gt; _)).parseToMap</code>.</p><p>The returned parser will fail if the first event is not an <code>ObjectStart</code>,
or if any of the field values in the object cause the underlying parser to fail.
E.g. if the underlying parser is <code>JsonParser.forString</code>, but one of the fields contains some non-string value,
the exception thrown by <code>JsonParser.forString</code> will bubble up through the returned parser.</p><p>E.g.</p><pre><span class="kw">val</span> parser = JsonParser.objectOf(JsonParser.forInt)
parser.parse(<span class="lit">"""{ "foo": 1, "bar": 2 }""") // returns Map("foo" -&gt; 1, "bar" -&gt; 2)
parser.parse("""{ "foo": 1, "bar": "whoops" }""") // throws a SpacException
parser.parse("13") // throws a SpacException</span></pre></div><dl class="paramcmts block"><dt class="tparam">T</dt><dd class="cmt"><p>The type of the values inside each field</p></dd><dt class="param">parser</dt><dd class="cmt"><p>The underlying parser used to parse each field in the object</p></dd><dt class="param">callerPos</dt><dd class="cmt"><p>Macro-derived location of the code calling this method, used to form a SpacTraceElement when the returned parser fails</p></dd><dt>returns</dt><dd class="cmt"><p>A JsonParser that parses an object as a <code>Map[String, T]</code></p></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.json.JsonParserApplyOps#objectOf" group="high" fullComment="yes" data-isabs="false" visbl="pub"><a id="objectOf[T](implicitevidence$10:org.tpolecat.typename.TypeName[T],implicitevidence$11:io.dylemma.spac.json.package.JsonParser[T],implicitcallerPos:io.dylemma.spac.CallerPos):io.dylemma.spac.json.package.JsonParser[Map[String,T]]" class="anchorToMember"></a><a id="objectOf[T](TypeName[T],JsonParser[T],CallerPos):JsonParser[Map[String,T]]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../io/dylemma/spac/json/package$$JsonParserApplyOps.html#objectOf[T](implicitevidence$10:org.tpolecat.typename.TypeName[T],implicitevidence$11:io.dylemma.spac.json.package.JsonParser[T],implicitcallerPos:io.dylemma.spac.CallerPos):io.dylemma.spac.json.package.JsonParser[Map[String,T]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">objectOf</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <span name="org.tpolecat.typename.TypeName" class="extype">TypeName</span>[<span name="io.dylemma.spac.json.JsonParserApplyOps.objectOf.T" class="extype">T</span>]</span>, <span name="arg1">arg1: <a href="index.html#JsonParser[+Out]=io.dylemma.spac.Parser[io.dylemma.spac.json.JsonEvent,Out]" name="io.dylemma.spac.json.JsonParser" id="io.dylemma.spac.json.JsonParser" class="extmbr">JsonParser</a>[<span name="io.dylemma.spac.json.JsonParserApplyOps.objectOf.T" class="extype">T</span>]</span>, <span name="callerPos">callerPos: <a href="../CallerPos.html" name="io.dylemma.spac.CallerPos" id="io.dylemma.spac.CallerPos" class="extype">CallerPos</a></span>)</span><span class="result">: <a href="index.html#JsonParser[+Out]=io.dylemma.spac.Parser[io.dylemma.spac.json.JsonEvent,Out]" name="io.dylemma.spac.json.JsonParser" id="io.dylemma.spac.json.JsonParser" class="extmbr">JsonParser</a>[<span name="scala.Predef.Map" class="extype">Map</span>[<span name="scala.Predef.String" class="extype">String</span>, <span name="io.dylemma.spac.json.JsonParserApplyOps.objectOf.T" class="extype">T</span>]]</span></span><p class="shortcomment cmt">A JsonParser that parses a JSON object by interpreting every field as a value of type <code>T</code> using the implicitly-available <code>JsonParser[T]</code>,
yielding a <code>Map</code> containing the parsed <code>field -&gt; value</code> pairs.</p><div class="fullcomment"><div class="comment cmt"><p>A JsonParser that parses a JSON object by interpreting every field as a value of type <code>T</code> using the implicitly-available <code>JsonParser[T]</code>,
yielding a <code>Map</code> containing the parsed <code>field -&gt; value</code> pairs.</p><p>This is a shortcut for <code>Splitter.json(anyField).map(field -&gt; implicitly[JsonParser[T]].map(field -&gt; _)).parseToMap</code>.</p><p>The returned parser will fail if the first event is not an <code>ObjectStart</code>,
or if any of the field values in the object cause the underlying parser to fail.
E.g. if the underlying parser is <code>JsonParser.forString</code>, but one of the fields contains some non-string value,
the exception thrown by <code>JsonParser.forString</code> will bubble up through the returned parser.</p><p>E.g.</p><pre><span class="kw">val</span> parser = JsonParser.objectOf[<span class="std">Int</span>]
parser.parse(<span class="lit">"""{ "foo": 1, "bar": 2 }""") // returns Map("foo" -&gt; 1, "bar" -&gt; 2)
parser.parse("""{ "foo": 1, "bar": "whoops" }""") // throws a SpacException
parser.parse("13") // throws a SpacException</span></pre></div><dl class="paramcmts block"><dt class="tparam">T</dt><dd class="cmt"><p>The type of the values inside each field</p></dd><dt class="param">callerPos</dt><dd class="cmt"><p>Macro-derived location of the code calling this method, used to form a SpacTraceElement when the returned parser fails</p></dd><dt>returns</dt><dd class="cmt"><p>A JsonParser that parses an object as a <code>Map[String, T]</code></p></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.json.JsonParserApplyOps#objectOfNullable" group="high" fullComment="yes" data-isabs="false" visbl="pub"><a id="objectOfNullable[T](parser:io.dylemma.spac.json.package.JsonParser[T])(implicitevidence$15:org.tpolecat.typename.TypeName[T],implicitcallerPos:io.dylemma.spac.CallerPos):io.dylemma.spac.json.package.JsonParser[Map[String,T]]" class="anchorToMember"></a><a id="objectOfNullable[T](JsonParser[T])(TypeName[T],CallerPos):JsonParser[Map[String,T]]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../io/dylemma/spac/json/package$$JsonParserApplyOps.html#objectOfNullable[T](parser:io.dylemma.spac.json.package.JsonParser[T])(implicitevidence$15:org.tpolecat.typename.TypeName[T],implicitcallerPos:io.dylemma.spac.CallerPos):io.dylemma.spac.json.package.JsonParser[Map[String,T]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">objectOfNullable</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="parser">parser: <a href="index.html#JsonParser[+Out]=io.dylemma.spac.Parser[io.dylemma.spac.json.JsonEvent,Out]" name="io.dylemma.spac.json.JsonParser" id="io.dylemma.spac.json.JsonParser" class="extmbr">JsonParser</a>[<span name="io.dylemma.spac.json.JsonParserApplyOps.objectOfNullable.T" class="extype">T</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <span name="org.tpolecat.typename.TypeName" class="extype">TypeName</span>[<span name="io.dylemma.spac.json.JsonParserApplyOps.objectOfNullable.T" class="extype">T</span>]</span>, <span name="callerPos">callerPos: <a href="../CallerPos.html" name="io.dylemma.spac.CallerPos" id="io.dylemma.spac.CallerPos" class="extype">CallerPos</a></span>)</span><span class="result">: <a href="index.html#JsonParser[+Out]=io.dylemma.spac.Parser[io.dylemma.spac.json.JsonEvent,Out]" name="io.dylemma.spac.json.JsonParser" id="io.dylemma.spac.json.JsonParser" class="extmbr">JsonParser</a>[<span name="scala.Predef.Map" class="extype">Map</span>[<span name="scala.Predef.String" class="extype">String</span>, <span name="io.dylemma.spac.json.JsonParserApplyOps.objectOfNullable.T" class="extype">T</span>]]</span></span><p class="shortcomment cmt">A JsonParser that parses a JSON object by interpreting every possibly-null field as a value of type <code>T</code> using
the given <code>JsonParser[T]</code>, filtering out null fields and yielding a <code>Map</code> containing <code>field -&gt; value</code> pairs
of the successfully-parsed fields.</p><div class="fullcomment"><div class="comment cmt"><p>A JsonParser that parses a JSON object by interpreting every possibly-null field as a value of type <code>T</code> using
the given <code>JsonParser[T]</code>, filtering out null fields and yielding a <code>Map</code> containing <code>field -&gt; value</code> pairs
of the successfully-parsed fields.</p><p>Note that if the given <code>parser</code> is available implicitly, you can use the other <code>objectOfNullable</code> signature instead.</p><p>Note that while fields with <code>null</code> instead of an expected <code>T</code> value are filtered out,
non-null fields that cause the underlying parser to fail will cause the returned parser to fail as well.
As with <code>objectOf</code>, the returned parser will fail if the first event is not an <code>ObjectStart</code>.</p><p>E.g.</p><pre><span class="kw">val</span> parser = JsonParser.objectOfNullable(JsonParser.forInt)
parser.parse(<span class="lit">"""{ "foo": 1, "bar": 2 }""") // returns Map("foo" -&gt; 1, "bar" -&gt; 2)
parser.parse("""{ "foo": 1, "bar": null }""") // returns Map("foo" -&gt; 1)
parser.parse("""{ "foo": 1, "bar": "whoops" }""") // throws a SpacException
parser.parse("13") // throws a SpacException</span></pre></div><dl class="paramcmts block"><dt class="tparam">T</dt><dd class="cmt"><p>The type of the values inside each field</p></dd><dt class="param">parser</dt><dd class="cmt"><p>The underlying parser used to parse values (aside from null) for each of the fields in the input object</p></dd><dt class="param">callerPos</dt><dd class="cmt"><p>Macro-derived location of the code calling this method, used to form a SpacTraceElement when the returned parser fails</p></dd><dt>returns</dt><dd class="cmt"><p>A JsonParser that parses an object as a <code>Map[String, T]</code>, ignoring fields with <code>null</code> values</p></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.json.JsonParserApplyOps#objectOfNullable" group="high" fullComment="yes" data-isabs="false" visbl="pub"><a id="objectOfNullable[T](implicitevidence$13:org.tpolecat.typename.TypeName[T],implicitevidence$14:io.dylemma.spac.json.package.JsonParser[T],implicitcallerPos:io.dylemma.spac.CallerPos):io.dylemma.spac.json.package.JsonParser[Map[String,T]]" class="anchorToMember"></a><a id="objectOfNullable[T](TypeName[T],JsonParser[T],CallerPos):JsonParser[Map[String,T]]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../io/dylemma/spac/json/package$$JsonParserApplyOps.html#objectOfNullable[T](implicitevidence$13:org.tpolecat.typename.TypeName[T],implicitevidence$14:io.dylemma.spac.json.package.JsonParser[T],implicitcallerPos:io.dylemma.spac.CallerPos):io.dylemma.spac.json.package.JsonParser[Map[String,T]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">objectOfNullable</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <span name="org.tpolecat.typename.TypeName" class="extype">TypeName</span>[<span name="io.dylemma.spac.json.JsonParserApplyOps.objectOfNullable.T" class="extype">T</span>]</span>, <span name="arg1">arg1: <a href="index.html#JsonParser[+Out]=io.dylemma.spac.Parser[io.dylemma.spac.json.JsonEvent,Out]" name="io.dylemma.spac.json.JsonParser" id="io.dylemma.spac.json.JsonParser" class="extmbr">JsonParser</a>[<span name="io.dylemma.spac.json.JsonParserApplyOps.objectOfNullable.T" class="extype">T</span>]</span>, <span name="callerPos">callerPos: <a href="../CallerPos.html" name="io.dylemma.spac.CallerPos" id="io.dylemma.spac.CallerPos" class="extype">CallerPos</a></span>)</span><span class="result">: <a href="index.html#JsonParser[+Out]=io.dylemma.spac.Parser[io.dylemma.spac.json.JsonEvent,Out]" name="io.dylemma.spac.json.JsonParser" id="io.dylemma.spac.json.JsonParser" class="extmbr">JsonParser</a>[<span name="scala.Predef.Map" class="extype">Map</span>[<span name="scala.Predef.String" class="extype">String</span>, <span name="io.dylemma.spac.json.JsonParserApplyOps.objectOfNullable.T" class="extype">T</span>]]</span></span><p class="shortcomment cmt">A JsonParser that parses a JSON object by interpreting every possibly-null field as a value of type <code>T</code> using
an implicitly-available <code>JsonParser[T]</code>, filtering out null fields and yielding a <code>Map</code> containing <code>field -&gt; value</code> pairs
of the successfully-parsed fields.</p><div class="fullcomment"><div class="comment cmt"><p>A JsonParser that parses a JSON object by interpreting every possibly-null field as a value of type <code>T</code> using
an implicitly-available <code>JsonParser[T]</code>, filtering out null fields and yielding a <code>Map</code> containing <code>field -&gt; value</code> pairs
of the successfully-parsed fields.</p><p>Note that while fields with <code>null</code> instead of an expected <code>T</code> value are filtered out,
non-null fields that cause the underlying parser to fail will cause the returned parser to fail as well.
As with <code>objectOf</code>, the returned parser will fail if the first event is not an <code>ObjectStart</code>.</p><p>E.g.</p><pre><span class="kw">val</span> parser = JsonParser.objectOfNullable[<span class="std">Int</span>]
parser.parse(<span class="lit">"""{ "foo": 1, "bar": 2 }""") // returns Map("foo" -&gt; 1, "bar" -&gt; 2)
parser.parse("""{ "foo": 1, "bar": null }""") // returns Map("foo" -&gt; 1)
parser.parse("""{ "foo": 1, "bar": "whoops" }""") // throws a SpacException
parser.parse("13") // throws a SpacException</span></pre></div><dl class="paramcmts block"><dt class="tparam">T</dt><dd class="cmt"><p>The type of the values inside each field</p></dd><dt class="param">callerPos</dt><dd class="cmt"><p>Macro-derived location of the code calling this method, used to form a SpacTraceElement when the returned parser fails</p></dd><dt>returns</dt><dd class="cmt"><p>A JsonParser that parses an object as a <code>Map[String, T]</code>, ignoring fields with <code>null</code> values</p></dd></dl></div></li><li class="indented0 " name="scala.Any#toString" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="toString():String" class="anchorToMember"></a> <span class="permalink"><a href="../../../../io/dylemma/spac/json/package$$JsonParserApplyOps.html#toString():String" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">toString</span><span class="params">()</span><span class="result">: <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#java.lang.String" name="java.lang.String" id="java.lang.String" class="extype">String</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li></ol></div><div class="values members"><h3>Deprecated Value Members</h3><ol><li class="indented0 " name="scala.Predef.StringFormat#formatted" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="formatted(fmtstr:String):String" class="anchorToMember"></a><a id="formatted(String):String" class="anchorToMember"></a> <span class="permalink"><a href="../../../../io/dylemma/spac/json/package$$JsonParserApplyOps.html#formatted(fmtstr:String):String" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit deprecated" title="Deprecated: (Since version 2.12.16) Use formatString.format(value) instead of value.formatted(formatString),
or use the f&quot;&quot; string interpolator. In Java 15 and later, formatted resolves to the new method in String which has reversed parameters.">formatted</span><span class="params">(<span name="fmtstr">fmtstr: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <span name="scala.Predef.String" class="extype">String</span></span></span><div class="fullcomment"><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="io.dylemma.spac.json.JsonParserApplyOps" id="io.dylemma.spac.json.JsonParserApplyOps" class="extype">JsonParserApplyOps</a> to<span name="scala.Predef.StringFormat" class="extype">StringFormat</span>[<a href="" name="io.dylemma.spac.json.JsonParserApplyOps" id="io.dylemma.spac.json.JsonParserApplyOps" class="extype">JsonParserApplyOps</a>] performed by method StringFormat in scala.Predef.</dd><dt>Definition Classes</dt><dd>StringFormat</dd><dt>Annotations</dt><dd><span class="name">@deprecated</span> <span class="name">@inline</span><span class="args">()</span> </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 2.12.16)</i> Use <code>formatString.format(value)</code> instead of <code>value.formatted(formatString)</code>,
or use the <code>f""</code> string interpolator. In Java 15 and later, <code>formatted</code> resolves to the new method in String which has reversed parameters.</p></dd></dl></div></li><li class="indented0 " name="scala.Predef.ArrowAssoc#→" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="→[B](y:B):(A,B)" class="anchorToMember"></a><a id="→[B](B):(JsonParserApplyOps,B)" class="anchorToMember"></a> <span class="permalink"><a href="../../../../io/dylemma/spac/json/package$$JsonParserApplyOps.html#→[B](y:B):(A,B)" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit deprecated" title="gt4s: $u2192. Deprecated: (Since version 2.13.0) Use -&gt; instead. If you still wish to display it as one character, consider using a font with programming ligatures such as Fira Code.">→</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="y">y: <span name="scala.Predef.ArrowAssoc.→.B" class="extype">B</span></span>)</span><span class="result">: (<a href="" name="io.dylemma.spac.json.JsonParserApplyOps" id="io.dylemma.spac.json.JsonParserApplyOps" class="extype">JsonParserApplyOps</a>, <span name="scala.Predef.ArrowAssoc.→.B" class="extype">B</span>)</span></span><div class="fullcomment"><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="io.dylemma.spac.json.JsonParserApplyOps" id="io.dylemma.spac.json.JsonParserApplyOps" class="extype">JsonParserApplyOps</a> to<span name="scala.Predef.ArrowAssoc" class="extype">ArrowAssoc</span>[<a href="" name="io.dylemma.spac.json.JsonParserApplyOps" id="io.dylemma.spac.json.JsonParserApplyOps" class="extype">JsonParserApplyOps</a>] performed by method ArrowAssoc in scala.Predef.</dd><dt>Definition Classes</dt><dd>ArrowAssoc</dd><dt>Annotations</dt><dd><span class="name">@deprecated</span> </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 2.13.0)</i> Use <code>-&gt;</code> instead. If you still wish to display it as one character, consider using a font with programming ligatures such as Fira Code.</p></dd></dl></div></li></ol></div></div><div id="inheritedMembers"><div name="scala.AnyVal" class="parent"><h3>Inherited from <span name="scala.AnyVal" class="extype">AnyVal</span></h3></div><div name="scala.Any" class="parent"><h3>Inherited from <span name="scala.Any" class="extype">Any</span></h3></div><div name="scala.Predef.any2stringadd" class="conversion"><h3>Inherited by implicit conversion any2stringadd from<a href="" name="io.dylemma.spac.json.JsonParserApplyOps" id="io.dylemma.spac.json.JsonParserApplyOps" class="extype">JsonParserApplyOps</a> to <span name="scala.Predef.any2stringadd" class="extype">any2stringadd</span>[<a href="" name="io.dylemma.spac.json.JsonParserApplyOps" id="io.dylemma.spac.json.JsonParserApplyOps" class="extype">JsonParserApplyOps</a>]</h3></div><div name="scala.Predef.StringFormat" class="conversion"><h3>Inherited by implicit conversion StringFormat from<a href="" name="io.dylemma.spac.json.JsonParserApplyOps" id="io.dylemma.spac.json.JsonParserApplyOps" class="extype">JsonParserApplyOps</a> to <span name="scala.Predef.StringFormat" class="extype">StringFormat</span>[<a href="" name="io.dylemma.spac.json.JsonParserApplyOps" id="io.dylemma.spac.json.JsonParserApplyOps" class="extype">JsonParserApplyOps</a>]</h3></div><div name="scala.Predef.Ensuring" class="conversion"><h3>Inherited by implicit conversion Ensuring from<a href="" name="io.dylemma.spac.json.JsonParserApplyOps" id="io.dylemma.spac.json.JsonParserApplyOps" class="extype">JsonParserApplyOps</a> to <span name="scala.Predef.Ensuring" class="extype">Ensuring</span>[<a href="" name="io.dylemma.spac.json.JsonParserApplyOps" id="io.dylemma.spac.json.JsonParserApplyOps" class="extype">JsonParserApplyOps</a>]</h3></div><div name="scala.Predef.ArrowAssoc" class="conversion"><h3>Inherited by implicit conversion ArrowAssoc from<a href="" name="io.dylemma.spac.json.JsonParserApplyOps" id="io.dylemma.spac.json.JsonParserApplyOps" class="extype">JsonParserApplyOps</a> to <span name="scala.Predef.ArrowAssoc" class="extype">ArrowAssoc</span>[<a href="" name="io.dylemma.spac.json.JsonParserApplyOps" id="io.dylemma.spac.json.JsonParserApplyOps" class="extype">JsonParserApplyOps</a>]</h3></div></div><div id="groupedMembers"><div name="high" class="group"><h3>Objects and Arrays</h3></div><div name="primitive" class="group"><h3>Primitives</h3></div><div name="Ungrouped" class="group"><h3>Ungrouped</h3></div></div></div><div id="tooltip"></div><div id="footer"></div></body></div></div></div></body></html>

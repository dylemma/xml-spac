<!DOCTYPE html ><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/><title></title><meta content="" name="description"/><meta content="" name="keywords"/><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><link href="../../../lib/index.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../../lib/template.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../../lib/print.css" media="print" type="text/css" rel="stylesheet"/><link href="../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css"/><script type="text/javascript" src="../../../lib/jquery.min.js"></script><script type="text/javascript" src="../../../lib/index.js"></script><script type="text/javascript" src="../../../index.js"></script><script type="text/javascript" src="../../../lib/scheduler.js"></script><script type="text/javascript" src="../../../lib/template.js"></script><script type="text/javascript">/* this variable can be used by the JS to determine the path to the root document */
var toRoot = '../../../';</script></head><body><div id="search"><span id="doc-title"><span id="doc-version"></span></span> <span class="close-results"><span class="left">&lt;</span> Back</span><div id="textfilter"><span class="input"><input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/"/><i class="clear material-icons"></i><i id="search-icon" class="material-icons"></i></span></div></div><div id="search-results"><div id="search-progress"><div id="progress-fill"></div></div><div id="results-content"><div id="entity-results"></div><div id="member-results"></div></div></div><div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;"><div id="content-container" style="-webkit-overflow-scrolling: touch;"><div id="subpackage-spacer"><div id="packages"><h1>Packages</h1><ul><li class="indented0 " name="_root_.root" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="_root_" class="anchorToMember"></a><a id="root:_root_" class="anchorToMember"></a> <span class="permalink"><a href="../../../index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../../index.html" title=""><span class="name">root</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented1 " name="_root_.io" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="io" class="anchorToMember"></a><a id="io:io" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../index.html" title=""><span class="name">io</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented2 " name="io.dylemma" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="dylemma" class="anchorToMember"></a><a id="dylemma:dylemma" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../index.html" title=""><span class="name">dylemma</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../index.html" name="io" id="io" class="extype">io</a></dd></dl></div></li><li class="indented3 " name="io.dylemma.spac" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="spac" class="anchorToMember"></a><a id="spac:spac" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="index.html" title="SPaC (short for &quot;Streaming Parser Combinators&quot;) is a library for building stream consumers in a declarative style, specialized for tree-like data types like XML and JSON."><span class="name">spac</span></a></span><p class="shortcomment cmt">SPaC (short for "<strong>S</strong>treaming <strong>Pa</strong>rser <strong>C</strong>ombinators")
is a library for building stream consumers in a declarative style, specialized for tree-like data
types like XML and JSON.</p><div class="fullcomment"><div class="comment cmt"><p>SPaC (short for "<strong>S</strong>treaming <strong>Pa</strong>rser <strong>C</strong>ombinators")
is a library for building stream consumers in a declarative style, specialized for tree-like data
types like XML and JSON.</p><p>Many utilities for handling XML and JSON data involve parsing the entire "document" to some DOM model,
then inspecting and transforming that model to extract information.
The downside to these utilities is that when the document is very large, the DOM may not fit in memory.
The workaround for this type of problem is to treat the document as a stream of "events",
e.g. "StartElement" and "EndElement" for XML, or "StartObject" and "EndObject" for JSON.
The downside to this workaround is that writing code to handle these streams can be complicated and
error-prone, especially when the DOM is complicated.</p><p>SPaC's goal is to drastically simplify the process of creating code to handle these streams.</p><p>This package contains the "core" SPaC traits; <code>Parser</code>, <code>Transformer</code>, <code>Splitter</code>, and <code>ContextMatcher</code>.</p><p>See the <code>xml</code> and <code>json</code> subpackages (provided by the <code>xml-spac</code> and <code>json-spac</code> libraries respectively)
for specific utilities related to handling XML and JSON event streams.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="io.dylemma" id="io.dylemma" class="extype">dylemma</a></dd></dl></div></li><li class="indented4 " name="io.dylemma.spac.interop" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="interop" class="anchorToMember"></a><a id="interop:interop" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/interop/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="interop/index.html" title=""><span class="name">interop</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="index.html" name="io.dylemma.spac" id="io.dylemma.spac" class="extype">spac</a></dd></dl></div></li><li class="indented4 " name="io.dylemma.spac.json" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="json" class="anchorToMember"></a><a id="json:json" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/json/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="json/index.html" title="This package provides extensions to the core &quot;spac&quot; library which allow for the handling of JSON data."><span class="name">json</span></a></span><p class="shortcomment cmt">This package provides extensions to the core "spac" library which allow for the handling of JSON data.</p><div class="fullcomment"><div class="comment cmt"><p>This package provides extensions to the core "spac" library which allow for the handling of JSON data.</p><p>Rather than creating explicit classes that extend <code>Parser</code>, <code>Transformer</code>, and <code>Splitter</code>,
this package provides type aliases and implicit extensions.
For example, <code>JsonParser[A]</code> is just a type alias for <code>Parser[JsonEvent, A]</code>,
and <code>JsonParser</code> is just a call to <code>Parser[JsonEvent]</code>.</p><p>Implicit JsonParsers are available for each of the JSON primitive types:</p><ul><li><code>string</code></li><li><code>number</code> (expressed as <code>Int</code>, <code>Long</code>, <code>Float</code>, or <code>Double</code>)</li><li><code>boolean</code></li><li><code>null</code> (expressed as <code>None.type</code>)</li></ul><p>Helpers are available for parsing JSON arrays and objects:</p><ul><li><code>JsonParser.listOf[A]</code> to parse an <code>array</code><code> where each value is an </code>A<code></code></li><li><code>JsonParser.objectOf[A]</code> to parse an <code>object</code> where the value for each field an <code>A</code></li><li><code>JsonParser.objectOfNullable[A]</code> to parse an <code>object</code> where the value for each field is either <code>null</code> or an <code>A</code>, filtering out the <code>null</code>s</li><li><code>JsonParser.fieldOf[A](fieldName)</code> to parse a specific field from an object</li></ul><p>A DSL for creating json-specific ContextMatchers is provided to make it more convenient to call <code>Splitter.json</code>.
For example:</p><pre>Splitter.json(<span class="lit">"foo"</span> \ <span class="lit">"bar"</span>).as[<span class="std">String</span>].parseFirst</pre><p>Can be used to capture <code>rootJson.foo.bar</code> as a String in</p><pre>{
  <span class="lit">"foo"</span>: {
    <span class="lit">"bar"</span>: <span class="lit">"hello"</span>
  }
}</pre><p>To "split" values inside arrays, index-related context matchers are available, e.g.</p><pre>Splitter.json(<span class="lit">"foo"</span> \ anyIndex).as[<span class="std">Int</span>].parseToList</pre><p>Can be used to capture each of the numbers in the "foo" array in</p><pre>{
  <span class="lit">"foo"</span>: [<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>]
}</pre><p>A note about JsonEvents in spac:
JSON doesn't have any explicit markers for when a field ends, or when an array index starts or ends;
those context changes are essentially inferred by the presence of some other event.
For example, instead of a "field end" event, typically there will be either a new "field start" or a token representing the end of the current object.
With spac, splitters and context matchers generally operate under the assumption that a "stack push" event (like a field start) will eventually be
followed by a corresponding "stack pop" event (i.e. field end).</p><p>To allow for this, these "inferred" events (FieldEnd, IndexStart, IndexEnd) are explicitly represented as JsonEvents in the stream being parsed.
Keep this in mind when creating JSON ContextMatchers:</p><ul><li><code>field</code>-related matchers will match a stack like <code>case ObjectStart :: FieldStart(_) :: _</code></li><li><code>index</code>-related matchers will match a stack like <code>case ArrayStart :: IndexStart(_) :: _</code>
</li></ul></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="index.html" name="io.dylemma.spac" id="io.dylemma.spac" class="extype">spac</a></dd></dl></div></li><li class="indented4 " name="io.dylemma.spac.xml" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="xml" class="anchorToMember"></a><a id="xml:xml" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/xml/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="xml/index.html" title="This package provides extensions to the core &quot;spac&quot; library which allow for the handling of XML data."><span class="name">xml</span></a></span><p class="shortcomment cmt">This package provides extensions to the core "spac" library which allow for the handling of XML data.</p><div class="fullcomment"><div class="comment cmt"><p>This package provides extensions to the core "spac" library which allow for the handling of XML data.</p><p>Rather than creating explicit classes that extend <code>Parser</code>, <code>Transformer</code>, and <code>Splitter</code>,
this package provides type aliases and implicit extensions.
For example, <code>XmlParser[A]</code> is just a type alias for <code>Parser[XmlEvent, A]</code>,
and <code>XmlParser</code> is just a call to <code>Parser[XmlEvent]</code>.</p><p>Three main Parser methods are added to <code>Parser[XmlEvent]</code> via the <code>XmlParserApplyOps</code> implicit class:</p><ul><li><code>XmlParser.forText</code> - for capturing raw text</li><li><code>XmlParser.attr</code> - for capturing mandatory attributes from elements</li><li><code>XmlParser.attrOpt</code> - for capturing optional attributes from elements</li></ul><p>One main Splitter constructor method is added to <code>Splitter</code> via the <code>XmlSplitterApplyOps</code> implicit class:</p><ul><li><code>Splitter.xml</code> - for creating splitters based on an inspection of an "element stack"</li></ul><p>Three main Splitter member methods are added to <code>Splitter[XmlEvent, C]</code> via the <code>XmlSplitterOps</code> implicit class:</p><ul><li><code>.attr</code> - alias for <code>.joinBy(XmlParser.attr(...))</code></li><li><code>.attrOpt</code> - alias for <code>.joinBy(XmlParser.attrOpt(...))</code></li><li><code>.text</code> - alias for <code>.joinBy(XmlParser.forText)</code></li></ul><p>A DSL for creating xml-specific ContextMatchers is provided to make it more convenient to call <code>Splitter.xml</code>.
For example:</p><pre>Splitter.xml(<span class="lit">"things"</span> \ <span class="lit">"thing"</span>).attr(<span class="lit">"foo"</span>).parseToList</pre><p>Can be used to capture a list of the "foo" attributes in the <code>&lt;thing&gt;</code> elements in</p><pre>&lt;things&gt;
   &lt;thing foo=<span class="lit">"hello"</span> /&gt;
   &lt;thing foo=<span class="lit">"Goodbye"</span>&gt;
      &lt;extra&gt;junk&lt;/extra&gt;
   &lt;/thing&gt;
&lt;/thing&gt;</pre></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="index.html" name="io.dylemma.spac" id="io.dylemma.spac" class="extype">spac</a></dd></dl></div></li><li class="current-entities indented3"><a href="CallerPos$.html" title="" class="object"></a> <a href="CallerPos.html" title="Represents a location in code that called a method." class="class"></a><a href="CallerPos.html" title="Represents a location in code that called a method.">CallerPos</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="ContextChange.html" title="Represents either entering (ContextPush) or exiting (ContextPop) some matched context within a stream of inputs." class="trait"></a><a href="ContextChange.html" title="Represents either entering (ContextPush) or exiting (ContextPop) some matched context within a stream of inputs.">ContextChange</a></li><li class="current-entities indented3"><a href="ContextLocation$.html" title="" class="object"></a> <a href="ContextLocation.html" title="A map-like representation of some location in a stream, used like stack trace elements for reporting errors in stream processing." class="trait"></a><a href="ContextLocation.html" title="A map-like representation of some location in a stream, used like stack trace elements for reporting errors in stream processing.">ContextLocation</a></li><li class="current-entities indented3"><a href="ContextMatcher$.html" title="" class="object"></a> <a href="ContextMatcher.html" title="An object responsible for inspecting a stack of StartElement events and determining if they correspond to some &quot;context&quot; value of type A." class="trait"></a><a href="ContextMatcher.html" title="An object responsible for inspecting a stack of StartElement events and determining if they correspond to some &quot;context&quot; value of type A.">ContextMatcher</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="ContextPop$.html" title="" class="object"></a><a href="ContextPop$.html" title="">ContextPop</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="ContextPush.html" title="" class="class"></a><a href="ContextPush.html" title="">ContextPush</a></li><li class="current-entities indented3"><a href="ContextTrace$.html" title="" class="object"></a> <a href="ContextTrace.html" title="" class="class"></a><a href="ContextTrace.html" title="">ContextTrace</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="HasLocation.html" title="Marker trait used by SpacTraceElement.InInput to extract location information from inputs that cause parsing exceptions." class="trait"></a><a href="HasLocation.html" title="Marker trait used by SpacTraceElement.InInput to extract location information from inputs that cause parsing exceptions.">HasLocation</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="LowPriorityTypeReduceImplicits.html" title="" class="trait"></a><a href="LowPriorityTypeReduceImplicits.html" title="">LowPriorityTypeReduceImplicits</a></li><li class="current-entities indented3"><a href="Parser$.html" title="" class="object"></a> <a href="" title="Primary &quot;spac&quot; abstraction which represents a sink for data events." class="trait"></a><a href="" title="Primary &quot;spac&quot; abstraction which represents a sink for data events.">Parser</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="ParserApplyWithBoundInput.html" title="Convenience version of the Parser companion object, which provides parser constructors with the In type already specified." class="class"></a><a href="ParserApplyWithBoundInput.html" title="Convenience version of the Parser companion object, which provides parser constructors with the In type already specified.">ParserApplyWithBoundInput</a></li><li class="current-entities indented3"><a href="Signal$.html" title="" class="object"></a> <a href="Signal.html" title="Value used by Transformer.Handler to indicate to its upstream producer whether or not the handler wants to continue receiving values." class="trait"></a><a href="Signal.html" title="Value used by Transformer.Handler to indicate to its upstream producer whether or not the handler wants to continue receiving values.">Signal</a></li><li class="current-entities indented3"><a href="SingleItemContextMatcher$.html" title="" class="object"></a> <a href="SingleItemContextMatcher.html" title="Specialization of ContextMatcher which only checks the first element in the stack for matching operations." class="trait"></a><a href="SingleItemContextMatcher.html" title="Specialization of ContextMatcher which only checks the first element in the stack for matching operations.">SingleItemContextMatcher</a></li><li class="current-entities indented3"><a href="Source$.html" title="Note: this companion object provides a few very basic Source-constructor helpers, but the real useful functionality is provided by the &quot;parser backend&quot; modules like xml-spac-javax and json-spac-jackson, via JavaxSource and JacksonSource." class="object"></a> <a href="Source.html" title="A Source[A] is like an Iterable[A] but with a built-in assumption that the iterator may be closeable, intended for use as a convenient argument to a Parser's parse method." class="trait"></a><a href="Source.html" title="A Source[A] is like an Iterable[A] but with a built-in assumption that the iterator may be closeable, intended for use as a convenient argument to a Parser's parse method.">Source</a></li><li class="current-entities indented3"><a href="SpacException$.html" title="" class="object"></a> <a href="SpacException.html" title="Base class for all exceptions thrown by Spac parsers." class="class"></a><a href="SpacException.html" title="Base class for all exceptions thrown by Spac parsers.">SpacException</a></li><li class="current-entities indented3"><a href="SpacTraceElement$.html" title="" class="object"></a> <a href="SpacTraceElement.html" title="A play on words vs StackTraceElement, a *Spac* trace element represents some contextual location inside the logic of a spac Parser, or the location of an input to that parser." class="trait"></a><a href="SpacTraceElement.html" title="A play on words vs StackTraceElement, a *Spac* trace element represents some contextual location inside the logic of a spac Parser, or the location of an input to that parser.">SpacTraceElement</a></li><li class="current-entities indented3"><a href="Splitter$.html" title="" class="object"></a> <a href="Splitter.html" title="Primary &quot;spac&quot; abstraction that acts as a selector for sub-streams within a single input stream." class="trait"></a><a href="Splitter.html" title="Primary &quot;spac&quot; abstraction that acts as a selector for sub-streams within a single input stream.">Splitter</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="SplitterApplyWithBoundInput.html" title="" class="class"></a><a href="SplitterApplyWithBoundInput.html" title="">SplitterApplyWithBoundInput</a></li><li class="current-entities indented3"><a href="StackInterpretation$.html" title="" class="object"></a> <a href="StackInterpretation.html" title="Outcome of a StackLike[In, Elem], indicating whether a given input was a stack push/pop, and whether that push/pop should be treated as happening before or after the input that caused it." class="trait"></a><a href="StackInterpretation.html" title="Outcome of a StackLike[In, Elem], indicating whether a given input was a stack push/pop, and whether that push/pop should be treated as happening before or after the input that caused it.">StackInterpretation</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="StackLike.html" title="Typeclass that perceives a subset of In values as either &quot;stack push&quot; or &quot;stack pop&quot; events." class="trait"></a><a href="StackLike.html" title="Typeclass that perceives a subset of In values as either &quot;stack push&quot; or &quot;stack pop&quot; events.">StackLike</a></li><li class="current-entities indented3"><a href="Transformer$.html" title="" class="object"></a> <a href="Transformer.html" title="Primary &quot;spac&quot; abstraction which represents a transformation stage for a stream of data events" class="trait"></a><a href="Transformer.html" title="Primary &quot;spac&quot; abstraction which represents a transformation stage for a stream of data events">Transformer</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="TransformerApplyWithBoundInput.html" title="Convenience version of the Transformer companion object, which provides transformer constructors with the In type already specified." class="class"></a><a href="TransformerApplyWithBoundInput.html" title="Convenience version of the Transformer companion object, which provides transformer constructors with the In type already specified.">TransformerApplyWithBoundInput</a></li><li class="current-entities indented3"><a href="TypeReduce$.html" title="" class="object"></a> <a href="TypeReduce.html" title="Type-level tuple reduction function that treats Unit as an Identity." class="trait"></a><a href="TypeReduce.html" title="Type-level tuple reduction function that treats Unit as an Identity.">TypeReduce</a></li><li class="current-entities indented3"><a href="Unconsable$.html" title="" class="object"></a> <a href="Unconsable.html" title="Typeclass for collections that can be efficiently split into a head element and a tail collection as long as they are not empty." class="trait"></a><a href="Unconsable.html" title="Typeclass for collections that can be efficiently split into a head element and a tail collection as long as they are not empty.">Unconsable</a></li></ul></div></div><div id="content"><body class="trait type"><div id="definition"><a href="Parser$.html" title="See companion object"><div class="big-circle trait-companion-object">t</div></a><p id="owner"><a href="../../index.html" name="io" id="io" class="extype">io</a>.<a href="../index.html" name="io.dylemma" id="io.dylemma" class="extype">dylemma</a>.<a href="index.html" name="io.dylemma.spac" id="io.dylemma.spac" class="extype">spac</a></p><h1><a href="Parser$.html" title="See companion object">Parser</a><span class="permalink"><a href="../../../io/dylemma/spac/Parser.html" title="Permalink"><i class="material-icons"></i></a></span></h1><h3><span class="morelinks"><div>Companion <a href="Parser$.html" title="See companion object">object Parser</a></div></span></h3></div><h4 id="signature" class="signature"><span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><span class="name">Parser</span><span class="tparams">[<span name="In">-In</span>, <span name="Out">+Out</span>]</span><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span></h4><div id="comment" class="fullcommenttop"><div class="comment cmt"><p>Primary "spac" abstraction which represents a sink for data events.</p><p>Parsers are responsible for interpreting a stream of <code>In</code> events as a single result of type <code>Out</code>.
The actual interpretation is performed by a <code>Parser.Handler</code> which the Parser is responsible for constructing.
Handlers may be internally-mutable, and so they are generally only constructed by the <code>parse</code> helper methods or by other handlers.
Parsers themselves are immutable, acting as "handler factories", and so they may be freely reused.</p><p>A parser differs from typical "fold" operations in that it may choose to abort early with a result,
leaving the remainder of the data stream untouched.
</p></div><dl class="paramcmts block"><dt class="tparam">In</dt><dd class="cmt"><p>event/input type</p></dd><dt class="tparam">Out</dt><dd class="cmt"><p>result type</p></dd></dl><dl class="attributes block"><dt>Self Type</dt><dd><a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>]</dd><dt>Source</dt><dd><a href="https://github.com/dylemma/xml-spac/tree/0.10.0/core/src/main/scala/io/dylemma/spac/Parser.scala" target="_blank">Parser.scala</a></dd></dl><div class="toggleContainer"><div class="toggle block"><span>Linear Supertypes</span><div class="superTypes hiddenContent"><span name="scala.AnyRef" class="extype">AnyRef</span>, <span name="scala.Any" class="extype">Any</span></div></div></div><div class="toggleContainer"><div class="toggle block"><span>Known Subclasses</span><div class="subClasses hiddenContent"><a href="Parser$$Stateless.html" name="io.dylemma.spac.Parser.Stateless" id="io.dylemma.spac.Parser.Stateless" class="extype">Stateless</a></div></div></div></div><div id="mbrsel"><div class="toggle"></div><div id="memberfilter"><i class="material-icons arrow"></i><span class="input"><input placeholder="Filter all members" id="mbrsel-input" type="text" accesskey="/"/></span><i class="clear material-icons"></i></div><div id="filterby"><div id="order"><span class="filtertype">Ordering</span><ol><li class="group out"><span>Grouped</span></li><li class="alpha in"><span>Alphabetic</span></li><li class="inherit out"><span>By Inheritance</span></li></ol></div><div class="ancestors"><span class="filtertype">Inherited<br/></span><ol id="linearization"><li class="in" name="io.dylemma.spac.Parser"><span>Parser</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li></ol></div><div class="ancestors"><span class="filtertype">Implicitly<br/></span><ol id="implicits"><li class="in" name="io.dylemma.spac.Parser.ParserFollowedByOps" data-hidden="false"><span>by ParserFollowedByOps</span></li><li class="in" name="scala.Predef.any2stringadd" data-hidden="true"><span>by any2stringadd</span></li><li class="in" name="scala.Predef.StringFormat" data-hidden="true"><span>by StringFormat</span></li><li class="in" name="scala.Predef.Ensuring" data-hidden="true"><span>by Ensuring</span></li><li class="in" name="scala.Predef.ArrowAssoc" data-hidden="true"><span>by ArrowAssoc</span></li></ol></div><div class="ancestors"><span class="filtertype"></span><ol><li class="hideall out"><span>Hide All</span></li><li class="showall in"><span>Show All</span></li></ol></div><div id="visbl"><span class="filtertype">Visibility</span><ol><li class="public in"><span>Public</span></li><li class="protected out"><span>Protected</span></li></ol></div></div></div><div id="template"><div id="allMembers"><div class="values members"><h3>Abstract Value Members</h3><ol><li class="indented0 " name="io.dylemma.spac.Parser#newHandler" group="abstract" fullComment="yes" data-isabs="true" visbl="pub"><a id="newHandler:io.dylemma.spac.Parser.Handler[In,Out]" class="anchorToMember"></a><a id="newHandler:Handler[In,Out]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#newHandler:io.dylemma.spac.Parser.Handler[In,Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">newHandler</span><span class="result">: <a href="Parser$$Handler.html" name="io.dylemma.spac.Parser.Handler" id="io.dylemma.spac.Parser.Handler" class="extype">Handler</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>]</span></span><p class="shortcomment cmt">Parser's main abstract method; constructs a new Handler representing this parser's logic.</p><div class="fullcomment"><div class="comment cmt"><p>Parser's main abstract method; constructs a new Handler representing this parser's logic.
Parsers are expected to be immutable, but Handlers may be internally-mutable.
</p></div></div></li></ol></div><div class="values members"><h3>Concrete Value Members</h3><ol><li class="indented0 " name="scala.AnyRef#!=" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="!=(x$1:Any):Boolean" class="anchorToMember"></a><a id="!=(Any):Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#!=(x$1:Any):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $bang$eq">!=</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef###" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="##:Int" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html###:Int" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $hash$hash">##</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.Predef.any2stringadd#+" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="+(other:String):String" class="anchorToMember"></a><a id="+(String):String" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#+(other:String):String" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit" title="gt4s: $plus">+</span><span class="params">(<span name="other">other: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <span name="scala.Predef.String" class="extype">String</span></span></span><div class="fullcomment"><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>] to<span name="scala.Predef.any2stringadd" class="extype">any2stringadd</span>[<a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>]] performed by method any2stringadd in scala.Predef.</dd><dt>Definition Classes</dt><dd>any2stringadd</dd></dl></div></li><li class="indented0 " name="scala.Predef.ArrowAssoc#-&gt;" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="-&gt;[B](y:B):(A,B)" class="anchorToMember"></a><a id="-&gt;[B](B):(Parser[In,Out],B)" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#-&gt;[B](y:B):(A,B)" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit" title="gt4s: $minus$greater">-&gt;</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="y">y: <span name="scala.Predef.ArrowAssoc.-&gt;.B" class="extype">B</span></span>)</span><span class="result">: (<a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>], <span name="scala.Predef.ArrowAssoc.-&gt;.B" class="extype">B</span>)</span></span><div class="fullcomment"><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>] to<span name="scala.Predef.ArrowAssoc" class="extype">ArrowAssoc</span>[<a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>]] performed by method ArrowAssoc in scala.Predef.</dd><dt>Definition Classes</dt><dd>ArrowAssoc</dd><dt>Annotations</dt><dd><span class="name">@inline</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#==" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="==(x$1:Any):Boolean" class="anchorToMember"></a><a id="==(Any):Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#==(x$1:Any):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $eq$eq">==</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.Any#asInstanceOf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="asInstanceOf[T0]:T0" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#asInstanceOf[T0]:T0" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span name="scala.Any.asInstanceOf.T0" class="extype">T0</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser#asTransformer" group="combinators" fullComment="no" data-isabs="false" visbl="pub"><a id="asTransformer:io.dylemma.spac.Transformer[In,Out]" class="anchorToMember"></a><a id="asTransformer:Transformer[In,Out]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#asTransformer:io.dylemma.spac.Transformer[In,Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">asTransformer</span><span class="result">: <a href="Transformer.html" name="io.dylemma.spac.Transformer" id="io.dylemma.spac.Transformer" class="extype">Transformer</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>]</span></span><p class="shortcomment cmt">Represent this parser as a <code>Transformer</code> which emits this parser's result
</p></li><li class="indented0 " name="io.dylemma.spac.Parser#attempt" group="combinators" fullComment="no" data-isabs="false" visbl="pub"><a id="attempt:io.dylemma.spac.Parser[In,Either[Throwable,Out]]" class="anchorToMember"></a><a id="attempt:Parser[In,Either[Throwable,Out]]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#attempt:io.dylemma.spac.Parser[In,Either[Throwable,Out]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">attempt</span><span class="result">: <a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="scala.Either" class="extype">Either</span>[<span name="scala.Throwable" class="extype">Throwable</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>]]</span></span><p class="shortcomment cmt">Like <code>wrapSafe</code>, but represents exceptions as <code>Left</code> and successful results as <code>Right</code>
</p></li><li class="indented0 " name="io.dylemma.spac.Parser#beforeContext" group="combinators" fullComment="yes" data-isabs="false" visbl="pub"><a id="beforeContext[I2&lt;:In,StackElem](matcher:io.dylemma.spac.ContextMatcher[StackElem,Any])(implicitstackable:io.dylemma.spac.StackLike[I2,StackElem],implicitpos:io.dylemma.spac.CallerPos):io.dylemma.spac.Parser[I2,Out]" class="anchorToMember"></a><a id="beforeContext[I2&lt;:In,StackElem](ContextMatcher[StackElem,Any])(StackLike[I2,StackElem],CallerPos):Parser[I2,Out]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#beforeContext[I2&lt;:In,StackElem](matcher:io.dylemma.spac.ContextMatcher[StackElem,Any])(implicitstackable:io.dylemma.spac.StackLike[I2,StackElem],implicitpos:io.dylemma.spac.CallerPos):io.dylemma.spac.Parser[I2,Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">beforeContext</span><span class="tparams">[<span name="I2">I2 &lt;: <span name="io.dylemma.spac.Parser.In" class="extype">In</span></span>, <span name="StackElem">StackElem</span>]</span><span class="params">(<span name="matcher">matcher: <a href="ContextMatcher.html" name="io.dylemma.spac.ContextMatcher" id="io.dylemma.spac.ContextMatcher" class="extype">ContextMatcher</a>[<span name="io.dylemma.spac.Parser.beforeContext.StackElem" class="extype">StackElem</span>, <span name="scala.Any" class="extype">Any</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="stackable">stackable: <a href="StackLike.html" name="io.dylemma.spac.StackLike" id="io.dylemma.spac.StackLike" class="extype">StackLike</a>[<span name="io.dylemma.spac.Parser.beforeContext.I2" class="extype">I2</span>, <span name="io.dylemma.spac.Parser.beforeContext.StackElem" class="extype">StackElem</span>]</span>, <span name="pos">pos: <a href="CallerPos.html" name="io.dylemma.spac.CallerPos" id="io.dylemma.spac.CallerPos" class="extype">CallerPos</a></span>)</span><span class="result">: <a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.beforeContext.I2" class="extype">I2</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>]</span></span><p class="shortcomment cmt">Specialization of <code>interruptedBy</code> for stack-like input types, such that an interruption will occur upon entering
a stack context that can be matched by the given <code>matcher</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Specialization of <code>interruptedBy</code> for stack-like input types, such that an interruption will occur upon entering
a stack context that can be matched by the given <code>matcher</code>.</p><p>Example:</p><pre><span class="kw">val</span> preludeContext = * \ <span class="lit">"prelude"</span>
<span class="kw">val</span> dataContext = * \ <span class="lit">"data"</span>
<span class="kw">for</span> {
  prelude <span class="kw">&lt;-</span> Splitter(preludeContext).firstOption[Prelude].beforeContext(dataContext).followedByStream
  data <span class="kw">&lt;-</span> Splitter(dataContext).as[Data]
} <span class="kw">yield</span> data</pre></div><dl class="paramcmts block"><dt class="tparam">I2</dt><dd class="cmt"><p>Subtype of <code>In</code>, or just <code>In</code> (to satisfy contravariance of Parser's <code>In</code> type)</p></dd><dt class="tparam">StackElem</dt><dd class="cmt"><p>Specialization of the <code>In</code> type for when it represents a stack push or pop</p></dd><dt class="param">matcher</dt><dd class="cmt"><p>A matching function that operates on a context stack</p></dd><dt class="param">stackable</dt><dd class="cmt"><p>Interprets the inputs as stack push/pop events to accumulate a context stack</p></dd><dt>returns</dt><dd class="cmt"><p>A parser which will perform an early <code>finish()</code> when a matching context is encountered</p></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#clone" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="clone():Object" class="anchorToMember"></a><a id="clone():AnyRef" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#clone():Object" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clone</span><span class="params">()</span><span class="result">: <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Attributes</dt><dd>protected[<span name="java.lang" class="extype">lang</span>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.CloneNotSupportedException]</span></span>)</span> <span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.Predef.Ensuring#ensuring" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ensuring(cond:A=&gt;Boolean,msg:=&gt;Any):A" class="anchorToMember"></a><a id="ensuring((Parser[In,Out])=&gt;Boolean,=&gt;Any):Parser[In,Out]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#ensuring(cond:A=&gt;Boolean,msg:=&gt;Any):A" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">ensuring</span><span class="params">(<span name="cond">cond: (<a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>]) =&gt; <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="msg">msg: =&gt; <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>]</span></span><div class="fullcomment"><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>] to<span name="scala.Predef.Ensuring" class="extype">Ensuring</span>[<a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>]] performed by method Ensuring in scala.Predef.</dd><dt>Definition Classes</dt><dd>Ensuring</dd></dl></div></li><li class="indented0 " name="scala.Predef.Ensuring#ensuring" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ensuring(cond:A=&gt;Boolean):A" class="anchorToMember"></a><a id="ensuring((Parser[In,Out])=&gt;Boolean):Parser[In,Out]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#ensuring(cond:A=&gt;Boolean):A" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">ensuring</span><span class="params">(<span name="cond">cond: (<a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>]) =&gt; <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>]</span></span><div class="fullcomment"><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>] to<span name="scala.Predef.Ensuring" class="extype">Ensuring</span>[<a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>]] performed by method Ensuring in scala.Predef.</dd><dt>Definition Classes</dt><dd>Ensuring</dd></dl></div></li><li class="indented0 " name="scala.Predef.Ensuring#ensuring" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ensuring(cond:Boolean,msg:=&gt;Any):A" class="anchorToMember"></a><a id="ensuring(Boolean,=&gt;Any):Parser[In,Out]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#ensuring(cond:Boolean,msg:=&gt;Any):A" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">ensuring</span><span class="params">(<span name="cond">cond: <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="msg">msg: =&gt; <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>]</span></span><div class="fullcomment"><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>] to<span name="scala.Predef.Ensuring" class="extype">Ensuring</span>[<a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>]] performed by method Ensuring in scala.Predef.</dd><dt>Definition Classes</dt><dd>Ensuring</dd></dl></div></li><li class="indented0 " name="scala.Predef.Ensuring#ensuring" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ensuring(cond:Boolean):A" class="anchorToMember"></a><a id="ensuring(Boolean):Parser[In,Out]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#ensuring(cond:Boolean):A" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">ensuring</span><span class="params">(<span name="cond">cond: <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>]</span></span><div class="fullcomment"><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>] to<span name="scala.Predef.Ensuring" class="extype">Ensuring</span>[<a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>]] performed by method Ensuring in scala.Predef.</dd><dt>Definition Classes</dt><dd>Ensuring</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#eq" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="eq(x$1:AnyRef):Boolean" class="anchorToMember"></a><a id="eq(AnyRef):Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#eq(x$1:AnyRef):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">eq</span><span class="params">(<span name="arg0">arg0: <span name="scala.AnyRef" class="extype">AnyRef</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#equals" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="equals(x$1:Object):Boolean" class="anchorToMember"></a><a id="equals(AnyRef):Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#equals(x$1:Object):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span name="scala.AnyRef" class="extype">AnyRef</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser#expectInputs" group="combinators" fullComment="yes" data-isabs="false" visbl="pub"><a id="expectInputs[I2&lt;:In](expectations:List[(String,I2=&gt;Boolean)]):io.dylemma.spac.Parser[I2,Out]" class="anchorToMember"></a><a id="expectInputs[I2&lt;:In](List[(String,(I2)=&gt;Boolean)]):Parser[I2,Out]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#expectInputs[I2&lt;:In](expectations:List[(String,I2=&gt;Boolean)]):io.dylemma.spac.Parser[I2,Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">expectInputs</span><span class="tparams">[<span name="I2">I2 &lt;: <span name="io.dylemma.spac.Parser.In" class="extype">In</span></span>]</span><span class="params">(<span name="expectations">expectations: <span name="scala.List" class="extype">List</span>[(<span name="scala.Predef.String" class="extype">String</span>, (<span name="io.dylemma.spac.Parser.expectInputs.I2" class="extype">I2</span>) =&gt; <span name="scala.Boolean" class="extype">Boolean</span>)]</span>)</span><span class="result">: <a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.expectInputs.I2" class="extype">I2</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>]</span></span><p class="shortcomment cmt">Impose expectations on the sequence of inputs to be received by handlers created by this parser.</p><div class="fullcomment"><div class="comment cmt"><p>Impose expectations on the sequence of inputs to be received by handlers created by this parser.
As this parser's handler receives an input, the input will be tested against the head of the expectations list.
If the test returns <code>false</code>, the expectation is failed and the handler will throw an exception.
If the test returns <code>true</code>, the expectation is satisfied, and the handler will advance to the next expectation.
If there are no more expectations left in the list (i.e. N inputs have satisfied the corresponding N expectations),
then all expectations have been met and inputs will be treated as normal by the handler.
If the handler receives an EOF before all expectations are met, it will throw an exception.
</p></div><dl class="paramcmts block"><dt class="param">expectations</dt><dd class="cmt"><p>A sequence of <code>label -&gt; test</code> expectations imposed on inputs to this parser</p></dd><dt>returns</dt><dd class="cmt"><p>A copy of this parser with expectations imposed on its inputs</p></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#finalize" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="finalize():Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#finalize():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">finalize</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Attributes</dt><dd>protected[<span name="java.lang" class="extype">lang</span>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="symbol">classOf[java.lang.Throwable]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser.ParserFollowedByOps#followedBy" group="combinators" fullComment="yes" data-isabs="false" visbl="pub"><a id="followedBy:io.dylemma.spac.Parser.FollowedBy[In,A,io.dylemma.spac.Parser]" class="anchorToMember"></a><a id="followedBy:FollowedBy[In,Out,Parser]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#followedBy:io.dylemma.spac.Parser.FollowedBy[In,A,io.dylemma.spac.Parser]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">followedBy</span><span class="result">: <a href="Parser$$FollowedBy.html" name="io.dylemma.spac.Parser.FollowedBy" id="io.dylemma.spac.Parser.FollowedBy" class="extype">FollowedBy</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>, <a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>]</span></span><p class="shortcomment cmt">Intermediate object for creating a sequenced parser in which the result of this parser will
be used to initialize a second parser as soon as it is available.</p><div class="fullcomment"><div class="comment cmt"><p>Intermediate object for creating a sequenced parser in which the result of this parser will
be used to initialize a second parser as soon as it is available.</p><p>In other words, the source (series of <code>In</code> values) will be fed into this Parser until this
parser's handler returns a result of type <code>Out</code>. At that point, the second parser (as
specified by using the <code>apply</code> or <code>flatMap</code> methods on the <code>FollowedBy</code> returned by this method)
will be instantiated. Any relevant "stack events" (see <code>Stackable</code>) will be replayed so the
second parser has the right context, and from that point on, all <code>In</code> values will be sent
to the second parser. When that second parser returns a result, that result becomes the output
of the combined parser created by <code>this.followedBy(out =&gt; makeSecondParser(out))</code></p><p>Examples:</p><pre><span class="kw">val</span> p1: Parser[A] = <span class="cmt">/* ... */</span>
<span class="kw">def</span> getP2(p1Result: A): Parser[B] = <span class="cmt">/* ... */</span>
<span class="kw">val</span> combined: Parser[B] = p1.followedBy(getP2)

<span class="cmt">// alternative `flatMap` syntax</span>
<span class="kw">val</span> combined: Parser[B] = <span class="kw">for</span> {
  p1Result <span class="kw">&lt;-</span> p1.followedBy
  p2Result <span class="kw">&lt;-</span> getP2(p1Result)
} <span class="kw">yield</span> p2Result</pre><p>See Parser's <code>interruptedBy</code>, which is useful when a <code>transformer.parseFirstOption</code>
must be <code>followedBy</code> some other parser.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>] to<a href="Parser$$ParserFollowedByOps.html" name="io.dylemma.spac.Parser.ParserFollowedByOps" id="io.dylemma.spac.Parser.ParserFollowedByOps" class="extype">ParserFollowedByOps</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>] performed by method ParserFollowedByOps in <a href="Parser$.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">io.dylemma.spac.Parser</a>.</dd><dt>Definition Classes</dt><dd><a href="Parser$$ParserFollowedByOps.html" name="io.dylemma.spac.Parser.ParserFollowedByOps" id="io.dylemma.spac.Parser.ParserFollowedByOps" class="extype">ParserFollowedByOps</a></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser.ParserFollowedByOps#followedByParser" group="combinators" fullComment="yes" data-isabs="false" visbl="pub"><a id="followedByParser:io.dylemma.spac.Parser.FollowedBy[In,A,io.dylemma.spac.Parser]" class="anchorToMember"></a><a id="followedByParser:FollowedBy[In,Out,Parser]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#followedByParser:io.dylemma.spac.Parser.FollowedBy[In,A,io.dylemma.spac.Parser]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">followedByParser</span><span class="result">: <a href="Parser$$FollowedBy.html" name="io.dylemma.spac.Parser.FollowedBy" id="io.dylemma.spac.Parser.FollowedBy" class="extype">FollowedBy</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>, <a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>]</span></span><p class="shortcomment cmt">Alias for <code>followedBy</code>, for use when Cat's <code>ApplyOps</code> gets in the way with its own useless <code>followedBy</code> method.</p><div class="fullcomment"><div class="comment cmt"><p>Alias for <code>followedBy</code>, for use when Cat's <code>ApplyOps</code> gets in the way with its own useless <code>followedBy</code> method.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>] to<a href="Parser$$ParserFollowedByOps.html" name="io.dylemma.spac.Parser.ParserFollowedByOps" id="io.dylemma.spac.Parser.ParserFollowedByOps" class="extype">ParserFollowedByOps</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>] performed by method ParserFollowedByOps in <a href="Parser$.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">io.dylemma.spac.Parser</a>.</dd><dt>Definition Classes</dt><dd><a href="Parser$$ParserFollowedByOps.html" name="io.dylemma.spac.Parser.ParserFollowedByOps" id="io.dylemma.spac.Parser.ParserFollowedByOps" class="extype">ParserFollowedByOps</a></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser.ParserFollowedByOps#followedByStream" group="combinators" fullComment="yes" data-isabs="false" visbl="pub"><a id="followedByStream:io.dylemma.spac.Parser.FollowedBy[In,A,io.dylemma.spac.Transformer]" class="anchorToMember"></a><a id="followedByStream:FollowedBy[In,Out,Transformer]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#followedByStream:io.dylemma.spac.Parser.FollowedBy[In,A,io.dylemma.spac.Transformer]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">followedByStream</span><span class="result">: <a href="Parser$$FollowedBy.html" name="io.dylemma.spac.Parser.FollowedBy" id="io.dylemma.spac.Parser.FollowedBy" class="extype">FollowedBy</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>, <a href="Transformer.html" name="io.dylemma.spac.Transformer" id="io.dylemma.spac.Transformer" class="extype">Transformer</a>]</span></span><p class="shortcomment cmt">Intermediate object creating a transformer that depends on this parser.</p><div class="fullcomment"><div class="comment cmt"><p>Intermediate object creating a transformer that depends on this parser.
Particularly useful in cases where one or more specific "info" elements precede
a stream of other elements which require that "info" to be parsed.</p><p>Examples:</p><pre><span class="kw">val</span> p1: Parser[In, A] = <span class="cmt">/* ... */</span>
<span class="kw">def</span> getP2Stream(p1Result: A): Transformer[In, B] = <span class="cmt">/* ... */</span>
<span class="kw">val</span> combined: Transformer[In, B] = p1.andThenStream(getP2Stream)

<span class="cmt">// alternative `flatMap` syntax</span>
<span class="kw">val</span> combined: Transformer[In, B] = <span class="kw">for</span> {
  p1Result <span class="kw">&lt;-</span> p1.andThenStream
  p2Result <span class="kw">&lt;-</span> getP2Stream(p1Result)
} <span class="kw">yield</span> p2Result</pre><p>See <code>followedBy</code> for a general explanation of how the combination works.</p><p>See also, <code>interruptedBy</code>, which is useful when a <code>transformer.parseFirstOption</code>
must be <code>followedBy</code> some other transformer.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>] to<a href="Parser$$ParserFollowedByOps.html" name="io.dylemma.spac.Parser.ParserFollowedByOps" id="io.dylemma.spac.Parser.ParserFollowedByOps" class="extype">ParserFollowedByOps</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>] performed by method ParserFollowedByOps in <a href="Parser$.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">io.dylemma.spac.Parser</a>.</dd><dt>Definition Classes</dt><dd><a href="Parser$$ParserFollowedByOps.html" name="io.dylemma.spac.Parser.ParserFollowedByOps" id="io.dylemma.spac.Parser.ParserFollowedByOps" class="extype">ParserFollowedByOps</a></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#getClass" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="getClass():Class[_]" class="anchorToMember"></a><a id="getClass():Class[_&lt;:AnyRef]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#getClass():Class[_]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getClass</span><span class="params">()</span><span class="result">: <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#java.lang.Class" name="java.lang.Class" id="java.lang.Class" class="extype">Class</a>[_ &lt;: <span name="scala.AnyRef" class="extype">AnyRef</span>]</span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#hashCode" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="hashCode():Int" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#hashCode():Int" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">hashCode</span><span class="params">()</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser#interruptedBy" group="combinators" fullComment="yes" data-isabs="false" visbl="pub"><a id="interruptedBy[I2&lt;:In](interrupter:io.dylemma.spac.Parser[I2,Any]):io.dylemma.spac.Parser[I2,Out]" class="anchorToMember"></a><a id="interruptedBy[I2&lt;:In](Parser[I2,Any]):Parser[I2,Out]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#interruptedBy[I2&lt;:In](interrupter:io.dylemma.spac.Parser[I2,Any]):io.dylemma.spac.Parser[I2,Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">interruptedBy</span><span class="tparams">[<span name="I2">I2 &lt;: <span name="io.dylemma.spac.Parser.In" class="extype">In</span></span>]</span><span class="params">(<span name="interrupter">interrupter: <a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.interruptedBy.I2" class="extype">I2</span>, <span name="scala.Any" class="extype">Any</span>]</span>)</span><span class="result">: <a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.interruptedBy.I2" class="extype">I2</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>]</span></span><p class="shortcomment cmt">Create a copy of this parser that will treat a result from the <code>interrupter</code> as an early EOF.</p><div class="fullcomment"><div class="comment cmt"><p>Create a copy of this parser that will treat a result from the <code>interrupter</code> as an early EOF.
This is especially useful for creating <code>followedBy</code> chains involving optional elements.</p><p>Normally, a parser for an optional item in some context will not finish until that context ends,
or until the item is encountered. So if the item is not present, <code>followedBy</code> logic won't work
since the <code>followUp</code> parser/transformer will not see any events.</p><p>To make sure the leading parser can "fail fast", you can "interrupt" it, typically by creating
a parser that immediately returns a result upon entering a particular context, i.e. the context
in which the "following" parser will start. <code>Parser#beforeContext</code> provides a convenience for
doing so.</p><p>Note that if the <code>interrupter</code> throws an exception, that exception will not be caught.
If your interrupter might throw, pass <code>interrupter.wrapSafe</code> instead to swallow the exception.
</p></div><dl class="paramcmts block"><dt class="tparam">I2</dt><dd class="cmt"><p>Subtype of <code>In</code>, or just <code>In</code> (to satisfy contravariance of Parser's <code>In</code> type)</p></dd><dt class="param">interrupter</dt><dd class="cmt"><p>A parser which will be run in parallel with this parser, and whose result will
                   be treated as an early EOF for this parser, forcing an early call to <code>finish()</code>.</p></dd><dt>returns</dt><dd class="cmt"><p>A parser which will perform an early <code>finish()</code> call when the <code>interrupter</code> produces a result.</p></dd></dl></div></li><li class="indented0 " name="scala.Any#isInstanceOf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="isInstanceOf[T0]:Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#isInstanceOf[T0]:Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser#map" group="combinators" fullComment="yes" data-isabs="false" visbl="pub"><a id="map[Out2](f:Out=&gt;Out2):io.dylemma.spac.Parser[In,Out2]" class="anchorToMember"></a><a id="map[Out2]((Out)=&gt;Out2):Parser[In,Out2]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#map[Out2](f:Out=&gt;Out2):io.dylemma.spac.Parser[In,Out2]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">map</span><span class="tparams">[<span name="Out2">Out2</span>]</span><span class="params">(<span name="f">f: (<span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>) =&gt; <span name="io.dylemma.spac.Parser.map.Out2" class="extype">Out2</span></span>)</span><span class="result">: <a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.map.Out2" class="extype">Out2</span>]</span></span><p class="shortcomment cmt">Create a copy of this Parser whose result is transformed by the given function <code>f</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Create a copy of this Parser whose result is transformed by the given function <code>f</code>.
</p></div><dl class="paramcmts block"><dt class="tparam">Out2</dt><dd class="cmt"><p>The new parser's result type</p></dd><dt class="param">f</dt><dd class="cmt"><p>Result transformation function</p></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#ne" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ne(x$1:AnyRef):Boolean" class="anchorToMember"></a><a id="ne(AnyRef):Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#ne(x$1:AnyRef):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">ne</span><span class="params">(<span name="arg0">arg0: <span name="scala.AnyRef" class="extype">AnyRef</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#notify" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="notify():Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#notify():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">notify</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#notifyAll" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="notifyAll():Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#notifyAll():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser#orElse" group="combinators" fullComment="yes" data-isabs="false" visbl="pub"><a id="orElse[In2&lt;:In,Out2&gt;:Out](fallback:io.dylemma.spac.Parser[In2,Out2]):io.dylemma.spac.Parser[In2,Out2]" class="anchorToMember"></a><a id="orElse[In2&lt;:In,Out2&gt;:Out](Parser[In2,Out2]):Parser[In2,Out2]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#orElse[In2&lt;:In,Out2&gt;:Out](fallback:io.dylemma.spac.Parser[In2,Out2]):io.dylemma.spac.Parser[In2,Out2]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">orElse</span><span class="tparams">[<span name="In2">In2 &lt;: <span name="io.dylemma.spac.Parser.In" class="extype">In</span></span>, <span name="Out2">Out2 &gt;: <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span></span>]</span><span class="params">(<span name="fallback">fallback: <a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.orElse.In2" class="extype">In2</span>, <span name="io.dylemma.spac.Parser.orElse.Out2" class="extype">Out2</span>]</span>)</span><span class="result">: <a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.orElse.In2" class="extype">In2</span>, <span name="io.dylemma.spac.Parser.orElse.Out2" class="extype">Out2</span>]</span></span><p class="shortcomment cmt">Combine this parser with the <code>fallback</code> such that failures from the underlying parsers will be ignored as long as at least one succeeds.</p><div class="fullcomment"><div class="comment cmt"><p>Combine this parser with the <code>fallback</code> such that failures from the underlying parsers will be ignored as long as at least one succeeds.
The result will be the result of whichever underlying parser succeeds first.
If all of the underlying parsers fail, a <code>SpacException.FallbackChainFailure</code> will be thrown by the returned parser's handler.
</p></div><dl class="paramcmts block"><dt class="tparam">In2</dt><dd class="cmt"><p>Subtype of <code>In</code>, or just <code>In</code> (to satisfy Parser's contravariance on the <code>In</code> type)</p></dd><dt class="tparam">Out2</dt><dd class="cmt"><p>Supertype of <code>Out</code>, or just <code>Out</code> (to satisfy Parser's covariance on the <code>Out</code> type)</p></dd><dt class="param">fallback</dt><dd class="cmt"><p>another parser of the same(ish) type as this one</p></dd><dt>returns</dt><dd class="cmt"><p>A new parser that will succeed if either this parser or the fallback succeed</p></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser#parse" group="consumers" fullComment="yes" data-isabs="false" visbl="pub"><a id="parse(source:io.dylemma.spac.Source[In])(implicitpos:io.dylemma.spac.CallerPos):Out" class="anchorToMember"></a><a id="parse(Source[In])(CallerPos):Out" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#parse(source:io.dylemma.spac.Source[In])(implicitpos:io.dylemma.spac.CallerPos):Out" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">parse</span><span class="params">(<span name="source">source: <a href="Source.html" name="io.dylemma.spac.Source" id="io.dylemma.spac.Source" class="extype">Source</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="pos">pos: <a href="CallerPos.html" name="io.dylemma.spac.CallerPos" id="io.dylemma.spac.CallerPos" class="extype">CallerPos</a></span>)</span><span class="result">: <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span></span></span><p class="shortcomment cmt">Consume the given <code>source</code> to produce an output or possibly throw a <code>SpacException</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Consume the given <code>source</code> to produce an output or possibly throw a <code>SpacException</code>.</p><p>The <code>Source[A]</code> type is like <code>Iterable[A]</code> but uses the "lender" pattern to acquire the iterator
and close any resources associated with the iterator after the iterator is consumed.</p><p>XML and JSON-specific <code>Source</code> constructors are provided by the "parser backend" libraries
i.e. <code>xml-spac-javax</code> and <code>json-spac-jackson</code>.
</p></div><dl class="paramcmts block"><dt class="param">source</dt><dd class="cmt"><p>An object that can provide a series of <code>In</code> values, e.g. <code>XmlEvent</code> or <code>JsonEvent</code></p></dd><dt class="param">pos</dt><dd class="cmt"><p>Captures the caller filename and line number, used to fill in the 'spac trace' if the parser throws an exception</p></dd><dt>returns</dt><dd class="cmt"><p>The parser result based on the given <code>source</code></p></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser#parse" group="consumers" fullComment="yes" data-isabs="false" visbl="pub"><a id="parse(inputs:Iterator[In])(implicitpos:io.dylemma.spac.CallerPos):Out" class="anchorToMember"></a><a id="parse(Iterator[In])(CallerPos):Out" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#parse(inputs:Iterator[In])(implicitpos:io.dylemma.spac.CallerPos):Out" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">parse</span><span class="params">(<span name="inputs">inputs: <span name="scala.Iterator" class="extype">Iterator</span>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="pos">pos: <a href="CallerPos.html" name="io.dylemma.spac.CallerPos" id="io.dylemma.spac.CallerPos" class="extype">CallerPos</a></span>)</span><span class="result">: <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span></span></span><p class="shortcomment cmt">Consume the given <code>inputs</code> iterator to produce an output or possibly throw a <code>SpacException</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Consume the given <code>inputs</code> iterator to produce an output or possibly throw a <code>SpacException</code>.</p><p>After calling this method, the <code>inputs</code> should be discarded, since consuming an Iterator is a destructive operation.
</p></div><dl class="paramcmts block"><dt class="param">inputs</dt><dd class="cmt"><p>A series of <code>In</code> values, e.g. <code>XmlEvent</code> or <code>JsonEvent</code></p></dd><dt class="param">pos</dt><dd class="cmt"><p>Captures the caller filename and line number, used to fill in the 'spac trace' if the parser throws an exception</p></dd><dt>returns</dt><dd class="cmt"><p>The parser result based on the given <code>inputs</code></p></dd></dl><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">scala.this.throws.&lt;init&gt;$default$1[io.dylemma.spac.SpacException[_]]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser#rethrow" group="combinators" fullComment="yes" data-isabs="false" visbl="pub"><a id="rethrow[T](implicitev:Out&lt;:&lt;Either[Throwable,T]):io.dylemma.spac.Parser[In,T]" class="anchorToMember"></a><a id="rethrow[T](&lt;:&lt;[Out,Either[Throwable,T]]):Parser[In,T]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#rethrow[T](implicitev:Out&lt;:&lt;Either[Throwable,T]):io.dylemma.spac.Parser[In,T]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">rethrow</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="ev">ev: <span name="scala.&lt;:&lt;" class="extype">&lt;:&lt;</span>[<span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>, <span name="scala.Either" class="extype">Either</span>[<span name="scala.Throwable" class="extype">Throwable</span>, <span name="io.dylemma.spac.Parser.rethrow.T" class="extype">T</span>]]</span>)</span><span class="result">: <a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.rethrow.T" class="extype">T</span>]</span></span><p class="shortcomment cmt">Like <code>unwrapSafe</code>, but rethrows exceptions from <code>Left</code> or returns results from <code>Right</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Like <code>unwrapSafe</code>, but rethrows exceptions from <code>Left</code> or returns results from <code>Right</code>.
This operation is the opposite of <code>attempt</code>.
</p></div></div></li><li class="indented0 " name="io.dylemma.spac.Parser#start" group="consumers" fullComment="yes" data-isabs="false" visbl="pub"><a id="start(methodName:String)(implicitpos:io.dylemma.spac.CallerPos):io.dylemma.spac.Parser.Handler[In,Out]" class="anchorToMember"></a><a id="start(String)(CallerPos):Handler[In,Out]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#start(methodName:String)(implicitpos:io.dylemma.spac.CallerPos):io.dylemma.spac.Parser.Handler[In,Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">start</span><span class="params">(<span name="methodName">methodName: <span name="scala.Predef.String" class="extype">String</span> = <span class="symbol">"start"</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="pos">pos: <a href="CallerPos.html" name="io.dylemma.spac.CallerPos" id="io.dylemma.spac.CallerPos" class="extype">CallerPos</a></span>)</span><span class="result">: <a href="Parser$$Handler.html" name="io.dylemma.spac.Parser.Handler" id="io.dylemma.spac.Parser.Handler" class="extype">Handler</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>]</span></span><p class="shortcomment cmt">Low-level consumer method: creates a new handler and binds the caller position for its SpacTraceElement.</p><div class="fullcomment"><div class="comment cmt"><p>Low-level consumer method: creates a new handler and binds the caller position for its SpacTraceElement.</p><p>Used internally by the <code>parse</code> methods.
Start with this method if you have some sequence-like datatype that doesn't provide an <code>Iterator</code>.</p><p>This is just a convenience for <code>newHandler.asTopLevelhandler</code> which helps construct a useful SpacTraceElement.
</p></div><dl class="paramcmts block"><dt class="param">methodName</dt><dd class="cmt"><p>The method name used to construct the SpacTraceElement for the handler. Defaults to <code>"start"</code></p></dd><dt class="param">pos</dt><dd class="cmt"><p>Captures the caller filename and line number, used to fill in the 'spac trace' if the parser throws an exception</p></dd><dt>returns</dt><dd class="cmt"><p>A parser handler that can be used to eventually produce a result by calling its <code>step</code> and/or <code>finish</code> methods</p></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#synchronized" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="synchronized[T0](x$1:=&gt;T0):T0" class="anchorToMember"></a><a id="synchronized[T0](=&gt;T0):T0" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#synchronized[T0](x$1:=&gt;T0):T0" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: =&gt; <span name="java.lang.AnyRef.synchronized.T0" class="extype">T0</span></span>)</span><span class="result">: <span name="java.lang.AnyRef.synchronized.T0" class="extype">T0</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#toString" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="toString():String" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#toString():String" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">toString</span><span class="params">()</span><span class="result">: <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#java.lang.String" name="java.lang.String" id="java.lang.String" class="extype">String</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser#unwrapSafe" group="combinators" fullComment="yes" data-isabs="false" visbl="pub"><a id="unwrapSafe[T](implicitev:Out&lt;:&lt;scala.util.Try[T]):io.dylemma.spac.Parser[In,T]" class="anchorToMember"></a><a id="unwrapSafe[T](&lt;:&lt;[Out,Try[T]]):Parser[In,T]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#unwrapSafe[T](implicitev:Out&lt;:&lt;scala.util.Try[T]):io.dylemma.spac.Parser[In,T]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">unwrapSafe</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="ev">ev: <span name="scala.&lt;:&lt;" class="extype">&lt;:&lt;</span>[<span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>, <span name="scala.util.Try" class="extype">Try</span>[<span name="io.dylemma.spac.Parser.unwrapSafe.T" class="extype">T</span>]]</span>)</span><span class="result">: <a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.unwrapSafe.T" class="extype">T</span>]</span></span><p class="shortcomment cmt">Creates a copy of this parser which unwraps the resulting <code>Try</code>, throwing an exception if the result was a <code>Failure</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a copy of this parser which unwraps the resulting <code>Try</code>, throwing an exception if the result was a <code>Failure</code>.
This operation is the opposite of <code>wrapSafe</code>.
</p></div></div></li><li class="indented0 " name="io.dylemma.spac.Parser#upcast" group="combinators" fullComment="yes" data-isabs="false" visbl="pub"><a id="upcast[Out2](implicitev:Out&lt;:&lt;Out2):io.dylemma.spac.Parser[In,Out2]" class="anchorToMember"></a><a id="upcast[Out2](&lt;:&lt;[Out,Out2]):Parser[In,Out2]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#upcast[Out2](implicitev:Out&lt;:&lt;Out2):io.dylemma.spac.Parser[In,Out2]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">upcast</span><span class="tparams">[<span name="Out2">Out2</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="ev">ev: <span name="scala.&lt;:&lt;" class="extype">&lt;:&lt;</span>[<span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>, <span name="io.dylemma.spac.Parser.upcast.Out2" class="extype">Out2</span>]</span>)</span><span class="result">: <a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.upcast.Out2" class="extype">Out2</span>]</span></span><p class="shortcomment cmt">Returns this parser, with the output type widened to <code>Out2</code>, which is some supertype of <code>Out</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Returns this parser, with the output type widened to <code>Out2</code>, which is some supertype of <code>Out</code>.
Uses <code>asInstanceOf</code> rather than creating a new parser.
</p></div></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait():Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#wait():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait(x$1:Long,x$2:Int):Unit" class="anchorToMember"></a><a id="wait(Long,Int):Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#wait(x$1:Long,x$2:Int):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>, <span name="arg1">arg1: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait(x$1:Long):Unit" class="anchorToMember"></a><a id="wait(Long):Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#wait(x$1:Long):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> <span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser#withName" group="combinators" fullComment="yes" data-isabs="false" visbl="pub"><a id="withName(name:String):io.dylemma.spac.Parser[In,Out]" class="anchorToMember"></a><a id="withName(String):Parser[In,Out]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#withName(name:String):io.dylemma.spac.Parser[In,Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">withName</span><span class="params">(<span name="name">name: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>]</span></span><p class="shortcomment cmt">Creates a copy of this parser, but with a different <code>toString</code>
</p><div class="fullcomment"><div class="comment cmt"><p>Creates a copy of this parser, but with a different <code>toString</code>
</p></div><dl class="paramcmts block"><dt class="param">name</dt><dd class="cmt"><p>The new "name" (i.e. <code>toString</code>) for this parser</p></dd><dt>returns</dt><dd class="cmt"><p>A copy of this parser whose <code>toString</code> returns the given <code>name</code></p></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser#wrapSafe" group="combinators" fullComment="yes" data-isabs="false" visbl="pub"><a id="wrapSafe:io.dylemma.spac.Parser[In,scala.util.Try[Out]]" class="anchorToMember"></a><a id="wrapSafe:Parser[In,Try[Out]]" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#wrapSafe:io.dylemma.spac.Parser[In,scala.util.Try[Out]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wrapSafe</span><span class="result">: <a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="scala.util.Try" class="extype">Try</span>[<span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>]]</span></span><p class="shortcomment cmt">Create a copy of this Parser whose handler will catch NonFatal exceptions thrown by the underlying logic.</p><div class="fullcomment"><div class="comment cmt"><p>Create a copy of this Parser whose handler will catch NonFatal exceptions thrown by the underlying logic.
Caught exceptions will be yielded as a <code>Failure</code> output. Normal results will be wrapped in <code>Success</code>.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>A copy of this parser that will return a <code>Failure</code> instead of throwing exceptions</p></dd></dl></div></li></ol></div><div class="values members"><h3>Deprecated Value Members</h3><ol><li class="indented0 " name="scala.Predef.StringFormat#formatted" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="formatted(fmtstr:String):String" class="anchorToMember"></a><a id="formatted(String):String" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#formatted(fmtstr:String):String" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit deprecated" title="Deprecated: (Since version 2.12.16) Use formatString.format(value) instead of value.formatted(formatString),
or use the f&quot;&quot; string interpolator. In Java 15 and later, formatted resolves to the new method in String which has reversed parameters.">formatted</span><span class="params">(<span name="fmtstr">fmtstr: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <span name="scala.Predef.String" class="extype">String</span></span></span><div class="fullcomment"><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>] to<span name="scala.Predef.StringFormat" class="extype">StringFormat</span>[<a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>]] performed by method StringFormat in scala.Predef.</dd><dt>Definition Classes</dt><dd>StringFormat</dd><dt>Annotations</dt><dd><span class="name">@deprecated</span> <span class="name">@inline</span><span class="args">()</span> </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 2.12.16)</i> Use <code>formatString.format(value)</code> instead of <code>value.formatted(formatString)</code>,
or use the <code>f""</code> string interpolator. In Java 15 and later, <code>formatted</code> resolves to the new method in String which has reversed parameters.</p></dd></dl></div></li><li class="indented0 " name="scala.Predef.ArrowAssoc#→" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="→[B](y:B):(A,B)" class="anchorToMember"></a><a id="→[B](B):(Parser[In,Out],B)" class="anchorToMember"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser.html#→[B](y:B):(A,B)" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit deprecated" title="gt4s: $u2192. Deprecated: (Since version 2.13.0) Use -&gt; instead. If you still wish to display it as one character, consider using a font with programming ligatures such as Fira Code.">→</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="y">y: <span name="scala.Predef.ArrowAssoc.→.B" class="extype">B</span></span>)</span><span class="result">: (<a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>], <span name="scala.Predef.ArrowAssoc.→.B" class="extype">B</span>)</span></span><div class="fullcomment"><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>] to<span name="scala.Predef.ArrowAssoc" class="extype">ArrowAssoc</span>[<a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>]] performed by method ArrowAssoc in scala.Predef.</dd><dt>Definition Classes</dt><dd>ArrowAssoc</dd><dt>Annotations</dt><dd><span class="name">@deprecated</span> </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 2.13.0)</i> Use <code>-&gt;</code> instead. If you still wish to display it as one character, consider using a font with programming ligatures such as Fira Code.</p></dd></dl></div></li></ol></div></div><div id="inheritedMembers"><div name="scala.AnyRef" class="parent"><h3>Inherited from <span name="scala.AnyRef" class="extype">AnyRef</span></h3></div><div name="scala.Any" class="parent"><h3>Inherited from <span name="scala.Any" class="extype">Any</span></h3></div><div name="io.dylemma.spac.Parser.ParserFollowedByOps" class="conversion"><h3>Inherited by implicit conversion ParserFollowedByOps from<a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>] to <a href="Parser$$ParserFollowedByOps.html" name="io.dylemma.spac.Parser.ParserFollowedByOps" id="io.dylemma.spac.Parser.ParserFollowedByOps" class="extype">ParserFollowedByOps</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>]</h3></div><div name="scala.Predef.any2stringadd" class="conversion"><h3>Inherited by implicit conversion any2stringadd from<a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>] to <span name="scala.Predef.any2stringadd" class="extype">any2stringadd</span>[<a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>]]</h3></div><div name="scala.Predef.StringFormat" class="conversion"><h3>Inherited by implicit conversion StringFormat from<a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>] to <span name="scala.Predef.StringFormat" class="extype">StringFormat</span>[<a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>]]</h3></div><div name="scala.Predef.Ensuring" class="conversion"><h3>Inherited by implicit conversion Ensuring from<a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>] to <span name="scala.Predef.Ensuring" class="extype">Ensuring</span>[<a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>]]</h3></div><div name="scala.Predef.ArrowAssoc" class="conversion"><h3>Inherited by implicit conversion ArrowAssoc from<a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>] to <span name="scala.Predef.ArrowAssoc" class="extype">ArrowAssoc</span>[<a href="" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Out" class="extype">Out</span>]]</h3></div></div><div id="groupedMembers"><div name="abstract" class="group"><h3>Abstract Members</h3></div><div name="consumers" class="group"><h3>Consumer Methods</h3></div><div name="combinators" class="group"><h3>Transformation / Combinator Methods</h3></div><div name="Ungrouped" class="group"><h3>Ungrouped</h3></div></div></div><div id="tooltip"></div><div id="footer"></div></body></div></div></div></body></html>

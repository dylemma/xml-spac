<!DOCTYPE html ><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/><title></title><meta content="" name="description"/><meta content="" name="keywords"/><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><link href="../../../lib/index.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../../lib/template.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css"/><script type="text/javascript" src="../../../lib/jquery.js"></script><script type="text/javascript" src="../../../lib/index.js"></script><script type="text/javascript" src="../../../index.js"></script><script type="text/javascript" src="../../../lib/scheduler.js"></script><script type="text/javascript" src="../../../lib/template.js"></script><script type="text/javascript" src="../../../lib/tools.tooltip.js"></script><script type="text/javascript">/* this variable can be used by the JS to determine the path to the root document */
var toRoot = '../../../';</script></head><body><div id="search"><span id="doc-title"><span id="doc-version"></span></span> <span class="close-results"><span class="left">&lt;</span> Back</span><div id="textfilter"><span class="input"><input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/"/><i class="clear material-icons"></i><i id="search-icon" class="material-icons"></i></span></div></div><div id="search-results"><div id="search-progress"><div id="progress-fill"></div></div><div id="results-content"><div id="entity-results"></div><div id="member-results"></div></div></div><div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;"><div id="content-container" style="-webkit-overflow-scrolling: touch;"><div id="subpackage-spacer"><div id="packages"><h1>Packages</h1><ul><li class="indented0 " name="_root_.root" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="_root_"></a><a id="root:_root_"></a> <span class="permalink"><a href="index.html#_root_" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../../index.html" title=""><span class="name">root</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented1 " name="_root_.io" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="io"></a><a id="io:io"></a> <span class="permalink"><a href="index.html#io" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../index.html" title=""><span class="name">io</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented2 " name="io.dylemma" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="dylemma"></a><a id="dylemma:dylemma"></a> <span class="permalink"><a href="../io/index.html#dylemma" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../index.html" title=""><span class="name">dylemma</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../index.html" name="io" id="io" class="extype">io</a></dd></dl></div></li><li class="indented3 " name="io.dylemma.spac" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="spac"></a><a id="spac:spac"></a> <span class="permalink"><a href="../../io/dylemma/index.html#spac" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="index.html" title="SPaC (short for &quot;Streaming Parser Combinators&quot;) is a library for building stream consumers in a declarative style, specialized for tree-like data types like XML and JSON."><span class="name">spac</span></a></span><p class="shortcomment cmt">SPaC (short for "<strong>S</strong>treaming <strong>Pa</strong>rser <strong>C</strong>ombinators")
is a library for building stream consumers in a declarative style, specialized for tree-like data
types like XML and JSON.</p><div class="fullcomment"><div class="comment cmt"><p>SPaC (short for "<strong>S</strong>treaming <strong>Pa</strong>rser <strong>C</strong>ombinators")
is a library for building stream consumers in a declarative style, specialized for tree-like data
types like XML and JSON.</p><p>Many utilities for handling XML and JSON data involve parsing the entire "document" to some DOM model,
then inspecting and transforming that model to extract information.
The downside to these utilities is that when the document is very large, the DOM may not fit in memory.
The workaround for this type of problem is to treat the document as a stream of "events",
e.g. "StartElement" and "EndElement" for XML, or "StartObject" and "EndObject" for JSON.
The downside to this workaround is that writing code to handle these streams can be complicated and
error-prone, especially when the DOM is complicated.</p><p>SPaC's goal is to drastically simplify the process of creating code to handle these streams.</p><p>This package contains the "core" SPaC traits; <code>Parser</code>, <code>Transformer</code>, <code>Splitter</code>, and <code>ContextMatcher</code>.</p><p>See the <code>xml</code> and <code>json</code> subpackages (provided by the <code>xml-spac</code> and <code>json-spac</code> libraries respectively)
for specific utilities related to handling XML and JSON event streams.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="io.dylemma" id="io.dylemma" class="extype">dylemma</a></dd></dl></div></li><li class="indented4 " name="io.dylemma.spac.Parser" group="primary" fullComment="yes" data-isabs="false" visbl="pub"><a id="Parser"></a><a id="Parser:Parser"></a> <span class="permalink"><a href="../../../io/dylemma/spac/index.html#Parser" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="Parser$.html" title=""><span class="name">Parser</span></a></span><p class="shortcomment cmt"></p><div class="fullcomment"><div class="comment cmt"></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="index.html" name="io.dylemma.spac" id="io.dylemma.spac" class="extype">spac</a></dd></dl></div></li><li class="current-entities indented4"><span class="separator"></span> <a href="Parser$$FollowedBy.html" title="An intermediate object for creating sequence-based combination methods for a Parser or Consumer." class="trait"></a><a href="Parser$$FollowedBy.html" title="An intermediate object for creating sequence-based combination methods for a Parser or Consumer.">FollowedBy</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="Parser$$Handler.html" title="An internally-mutable representation of a Parser, which reacts to inputs from a data stream and eventually produces a result." class="trait"></a><a href="Parser$$Handler.html" title="An internally-mutable representation of a Parser, which reacts to inputs from a data stream and eventually produces a result.">Handler</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="Parser$$ParserFlatten.html" title="" class="class"></a><a href="Parser$$ParserFlatten.html" title="">ParserFlatten</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="Parser$$ParserFollowedByOps.html" title="Adds followedBy and followedByStream to Parser (they aren't defined in the Parser trait due to the In type needing to be invariant here)" class="class"></a><a href="Parser$$ParserFollowedByOps.html" title="Adds followedBy and followedByStream to Parser (they aren't defined in the Parser trait due to the In type needing to be invariant here)">ParserFollowedByOps</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="" title="Specialization for Parsers which require no mutable state." class="trait"></a><a href="" title="Specialization for Parsers which require no mutable state.">Stateless</a></li></ul></div></div><div id="content"><body class="trait type"><div id="definition"><div class="big-circle trait">t</div><p id="owner"><a href="../../index.html" name="io" id="io" class="extype">io</a>.<a href="../index.html" name="io.dylemma" id="io.dylemma" class="extype">dylemma</a>.<a href="index.html" name="io.dylemma.spac" id="io.dylemma.spac" class="extype">spac</a>.<a href="Parser$.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a></p><h1>Stateless<span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html" title="Permalink"><i class="material-icons"></i></a></span></h1><h3><span class="morelinks"></span></h3></div><h4 id="signature" class="signature"><span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><span class="name">Stateless</span><span class="tparams">[<span name="In">-In</span>, <span name="Out">+Out</span>]</span><span class="result"> extends <a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>] with <a href="Parser$$Handler.html" name="io.dylemma.spac.Parser.Handler" id="io.dylemma.spac.Parser.Handler" class="extype">Handler</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>]</span></span></h4><div id="comment" class="fullcommenttop"><div class="comment cmt"><p>Specialization for Parsers which require no mutable state.
A "stateless" parser acts as its own handler.
</p></div><dl class="attributes block"><dt>Source</dt><dd><a href="https://github.com/dylemma/xml-spac/tree/0.11.0/core/src/main/scala/io/dylemma/spac/Parser.scala" target="_blank">Parser.scala</a></dd></dl><div class="toggleContainer"><div class="toggle block"><span>Linear Supertypes</span><div class="superTypes hiddenContent"><a href="Parser$$Handler.html" name="io.dylemma.spac.Parser.Handler" id="io.dylemma.spac.Parser.Handler" class="extype">Handler</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>], <a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>], <span name="scala.AnyRef" class="extype">AnyRef</span>, <span name="scala.Any" class="extype">Any</span></div></div></div></div><div id="mbrsel"><div class="toggle"></div><div id="memberfilter"><i class="material-icons arrow"></i><span class="input"><input placeholder="Filter all members" id="mbrsel-input" type="text" accesskey="/"/></span><i class="clear material-icons"></i></div><div id="filterby"><div id="order"><span class="filtertype">Ordering</span><ol><li class="group out"><span>Grouped</span></li><li class="alpha in"><span>Alphabetic</span></li><li class="inherit out"><span>By Inheritance</span></li></ol></div><div class="ancestors"><span class="filtertype">Inherited<br/></span><ol id="linearization"><li class="in" name="io.dylemma.spac.Parser.Stateless"><span>Stateless</span></li><li class="in" name="io.dylemma.spac.Parser.Handler"><span>Handler</span></li><li class="in" name="io.dylemma.spac.Parser"><span>Parser</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li></ol></div><div class="ancestors"><span class="filtertype">Implicitly<br/></span><ol id="implicits"><li class="in" name="io.dylemma.spac.Parser.ParserFollowedByOps" data-hidden="false"><span>by ParserFollowedByOps</span></li><li class="in" name="io.dylemma.spac.Parser.ParserFollowedByOps" data-hidden="false"><span>by ParserFollowedByOps</span></li><li class="in" name="scala.Predef.any2stringadd" data-hidden="true"><span>by any2stringadd</span></li><li class="in" name="scala.Predef.StringFormat" data-hidden="true"><span>by StringFormat</span></li><li class="in" name="scala.Predef.Ensuring" data-hidden="true"><span>by Ensuring</span></li><li class="in" name="scala.Predef.ArrowAssoc" data-hidden="true"><span>by ArrowAssoc</span></li></ol></div><div class="ancestors"><span class="filtertype"></span><ol><li class="hideall out"><span>Hide All</span></li><li class="showall in"><span>Show All</span></li></ol></div><div id="visbl"><span class="filtertype">Visibility</span><ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol></div></div></div><div id="template"><div id="allMembers"><div class="values members"><h3>Abstract Value Members</h3><ol><li class="indented0 " name="io.dylemma.spac.Parser.Handler#finish" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="finish():Out"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#finish():Out" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">finish</span><span class="params">()</span><span class="result">: <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span></span></span><p class="shortcomment cmt">Signal the end of the data stream to this handler, forcing it to generate a result.</p><div class="fullcomment"><div class="comment cmt"><p>Signal the end of the data stream to this handler, forcing it to generate a result.
Handlers may throw exceptions in response to this, such as a handler which wants the first event from an empty stream.</p><p>Further calls to <code>step</code> or <code>finish</code> after the first call to <code>finish</code> will result in undefined behavior.
The general assumption is that a handler should be discarded after its <code>finish</code> method is called.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the final result of this parser</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Parser$$Handler.html" name="io.dylemma.spac.Parser.Handler" id="io.dylemma.spac.Parser.Handler" class="extype">Handler</a></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser.Handler#step" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="step(in:In):Either[Out,io.dylemma.spac.Parser.Handler[In,Out]]"></a><a id="step(In):Either[Out,Handler[In,Out]]"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#step(in:In):Either[Out,io.dylemma.spac.Parser.Handler[In,Out]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">step</span><span class="params">(<span name="in">in: <span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span></span>)</span><span class="result">: <span name="scala.Either" class="extype">Either</span>[<span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>, <a href="Parser$$Handler.html" name="io.dylemma.spac.Parser.Handler" id="io.dylemma.spac.Parser.Handler" class="extype">Handler</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>]]</span></span><p class="shortcomment cmt">Advance the state of this handler by accepting a single input of type <code>In</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Advance the state of this handler by accepting a single input of type <code>In</code>.
If doing so would cause this parser to complete, return a <code>Left</code> containing the output.
Otherwise, return a <code>Right</code> containing the next parser state.</p><p>Handlers are assumed to be internally-mutable, so it is acceptable to simply
update some internal state and then return <code>Right(this)</code>, although in some
cases it will be desirable to return a separate handler entirely.
</p></div><dl class="paramcmts block"><dt class="param">in</dt><dd class="cmt"><p>A single input event from a data stream</p></dd><dt>returns</dt><dd class="cmt"><p>If the input would finish the parser, return a <code>Left</code> containing the result.
        Otherwise, return a <code>Right</code> containing a Handler which represents the next parsing state.
        The handler in a <code>Right</code> may be this handler, or a completely separate one.</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Parser$$Handler.html" name="io.dylemma.spac.Parser.Handler" id="io.dylemma.spac.Parser.Handler" class="extype">Handler</a></dd></dl></div></li></ol></div><div class="values members"><h3>Concrete Value Members</h3><ol><li class="indented0 " name="scala.AnyRef#!=" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="!=(x$1:Any):Boolean"></a><a id="!=(Any):Boolean"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#!=(x$1:Any):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $bang$eq">!=</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef###" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="##():Int"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html###():Int" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $hash$hash">##</span><span class="params">()</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.Predef.any2stringadd#+" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="+(other:String):String"></a><a id="+(String):String"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#+(other:String):String" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit" title="gt4s: $plus">+</span><span class="params">(<span name="other">other: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <span name="scala.Predef.String" class="extype">String</span></span></span><div class="fullcomment"><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="io.dylemma.spac.Parser.Stateless" id="io.dylemma.spac.Parser.Stateless" class="extype">Stateless</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>] to<span name="scala.Predef.any2stringadd" class="extype">any2stringadd</span>[<a href="" name="io.dylemma.spac.Parser.Stateless" id="io.dylemma.spac.Parser.Stateless" class="extype">Stateless</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>]] performed by method any2stringadd in scala.Predef.</dd><dt>Definition Classes</dt><dd>any2stringadd</dd></dl></div></li><li class="indented0 " name="scala.Predef.ArrowAssoc#-&gt;" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="-&gt;[B](y:B):(A,B)"></a><a id="-&gt;[B](B):(Stateless[In,Out],B)"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#-&gt;[B](y:B):(A,B)" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit" title="gt4s: $minus$greater">-&gt;</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="y">y: <span name="scala.Predef.ArrowAssoc.-&gt;.B" class="extype">B</span></span>)</span><span class="result">: (<a href="" name="io.dylemma.spac.Parser.Stateless" id="io.dylemma.spac.Parser.Stateless" class="extype">Stateless</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>], <span name="scala.Predef.ArrowAssoc.-&gt;.B" class="extype">B</span>)</span></span><div class="fullcomment"><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="io.dylemma.spac.Parser.Stateless" id="io.dylemma.spac.Parser.Stateless" class="extype">Stateless</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>] to<span name="scala.Predef.ArrowAssoc" class="extype">ArrowAssoc</span>[<a href="" name="io.dylemma.spac.Parser.Stateless" id="io.dylemma.spac.Parser.Stateless" class="extype">Stateless</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>]] performed by method ArrowAssoc in scala.Predef.</dd><dt>Definition Classes</dt><dd>ArrowAssoc</dd><dt>Annotations</dt><dd><span class="name">@inline</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#==" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="==(x$1:Any):Boolean"></a><a id="==(Any):Boolean"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#==(x$1:Any):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $eq$eq">==</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.Any#asInstanceOf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="asInstanceOf[T0]:T0"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#asInstanceOf[T0]:T0" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span name="scala.Any.asInstanceOf.T0" class="extype">T0</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser.Handler#asTopLevelHandler" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="asTopLevelHandler(caller:io.dylemma.spac.SpacTraceElement):io.dylemma.spac.Parser.Handler[In,Out]"></a><a id="asTopLevelHandler(SpacTraceElement):Handler[In,Out]"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#asTopLevelHandler(caller:io.dylemma.spac.SpacTraceElement):io.dylemma.spac.Parser.Handler[In,Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">asTopLevelHandler</span><span class="params">(<span name="caller">caller: <a href="SpacTraceElement.html" name="io.dylemma.spac.SpacTraceElement" id="io.dylemma.spac.SpacTraceElement" class="extype">SpacTraceElement</a></span>)</span><span class="result">: <a href="Parser$$Handler.html" name="io.dylemma.spac.Parser.Handler" id="io.dylemma.spac.Parser.Handler" class="extype">Handler</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>]</span></span><p class="shortcomment cmt">Wraps this handler as a "top level" handler, which will inject a SpacTraceElement
(representing the current input or the "EOF" signal)
to any exception is thrown by this handler when calling its <code>step</code> or <code>finish</code> methods.</p><div class="fullcomment"><div class="comment cmt"><p>Wraps this handler as a "top level" handler, which will inject a SpacTraceElement
(representing the current input or the "EOF" signal)
to any exception is thrown by this handler when calling its <code>step</code> or <code>finish</code> methods.</p><p>Used internally by <code>Parser</code>'s <code>parse</code> methods.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Parser$$Handler.html" name="io.dylemma.spac.Parser.Handler" id="io.dylemma.spac.Parser.Handler" class="extype">Handler</a></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser#asTransformer" group="combinators" fullComment="yes" data-isabs="false" visbl="pub"><a id="asTransformer:io.dylemma.spac.Transformer[In,Out]"></a><a id="asTransformer:Transformer[In,Out]"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#asTransformer:io.dylemma.spac.Transformer[In,Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">asTransformer</span><span class="result">: <a href="Transformer.html" name="io.dylemma.spac.Transformer" id="io.dylemma.spac.Transformer" class="extype">Transformer</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>]</span></span><p class="shortcomment cmt">Represent this parser as a <code>Transformer</code> which emits this parser's result
</p><div class="fullcomment"><div class="comment cmt"><p>Represent this parser as a <code>Transformer</code> which emits this parser's result
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser#attempt" group="combinators" fullComment="yes" data-isabs="false" visbl="pub"><a id="attempt:io.dylemma.spac.Parser[In,Either[Throwable,Out]]"></a><a id="attempt:Parser[In,Either[Throwable,Out]]"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#attempt:io.dylemma.spac.Parser[In,Either[Throwable,Out]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">attempt</span><span class="result">: <a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="scala.Either" class="extype">Either</span>[<span name="scala.Throwable" class="extype">Throwable</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>]]</span></span><p class="shortcomment cmt">Like <code>wrapSafe</code>, but represents exceptions as <code>Left</code> and successful results as <code>Right</code>
</p><div class="fullcomment"><div class="comment cmt"><p>Like <code>wrapSafe</code>, but represents exceptions as <code>Left</code> and successful results as <code>Right</code>
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser#beforeContext" group="combinators" fullComment="yes" data-isabs="false" visbl="pub"><a id="beforeContext[I2&lt;:In,StackElem](matcher:io.dylemma.spac.ContextMatcher[StackElem,Any])(implicitstackable:io.dylemma.spac.StackLike[I2,StackElem],implicitpos:io.dylemma.spac.CallerPos):io.dylemma.spac.Parser[I2,Out]"></a><a id="beforeContext[I2&lt;:In,StackElem](ContextMatcher[StackElem,Any])(StackLike[I2,StackElem],CallerPos):Parser[I2,Out]"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#beforeContext[I2&lt;:In,StackElem](matcher:io.dylemma.spac.ContextMatcher[StackElem,Any])(implicitstackable:io.dylemma.spac.StackLike[I2,StackElem],implicitpos:io.dylemma.spac.CallerPos):io.dylemma.spac.Parser[I2,Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">beforeContext</span><span class="tparams">[<span name="I2">I2 &lt;: <span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span></span>, <span name="StackElem">StackElem</span>]</span><span class="params">(<span name="matcher">matcher: <a href="ContextMatcher.html" name="io.dylemma.spac.ContextMatcher" id="io.dylemma.spac.ContextMatcher" class="extype">ContextMatcher</a>[<span name="io.dylemma.spac.Parser.beforeContext.StackElem" class="extype">StackElem</span>, <span name="scala.Any" class="extype">Any</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="stackable">stackable: <a href="StackLike.html" name="io.dylemma.spac.StackLike" id="io.dylemma.spac.StackLike" class="extype">StackLike</a>[<span name="io.dylemma.spac.Parser.beforeContext.I2" class="extype">I2</span>, <span name="io.dylemma.spac.Parser.beforeContext.StackElem" class="extype">StackElem</span>]</span>, <span name="pos">pos: <a href="CallerPos.html" name="io.dylemma.spac.CallerPos" id="io.dylemma.spac.CallerPos" class="extype">CallerPos</a></span>)</span><span class="result">: <a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.beforeContext.I2" class="extype">I2</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>]</span></span><p class="shortcomment cmt">Specialization of <code>interruptedBy</code> for stack-like input types, such that an interruption will occur upon entering
a stack context that can be matched by the given <code>matcher</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Specialization of <code>interruptedBy</code> for stack-like input types, such that an interruption will occur upon entering
a stack context that can be matched by the given <code>matcher</code>.</p><p>Example:</p><pre><span class="kw">val</span> preludeContext = * \ <span class="lit">"prelude"</span>
<span class="kw">val</span> dataContext = * \ <span class="lit">"data"</span>
<span class="kw">for</span> {
  prelude <span class="kw">&lt;-</span> Splitter(preludeContext).firstOption[Prelude].beforeContext(dataContext).followedByStream
  data <span class="kw">&lt;-</span> Splitter(dataContext).as[Data]
} <span class="kw">yield</span> data</pre></div><dl class="paramcmts block"><dt class="tparam">I2</dt><dd class="cmt"><p>Subtype of <code>In</code>, or just <code>In</code> (to satisfy contravariance of Parser's <code>In</code> type)</p></dd><dt class="tparam">StackElem</dt><dd class="cmt"><p>Specialization of the <code>In</code> type for when it represents a stack push or pop</p></dd><dt class="param">matcher</dt><dd class="cmt"><p>A matching function that operates on a context stack</p></dd><dt class="param">stackable</dt><dd class="cmt"><p>Interprets the inputs as stack push/pop events to accumulate a context stack</p></dd><dt>returns</dt><dd class="cmt"><p>A parser which will perform an early <code>finish()</code> when a matching context is encountered</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#clone" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="clone():Object"></a><a id="clone():AnyRef"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#clone():Object" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clone</span><span class="params">()</span><span class="result">: <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Attributes</dt><dd>protected[<a href="../../../java/lang/index.html" name="java.lang" id="java.lang" class="extype">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.CloneNotSupportedException]</span></span>)</span> <span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.Predef.Ensuring#ensuring" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ensuring(cond:A=&gt;Boolean,msg:=&gt;Any):A"></a><a id="ensuring((Stateless[In,Out])=&gt;Boolean,=&gt;Any):Stateless[In,Out]"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#ensuring(cond:A=&gt;Boolean,msg:=&gt;Any):A" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">ensuring</span><span class="params">(<span name="cond">cond: (<a href="" name="io.dylemma.spac.Parser.Stateless" id="io.dylemma.spac.Parser.Stateless" class="extype">Stateless</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>]) =&gt; <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="msg">msg: =&gt; <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <a href="" name="io.dylemma.spac.Parser.Stateless" id="io.dylemma.spac.Parser.Stateless" class="extype">Stateless</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>]</span></span><div class="fullcomment"><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="io.dylemma.spac.Parser.Stateless" id="io.dylemma.spac.Parser.Stateless" class="extype">Stateless</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>] to<span name="scala.Predef.Ensuring" class="extype">Ensuring</span>[<a href="" name="io.dylemma.spac.Parser.Stateless" id="io.dylemma.spac.Parser.Stateless" class="extype">Stateless</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>]] performed by method Ensuring in scala.Predef.</dd><dt>Definition Classes</dt><dd>Ensuring</dd></dl></div></li><li class="indented0 " name="scala.Predef.Ensuring#ensuring" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ensuring(cond:A=&gt;Boolean):A"></a><a id="ensuring((Stateless[In,Out])=&gt;Boolean):Stateless[In,Out]"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#ensuring(cond:A=&gt;Boolean):A" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">ensuring</span><span class="params">(<span name="cond">cond: (<a href="" name="io.dylemma.spac.Parser.Stateless" id="io.dylemma.spac.Parser.Stateless" class="extype">Stateless</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>]) =&gt; <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <a href="" name="io.dylemma.spac.Parser.Stateless" id="io.dylemma.spac.Parser.Stateless" class="extype">Stateless</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>]</span></span><div class="fullcomment"><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="io.dylemma.spac.Parser.Stateless" id="io.dylemma.spac.Parser.Stateless" class="extype">Stateless</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>] to<span name="scala.Predef.Ensuring" class="extype">Ensuring</span>[<a href="" name="io.dylemma.spac.Parser.Stateless" id="io.dylemma.spac.Parser.Stateless" class="extype">Stateless</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>]] performed by method Ensuring in scala.Predef.</dd><dt>Definition Classes</dt><dd>Ensuring</dd></dl></div></li><li class="indented0 " name="scala.Predef.Ensuring#ensuring" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ensuring(cond:Boolean,msg:=&gt;Any):A"></a><a id="ensuring(Boolean,=&gt;Any):Stateless[In,Out]"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#ensuring(cond:Boolean,msg:=&gt;Any):A" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">ensuring</span><span class="params">(<span name="cond">cond: <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="msg">msg: =&gt; <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <a href="" name="io.dylemma.spac.Parser.Stateless" id="io.dylemma.spac.Parser.Stateless" class="extype">Stateless</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>]</span></span><div class="fullcomment"><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="io.dylemma.spac.Parser.Stateless" id="io.dylemma.spac.Parser.Stateless" class="extype">Stateless</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>] to<span name="scala.Predef.Ensuring" class="extype">Ensuring</span>[<a href="" name="io.dylemma.spac.Parser.Stateless" id="io.dylemma.spac.Parser.Stateless" class="extype">Stateless</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>]] performed by method Ensuring in scala.Predef.</dd><dt>Definition Classes</dt><dd>Ensuring</dd></dl></div></li><li class="indented0 " name="scala.Predef.Ensuring#ensuring" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ensuring(cond:Boolean):A"></a><a id="ensuring(Boolean):Stateless[In,Out]"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#ensuring(cond:Boolean):A" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">ensuring</span><span class="params">(<span name="cond">cond: <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <a href="" name="io.dylemma.spac.Parser.Stateless" id="io.dylemma.spac.Parser.Stateless" class="extype">Stateless</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>]</span></span><div class="fullcomment"><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="io.dylemma.spac.Parser.Stateless" id="io.dylemma.spac.Parser.Stateless" class="extype">Stateless</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>] to<span name="scala.Predef.Ensuring" class="extype">Ensuring</span>[<a href="" name="io.dylemma.spac.Parser.Stateless" id="io.dylemma.spac.Parser.Stateless" class="extype">Stateless</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>]] performed by method Ensuring in scala.Predef.</dd><dt>Definition Classes</dt><dd>Ensuring</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#eq" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="eq(x$1:AnyRef):Boolean"></a><a id="eq(AnyRef):Boolean"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#eq(x$1:AnyRef):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">eq</span><span class="params">(<span name="arg0">arg0: <span name="scala.AnyRef" class="extype">AnyRef</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#equals" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="equals(x$1:Object):Boolean"></a><a id="equals(AnyRef):Boolean"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#equals(x$1:Object):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span name="scala.AnyRef" class="extype">AnyRef</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser#expectInputs" group="combinators" fullComment="yes" data-isabs="false" visbl="pub"><a id="expectInputs[I2&lt;:In](expectations:List[(String,I2=&gt;Boolean)]):io.dylemma.spac.Parser[I2,Out]"></a><a id="expectInputs[I2&lt;:In](List[(String,(I2)=&gt;Boolean)]):Parser[I2,Out]"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#expectInputs[I2&lt;:In](expectations:List[(String,I2=&gt;Boolean)]):io.dylemma.spac.Parser[I2,Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">expectInputs</span><span class="tparams">[<span name="I2">I2 &lt;: <span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span></span>]</span><span class="params">(<span name="expectations">expectations: <span name="scala.List" class="extype">List</span>[(<span name="scala.Predef.String" class="extype">String</span>, (<span name="io.dylemma.spac.Parser.expectInputs.I2" class="extype">I2</span>) =&gt; <span name="scala.Boolean" class="extype">Boolean</span>)]</span>)</span><span class="result">: <a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.expectInputs.I2" class="extype">I2</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>]</span></span><p class="shortcomment cmt">Impose expectations on the sequence of inputs to be received by handlers created by this parser.</p><div class="fullcomment"><div class="comment cmt"><p>Impose expectations on the sequence of inputs to be received by handlers created by this parser.
As this parser's handler receives an input, the input will be tested against the head of the expectations list.
If the test returns <code>false</code>, the expectation is failed and the handler will throw an exception.
If the test returns <code>true</code>, the expectation is satisfied, and the handler will advance to the next expectation.
If there are no more expectations left in the list (i.e. N inputs have satisfied the corresponding N expectations),
then all expectations have been met and inputs will be treated as normal by the handler.
If the handler receives an EOF before all expectations are met, it will throw an exception.
</p></div><dl class="paramcmts block"><dt class="param">expectations</dt><dd class="cmt"><p>A sequence of <code>label -&gt; test</code> expectations imposed on inputs to this parser</p></dd><dt>returns</dt><dd class="cmt"><p>A copy of this parser with expectations imposed on its inputs</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#finalize" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="finalize():Unit"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#finalize():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">finalize</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Attributes</dt><dd>protected[<a href="../../../java/lang/index.html" name="java.lang" id="java.lang" class="extype">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="symbol">classOf[java.lang.Throwable]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="scala.Predef.StringFormat#formatted" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="formatted(fmtstr:String):String"></a><a id="formatted(String):String"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#formatted(fmtstr:String):String" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">formatted</span><span class="params">(<span name="fmtstr">fmtstr: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <span name="scala.Predef.String" class="extype">String</span></span></span><div class="fullcomment"><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="io.dylemma.spac.Parser.Stateless" id="io.dylemma.spac.Parser.Stateless" class="extype">Stateless</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>] to<span name="scala.Predef.StringFormat" class="extype">StringFormat</span>[<a href="" name="io.dylemma.spac.Parser.Stateless" id="io.dylemma.spac.Parser.Stateless" class="extype">Stateless</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>]] performed by method StringFormat in scala.Predef.</dd><dt>Definition Classes</dt><dd>StringFormat</dd><dt>Annotations</dt><dd><span class="name">@inline</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#getClass" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="getClass():Class[_]"></a><a id="getClass():Class[_&lt;:AnyRef]"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#getClass():Class[_]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getClass</span><span class="params">()</span><span class="result">: <span name="java.lang.Class" class="extype">Class</span>[_ &lt;: <span name="scala.AnyRef" class="extype">AnyRef</span>]</span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#hashCode" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="hashCode():Int"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#hashCode():Int" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">hashCode</span><span class="params">()</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser#interruptedBy" group="combinators" fullComment="yes" data-isabs="false" visbl="pub"><a id="interruptedBy[I2&lt;:In](interrupter:io.dylemma.spac.Parser[I2,Any]):io.dylemma.spac.Parser[I2,Out]"></a><a id="interruptedBy[I2&lt;:In](Parser[I2,Any]):Parser[I2,Out]"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#interruptedBy[I2&lt;:In](interrupter:io.dylemma.spac.Parser[I2,Any]):io.dylemma.spac.Parser[I2,Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">interruptedBy</span><span class="tparams">[<span name="I2">I2 &lt;: <span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span></span>]</span><span class="params">(<span name="interrupter">interrupter: <a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.interruptedBy.I2" class="extype">I2</span>, <span name="scala.Any" class="extype">Any</span>]</span>)</span><span class="result">: <a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.interruptedBy.I2" class="extype">I2</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>]</span></span><p class="shortcomment cmt">Create a copy of this parser that will treat a result from the <code>interrupter</code> as an early EOF.</p><div class="fullcomment"><div class="comment cmt"><p>Create a copy of this parser that will treat a result from the <code>interrupter</code> as an early EOF.
This is especially useful for creating <code>followedBy</code> chains involving optional elements.</p><p>Normally, a parser for an optional item in some context will not finish until that context ends,
or until the item is encountered. So if the item is not present, <code>followedBy</code> logic won't work
since the <code>followUp</code> parser/transformer will not see any events.</p><p>To make sure the leading parser can "fail fast", you can "interrupt" it, typically by creating
a parser that immediately returns a result upon entering a particular context, i.e. the context
in which the "following" parser will start. <code>Parser#beforeContext</code> provides a convenience for
doing so.</p><p>Note that if the <code>interrupter</code> throws an exception, that exception will not be caught.
If your interrupter might throw, pass <code>interrupter.wrapSafe</code> instead to swallow the exception.
</p></div><dl class="paramcmts block"><dt class="tparam">I2</dt><dd class="cmt"><p>Subtype of <code>In</code>, or just <code>In</code> (to satisfy contravariance of Parser's <code>In</code> type)</p></dd><dt class="param">interrupter</dt><dd class="cmt"><p>A parser which will be run in parallel with this parser, and whose result will
                   be treated as an early EOF for this parser, forcing an early call to <code>finish()</code>.</p></dd><dt>returns</dt><dd class="cmt"><p>A parser which will perform an early <code>finish()</code> call when the <code>interrupter</code> produces a result.</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a></dd></dl></div></li><li class="indented0 " name="scala.Any#isInstanceOf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="isInstanceOf[T0]:Boolean"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#isInstanceOf[T0]:Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser#map" group="combinators" fullComment="yes" data-isabs="false" visbl="pub"><a id="map[Out2](f:Out=&gt;Out2):io.dylemma.spac.Parser[In,Out2]"></a><a id="map[Out2]((Out)=&gt;Out2):Parser[In,Out2]"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#map[Out2](f:Out=&gt;Out2):io.dylemma.spac.Parser[In,Out2]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">map</span><span class="tparams">[<span name="Out2">Out2</span>]</span><span class="params">(<span name="f">f: (<span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>) =&gt; <span name="io.dylemma.spac.Parser.map.Out2" class="extype">Out2</span></span>)</span><span class="result">: <a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.map.Out2" class="extype">Out2</span>]</span></span><p class="shortcomment cmt">Create a copy of this Parser whose result is transformed by the given function <code>f</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Create a copy of this Parser whose result is transformed by the given function <code>f</code>.
</p></div><dl class="paramcmts block"><dt class="tparam">Out2</dt><dd class="cmt"><p>The new parser's result type</p></dd><dt class="param">f</dt><dd class="cmt"><p>Result transformation function</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#ne" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ne(x$1:AnyRef):Boolean"></a><a id="ne(AnyRef):Boolean"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#ne(x$1:AnyRef):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">ne</span><span class="params">(<span name="arg0">arg0: <span name="scala.AnyRef" class="extype">AnyRef</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser.Stateless#newHandler" group="abstract" fullComment="yes" data-isabs="false" visbl="pub"><a id="newHandler:Stateless.this.type"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#newHandler:Stateless.this.type" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">newHandler</span><span class="result">: <a href="" name="io.dylemma.spac.Parser.Stateless" id="io.dylemma.spac.Parser.Stateless" class="extype">Stateless</a>.this.type</span></span><p class="shortcomment cmt">Parser's main abstract method; constructs a new Handler representing this parser's logic.</p><div class="fullcomment"><div class="comment cmt"><p>Parser's main abstract method; constructs a new Handler representing this parser's logic.
Parsers are expected to be immutable, but Handlers may be internally-mutable.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="" name="io.dylemma.spac.Parser.Stateless" id="io.dylemma.spac.Parser.Stateless" class="extype">Stateless</a> → <a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#notify" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="notify():Unit"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#notify():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">notify</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#notifyAll" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="notifyAll():Unit"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#notifyAll():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser#orElse" group="combinators" fullComment="yes" data-isabs="false" visbl="pub"><a id="orElse[In2&lt;:In,Out2&gt;:Out](fallback:io.dylemma.spac.Parser[In2,Out2]):io.dylemma.spac.Parser[In2,Out2]"></a><a id="orElse[In2&lt;:In,Out2&gt;:Out](Parser[In2,Out2]):Parser[In2,Out2]"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#orElse[In2&lt;:In,Out2&gt;:Out](fallback:io.dylemma.spac.Parser[In2,Out2]):io.dylemma.spac.Parser[In2,Out2]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">orElse</span><span class="tparams">[<span name="In2">In2 &lt;: <span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span></span>, <span name="Out2">Out2 &gt;: <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span></span>]</span><span class="params">(<span name="fallback">fallback: <a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.orElse.In2" class="extype">In2</span>, <span name="io.dylemma.spac.Parser.orElse.Out2" class="extype">Out2</span>]</span>)</span><span class="result">: <a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.orElse.In2" class="extype">In2</span>, <span name="io.dylemma.spac.Parser.orElse.Out2" class="extype">Out2</span>]</span></span><p class="shortcomment cmt">Combine this parser with the <code>fallback</code> such that failures from the underlying parsers will be ignored as long as at least one succeeds.</p><div class="fullcomment"><div class="comment cmt"><p>Combine this parser with the <code>fallback</code> such that failures from the underlying parsers will be ignored as long as at least one succeeds.
The result will be the result of whichever underlying parser succeeds first.
If all of the underlying parsers fail, a <code>SpacException.FallbackChainFailure</code> will be thrown by the returned parser's handler.
</p></div><dl class="paramcmts block"><dt class="tparam">In2</dt><dd class="cmt"><p>Subtype of <code>In</code>, or just <code>In</code> (to satisfy Parser's contravariance on the <code>In</code> type)</p></dd><dt class="tparam">Out2</dt><dd class="cmt"><p>Supertype of <code>Out</code>, or just <code>Out</code> (to satisfy Parser's covariance on the <code>Out</code> type)</p></dd><dt class="param">fallback</dt><dd class="cmt"><p>another parser of the same(ish) type as this one</p></dd><dt>returns</dt><dd class="cmt"><p>A new parser that will succeed if either this parser or the fallback succeed</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser#parse" group="consumers" fullComment="yes" data-isabs="false" visbl="pub"><a id="parse(source:io.dylemma.spac.Source[In])(implicitpos:io.dylemma.spac.CallerPos):Out"></a><a id="parse(Source[In])(CallerPos):Out"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#parse(source:io.dylemma.spac.Source[In])(implicitpos:io.dylemma.spac.CallerPos):Out" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">parse</span><span class="params">(<span name="source">source: <a href="Source.html" name="io.dylemma.spac.Source" id="io.dylemma.spac.Source" class="extype">Source</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="pos">pos: <a href="CallerPos.html" name="io.dylemma.spac.CallerPos" id="io.dylemma.spac.CallerPos" class="extype">CallerPos</a></span>)</span><span class="result">: <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span></span></span><p class="shortcomment cmt">Consume the given <code>source</code> to produce an output or possibly throw a <code>SpacException</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Consume the given <code>source</code> to produce an output or possibly throw a <code>SpacException</code>.</p><p>The <code>Source[A]</code> type is like <code>Iterable[A]</code> but uses the "lender" pattern to acquire the iterator
and close any resources associated with the iterator after the iterator is consumed.</p><p>XML and JSON-specific <code>Source</code> constructors are provided by the "parser backend" libraries
i.e. <code>xml-spac-javax</code> and <code>json-spac-jackson</code>.
</p></div><dl class="paramcmts block"><dt class="param">source</dt><dd class="cmt"><p>An object that can provide a series of <code>In</code> values, e.g. <code>XmlEvent</code> or <code>JsonEvent</code></p></dd><dt class="param">pos</dt><dd class="cmt"><p>Captures the caller filename and line number, used to fill in the 'spac trace' if the parser throws an exception</p></dd><dt>returns</dt><dd class="cmt"><p>The parser result based on the given <code>source</code></p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser#parse" group="consumers" fullComment="yes" data-isabs="false" visbl="pub"><a id="parse(inputs:Iterator[In])(implicitpos:io.dylemma.spac.CallerPos):Out"></a><a id="parse(Iterator[In])(CallerPos):Out"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#parse(inputs:Iterator[In])(implicitpos:io.dylemma.spac.CallerPos):Out" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">parse</span><span class="params">(<span name="inputs">inputs: <span name="scala.Iterator" class="extype">Iterator</span>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="pos">pos: <a href="CallerPos.html" name="io.dylemma.spac.CallerPos" id="io.dylemma.spac.CallerPos" class="extype">CallerPos</a></span>)</span><span class="result">: <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span></span></span><p class="shortcomment cmt">Consume the given <code>inputs</code> iterator to produce an output or possibly throw a <code>SpacException</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Consume the given <code>inputs</code> iterator to produce an output or possibly throw a <code>SpacException</code>.</p><p>After calling this method, the <code>inputs</code> should be discarded, since consuming an Iterator is a destructive operation.
</p></div><dl class="paramcmts block"><dt class="param">inputs</dt><dd class="cmt"><p>A series of <code>In</code> values, e.g. <code>XmlEvent</code> or <code>JsonEvent</code></p></dd><dt class="param">pos</dt><dd class="cmt"><p>Captures the caller filename and line number, used to fill in the 'spac trace' if the parser throws an exception</p></dd><dt>returns</dt><dd class="cmt"><p>The parser result based on the given <code>inputs</code></p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a></dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">scala.this.throws.&lt;init&gt;$default$1[io.dylemma.spac.SpacException[_]]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser#rethrow" group="combinators" fullComment="yes" data-isabs="false" visbl="pub"><a id="rethrow[T](implicitev:Out&lt;:&lt;Either[Throwable,T]):io.dylemma.spac.Parser[In,T]"></a><a id="rethrow[T](&lt;:&lt;[Out,Either[Throwable,T]]):Parser[In,T]"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#rethrow[T](implicitev:Out&lt;:&lt;Either[Throwable,T]):io.dylemma.spac.Parser[In,T]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">rethrow</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="ev">ev: <span name="scala.&lt;:&lt;" class="extype">&lt;:&lt;</span>[<span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>, <span name="scala.Either" class="extype">Either</span>[<span name="scala.Throwable" class="extype">Throwable</span>, <span name="io.dylemma.spac.Parser.rethrow.T" class="extype">T</span>]]</span>)</span><span class="result">: <a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.rethrow.T" class="extype">T</span>]</span></span><p class="shortcomment cmt">Like <code>unwrapSafe</code>, but rethrows exceptions from <code>Left</code> or returns results from <code>Right</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Like <code>unwrapSafe</code>, but rethrows exceptions from <code>Left</code> or returns results from <code>Right</code>.
This operation is the opposite of <code>attempt</code>.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser#start" group="consumers" fullComment="yes" data-isabs="false" visbl="pub"><a id="start(methodName:String)(implicitpos:io.dylemma.spac.CallerPos):io.dylemma.spac.Parser.Handler[In,Out]"></a><a id="start(String)(CallerPos):Handler[In,Out]"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#start(methodName:String)(implicitpos:io.dylemma.spac.CallerPos):io.dylemma.spac.Parser.Handler[In,Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">start</span><span class="params">(<span name="methodName">methodName: <span name="scala.Predef.String" class="extype">String</span> = <span class="symbol">"start"</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="pos">pos: <a href="CallerPos.html" name="io.dylemma.spac.CallerPos" id="io.dylemma.spac.CallerPos" class="extype">CallerPos</a></span>)</span><span class="result">: <a href="Parser$$Handler.html" name="io.dylemma.spac.Parser.Handler" id="io.dylemma.spac.Parser.Handler" class="extype">Handler</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>]</span></span><p class="shortcomment cmt">Low-level consumer method: creates a new handler and binds the caller position for its SpacTraceElement.</p><div class="fullcomment"><div class="comment cmt"><p>Low-level consumer method: creates a new handler and binds the caller position for its SpacTraceElement.</p><p>Used internally by the <code>parse</code> methods.
Start with this method if you have some sequence-like datatype that doesn't provide an <code>Iterator</code>.</p><p>This is just a convenience for <code>newHandler.asTopLevelhandler</code> which helps construct a useful SpacTraceElement.
</p></div><dl class="paramcmts block"><dt class="param">methodName</dt><dd class="cmt"><p>The method name used to construct the SpacTraceElement for the handler. Defaults to <code>"start"</code></p></dd><dt class="param">pos</dt><dd class="cmt"><p>Captures the caller filename and line number, used to fill in the 'spac trace' if the parser throws an exception</p></dd><dt>returns</dt><dd class="cmt"><p>A parser handler that can be used to eventually produce a result by calling its <code>step</code> and/or <code>finish</code> methods</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser.Handler#stepMany" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="stepMany[C[_],In2&lt;:In](inputs:C[In2])(implicitC:io.dylemma.spac.Unconsable[C]):Either[(Out,C[In2]),io.dylemma.spac.Parser.Handler[In,Out]]"></a><a id="stepMany[C[_],In2&lt;:In](C[In2])(Unconsable[C]):Either[(Out,C[In2]),Handler[In,Out]]"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#stepMany[C[_],In2&lt;:In](inputs:C[In2])(implicitC:io.dylemma.spac.Unconsable[C]):Either[(Out,C[In2]),io.dylemma.spac.Parser.Handler[In,Out]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">stepMany</span><span class="tparams">[<span name="C">C<span class="tparams">[<span name="_">_</span>]</span></span>, <span name="In2">In2 &lt;: <span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span></span>]</span><span class="params">(<span name="inputs">inputs: <span name="io.dylemma.spac.Parser.Handler.stepMany.C" class="extype">C</span>[<span name="io.dylemma.spac.Parser.Handler.stepMany.In2" class="extype">In2</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="C">C: <a href="Unconsable.html" name="io.dylemma.spac.Unconsable" id="io.dylemma.spac.Unconsable" class="extype">Unconsable</a>[<span name="io.dylemma.spac.Parser.Handler.stepMany.C" class="extype">C</span>]</span>)</span><span class="result">: <span name="scala.Either" class="extype">Either</span>[(<span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>, <span name="io.dylemma.spac.Parser.Handler.stepMany.C" class="extype">C</span>[<span name="io.dylemma.spac.Parser.Handler.stepMany.In2" class="extype">In2</span>]), <a href="Parser$$Handler.html" name="io.dylemma.spac.Parser.Handler" id="io.dylemma.spac.Parser.Handler" class="extype">Handler</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>]]</span></span><p class="shortcomment cmt">Convenience function to call <code>step</code> on a sequence of inputs all at once.</p><div class="fullcomment"><div class="comment cmt"><p>Convenience function to call <code>step</code> on a sequence of inputs all at once.
If the <code>step</code> returns a result, this method will return a <code>Left</code> containing that result and the remainder of the <code>inputs</code> that were not consumed.
If the <code>inputs</code> run out before the handler returns a result from a <code>step</code>, this method will return a <code>Right</code> containing the latest state of the handler.
This method will not call the handler's <code>finish()</code>.</p><p>In general, you won't call this method directly. Instead, use one of the Parser trait's <code>parse</code> methods.
</p></div><dl class="paramcmts block"><dt class="tparam">C</dt><dd class="cmt"><p>An <code>Unconsable</code> collection, i.e. <code>List</code> or <code>cats.data.Chain</code></p></dd><dt class="tparam">In2</dt><dd class="cmt"><p>Subtype of <code>In</code>, or <code>In</code> (to satisfy contravariance)</p></dd><dt class="param">inputs</dt><dd class="cmt"><p>A sequence of inputs</p></dd><dt class="param">C</dt><dd class="cmt"><p>Evidence that the <code>inputs</code> has a <code>head/tail</code> split operation</p></dd><dt>returns</dt><dd class="cmt"><p>Either the handler's result paired with the remaining inputs, or the new handler state</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Parser$$Handler.html" name="io.dylemma.spac.Parser.Handler" id="io.dylemma.spac.Parser.Handler" class="extype">Handler</a></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#synchronized" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="synchronized[T0](x$1:=&gt;T0):T0"></a><a id="synchronized[T0](=&gt;T0):T0"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#synchronized[T0](x$1:=&gt;T0):T0" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: =&gt; <span name="java.lang.AnyRef.synchronized.T0" class="extype">T0</span></span>)</span><span class="result">: <span name="java.lang.AnyRef.synchronized.T0" class="extype">T0</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#toString" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="toString():String"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#toString():String" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">toString</span><span class="params">()</span><span class="result">: <span name="java.lang.String" class="extype">String</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser#unwrapSafe" group="combinators" fullComment="yes" data-isabs="false" visbl="pub"><a id="unwrapSafe[T](implicitev:Out&lt;:&lt;scala.util.Try[T]):io.dylemma.spac.Parser[In,T]"></a><a id="unwrapSafe[T](&lt;:&lt;[Out,Try[T]]):Parser[In,T]"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#unwrapSafe[T](implicitev:Out&lt;:&lt;scala.util.Try[T]):io.dylemma.spac.Parser[In,T]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">unwrapSafe</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="ev">ev: <span name="scala.&lt;:&lt;" class="extype">&lt;:&lt;</span>[<span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>, <span name="scala.util.Try" class="extype">Try</span>[<span name="io.dylemma.spac.Parser.unwrapSafe.T" class="extype">T</span>]]</span>)</span><span class="result">: <a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.unwrapSafe.T" class="extype">T</span>]</span></span><p class="shortcomment cmt">Creates a copy of this parser which unwraps the resulting <code>Try</code>, throwing an exception if the result was a <code>Failure</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a copy of this parser which unwraps the resulting <code>Try</code>, throwing an exception if the result was a <code>Failure</code>.
This operation is the opposite of <code>wrapSafe</code>.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser#upcast" group="combinators" fullComment="yes" data-isabs="false" visbl="pub"><a id="upcast[Out2](implicitev:Out&lt;:&lt;Out2):io.dylemma.spac.Parser[In,Out2]"></a><a id="upcast[Out2](&lt;:&lt;[Out,Out2]):Parser[In,Out2]"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#upcast[Out2](implicitev:Out&lt;:&lt;Out2):io.dylemma.spac.Parser[In,Out2]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">upcast</span><span class="tparams">[<span name="Out2">Out2</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="ev">ev: <span name="scala.&lt;:&lt;" class="extype">&lt;:&lt;</span>[<span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>, <span name="io.dylemma.spac.Parser.upcast.Out2" class="extype">Out2</span>]</span>)</span><span class="result">: <a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.upcast.Out2" class="extype">Out2</span>]</span></span><p class="shortcomment cmt">Returns this parser, with the output type widened to <code>Out2</code>, which is some supertype of <code>Out</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Returns this parser, with the output type widened to <code>Out2</code>, which is some supertype of <code>Out</code>.
Uses <code>asInstanceOf</code> rather than creating a new parser.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait():Unit"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#wait():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait(x$1:Long,x$2:Int):Unit"></a><a id="wait(Long,Int):Unit"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#wait(x$1:Long,x$2:Int):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>, <span name="arg1">arg1: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait(x$1:Long):Unit"></a><a id="wait(Long):Unit"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#wait(x$1:Long):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> <span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser#withName" group="combinators" fullComment="yes" data-isabs="false" visbl="pub"><a id="withName(name:String):io.dylemma.spac.Parser[In,Out]"></a><a id="withName(String):Parser[In,Out]"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#withName(name:String):io.dylemma.spac.Parser[In,Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">withName</span><span class="params">(<span name="name">name: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>]</span></span><p class="shortcomment cmt">Creates a copy of this parser, but with a different <code>toString</code>
</p><div class="fullcomment"><div class="comment cmt"><p>Creates a copy of this parser, but with a different <code>toString</code>
</p></div><dl class="paramcmts block"><dt class="param">name</dt><dd class="cmt"><p>The new "name" (i.e. <code>toString</code>) for this parser</p></dd><dt>returns</dt><dd class="cmt"><p>A copy of this parser whose <code>toString</code> returns the given <code>name</code></p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser#wrapSafe" group="combinators" fullComment="yes" data-isabs="false" visbl="pub"><a id="wrapSafe:io.dylemma.spac.Parser[In,scala.util.Try[Out]]"></a><a id="wrapSafe:Parser[In,Try[Out]]"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#wrapSafe:io.dylemma.spac.Parser[In,scala.util.Try[Out]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wrapSafe</span><span class="result">: <a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="scala.util.Try" class="extype">Try</span>[<span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>]]</span></span><p class="shortcomment cmt">Create a copy of this Parser whose handler will catch NonFatal exceptions thrown by the underlying logic.</p><div class="fullcomment"><div class="comment cmt"><p>Create a copy of this Parser whose handler will catch NonFatal exceptions thrown by the underlying logic.
Caught exceptions will be yielded as a <code>Failure</code> output. Normal results will be wrapped in <code>Success</code>.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>A copy of this parser that will return a <code>Failure</code> instead of throwing exceptions</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a></dd></dl></div></li></ol></div><div class="values members"><h3>Shadowed Implicit Value Members</h3><ol><li class="indented0 " name="io.dylemma.spac.Parser.ParserFollowedByOps#followedBy" group="combinators" fullComment="yes" data-isabs="false" visbl="pub"><a id="followedBy:io.dylemma.spac.Parser.FollowedBy[In,A,io.dylemma.spac.Parser]"></a><a id="followedBy:FollowedBy[In,Out,Parser]"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#followedBy:io.dylemma.spac.Parser.FollowedBy[In,A,io.dylemma.spac.Parser]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit shadowed">followedBy</span><span class="result">: <a href="Parser$$FollowedBy.html" name="io.dylemma.spac.Parser.FollowedBy" id="io.dylemma.spac.Parser.FollowedBy" class="extype">FollowedBy</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>, <a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>]</span></span><p class="shortcomment cmt">Intermediate object for creating a sequenced parser in which the result of this parser will
be used to initialize a second parser as soon as it is available.</p><div class="fullcomment"><div class="comment cmt"><p>Intermediate object for creating a sequenced parser in which the result of this parser will
be used to initialize a second parser as soon as it is available.</p><p>In other words, the source (series of <code>In</code> values) will be fed into this Parser until this
parser's handler returns a result of type <code>Out</code>. At that point, the second parser (as
specified by using the <code>apply</code> or <code>flatMap</code> methods on the <code>FollowedBy</code> returned by this method)
will be instantiated. Any relevant "stack events" (see <code>Stackable</code>) will be replayed so the
second parser has the right context, and from that point on, all <code>In</code> values will be sent
to the second parser. When that second parser returns a result, that result becomes the output
of the combined parser created by <code>this.followedBy(out =&gt; makeSecondParser(out))</code></p><p>Examples:</p><pre><span class="kw">val</span> p1: Parser[A] = <span class="cmt">/* ... */</span>
<span class="kw">def</span> getP2(p1Result: A): Parser[B] = <span class="cmt">/* ... */</span>
<span class="kw">val</span> combined: Parser[B] = p1.followedBy(getP2)

<span class="cmt">// alternative `flatMap` syntax</span>
<span class="kw">val</span> combined: Parser[B] = <span class="kw">for</span> {
  p1Result <span class="kw">&lt;-</span> p1.followedBy
  p2Result <span class="kw">&lt;-</span> getP2(p1Result)
} <span class="kw">yield</span> p2Result</pre><p>See Parser's <code>interruptedBy</code>, which is useful when a <code>transformer.parseFirstOption</code>
must be <code>followedBy</code> some other parser.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="io.dylemma.spac.Parser.Stateless" id="io.dylemma.spac.Parser.Stateless" class="extype">Stateless</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>] to<a href="Parser$$ParserFollowedByOps.html" name="io.dylemma.spac.Parser.ParserFollowedByOps" id="io.dylemma.spac.Parser.ParserFollowedByOps" class="extype">ParserFollowedByOps</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>] performed by method ParserFollowedByOps in <a href="Parser$.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">io.dylemma.spac.Parser</a>.</dd><dt class="implicit">Shadowing</dt><dd>This implicitly inherited member is ambiguous. One or more implicitly inherited members have similar signatures, so calling this member may produce an ambiguous implicit conversion compiler error.<br/>To access this member you can use a <a href="http://stackoverflow.com/questions/2087250/what-is-the-purpose-of-type-ascription-in-scala" target="_blank">type ascription</a>:<br/><div class="cmt"><pre>(stateless: ParserFollowedByOps[In, Out]).followedBy</pre></div></dd><dt>Definition Classes</dt><dd><a href="Parser$$ParserFollowedByOps.html" name="io.dylemma.spac.Parser.ParserFollowedByOps" id="io.dylemma.spac.Parser.ParserFollowedByOps" class="extype">ParserFollowedByOps</a></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser.ParserFollowedByOps#followedBy" group="combinators" fullComment="yes" data-isabs="false" visbl="pub"><a id="followedBy:io.dylemma.spac.Parser.FollowedBy[In,A,io.dylemma.spac.Parser]"></a><a id="followedBy:FollowedBy[In,Out,Parser]"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#followedBy:io.dylemma.spac.Parser.FollowedBy[In,A,io.dylemma.spac.Parser]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit shadowed">followedBy</span><span class="result">: <a href="Parser$$FollowedBy.html" name="io.dylemma.spac.Parser.FollowedBy" id="io.dylemma.spac.Parser.FollowedBy" class="extype">FollowedBy</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>, <a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>]</span></span><p class="shortcomment cmt">Intermediate object for creating a sequenced parser in which the result of this parser will
be used to initialize a second parser as soon as it is available.</p><div class="fullcomment"><div class="comment cmt"><p>Intermediate object for creating a sequenced parser in which the result of this parser will
be used to initialize a second parser as soon as it is available.</p><p>In other words, the source (series of <code>In</code> values) will be fed into this Parser until this
parser's handler returns a result of type <code>Out</code>. At that point, the second parser (as
specified by using the <code>apply</code> or <code>flatMap</code> methods on the <code>FollowedBy</code> returned by this method)
will be instantiated. Any relevant "stack events" (see <code>Stackable</code>) will be replayed so the
second parser has the right context, and from that point on, all <code>In</code> values will be sent
to the second parser. When that second parser returns a result, that result becomes the output
of the combined parser created by <code>this.followedBy(out =&gt; makeSecondParser(out))</code></p><p>Examples:</p><pre><span class="kw">val</span> p1: Parser[A] = <span class="cmt">/* ... */</span>
<span class="kw">def</span> getP2(p1Result: A): Parser[B] = <span class="cmt">/* ... */</span>
<span class="kw">val</span> combined: Parser[B] = p1.followedBy(getP2)

<span class="cmt">// alternative `flatMap` syntax</span>
<span class="kw">val</span> combined: Parser[B] = <span class="kw">for</span> {
  p1Result <span class="kw">&lt;-</span> p1.followedBy
  p2Result <span class="kw">&lt;-</span> getP2(p1Result)
} <span class="kw">yield</span> p2Result</pre><p>See Parser's <code>interruptedBy</code>, which is useful when a <code>transformer.parseFirstOption</code>
must be <code>followedBy</code> some other parser.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="io.dylemma.spac.Parser.Stateless" id="io.dylemma.spac.Parser.Stateless" class="extype">Stateless</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>] to<a href="Parser$$ParserFollowedByOps.html" name="io.dylemma.spac.Parser.ParserFollowedByOps" id="io.dylemma.spac.Parser.ParserFollowedByOps" class="extype">ParserFollowedByOps</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>] performed by method ParserFollowedByOps in <a href="Parser$.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">io.dylemma.spac.Parser</a>.</dd><dt class="implicit">Shadowing</dt><dd>This implicitly inherited member is ambiguous. One or more implicitly inherited members have similar signatures, so calling this member may produce an ambiguous implicit conversion compiler error.<br/>To access this member you can use a <a href="http://stackoverflow.com/questions/2087250/what-is-the-purpose-of-type-ascription-in-scala" target="_blank">type ascription</a>:<br/><div class="cmt"><pre>(stateless: ParserFollowedByOps[In, Out]).followedBy</pre></div></dd><dt>Definition Classes</dt><dd><a href="Parser$$ParserFollowedByOps.html" name="io.dylemma.spac.Parser.ParserFollowedByOps" id="io.dylemma.spac.Parser.ParserFollowedByOps" class="extype">ParserFollowedByOps</a></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser.ParserFollowedByOps#followedByParser" group="combinators" fullComment="yes" data-isabs="false" visbl="pub"><a id="followedByParser:io.dylemma.spac.Parser.FollowedBy[In,A,io.dylemma.spac.Parser]"></a><a id="followedByParser:FollowedBy[In,Out,Parser]"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#followedByParser:io.dylemma.spac.Parser.FollowedBy[In,A,io.dylemma.spac.Parser]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit shadowed">followedByParser</span><span class="result">: <a href="Parser$$FollowedBy.html" name="io.dylemma.spac.Parser.FollowedBy" id="io.dylemma.spac.Parser.FollowedBy" class="extype">FollowedBy</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>, <a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>]</span></span><p class="shortcomment cmt">Alias for <code>followedBy</code>, for use when Cat's <code>ApplyOps</code> gets in the way with its own useless <code>followedBy</code> method.</p><div class="fullcomment"><div class="comment cmt"><p>Alias for <code>followedBy</code>, for use when Cat's <code>ApplyOps</code> gets in the way with its own useless <code>followedBy</code> method.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="io.dylemma.spac.Parser.Stateless" id="io.dylemma.spac.Parser.Stateless" class="extype">Stateless</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>] to<a href="Parser$$ParserFollowedByOps.html" name="io.dylemma.spac.Parser.ParserFollowedByOps" id="io.dylemma.spac.Parser.ParserFollowedByOps" class="extype">ParserFollowedByOps</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>] performed by method ParserFollowedByOps in <a href="Parser$.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">io.dylemma.spac.Parser</a>.</dd><dt class="implicit">Shadowing</dt><dd>This implicitly inherited member is ambiguous. One or more implicitly inherited members have similar signatures, so calling this member may produce an ambiguous implicit conversion compiler error.<br/>To access this member you can use a <a href="http://stackoverflow.com/questions/2087250/what-is-the-purpose-of-type-ascription-in-scala" target="_blank">type ascription</a>:<br/><div class="cmt"><pre>(stateless: ParserFollowedByOps[In, Out]).followedByParser</pre></div></dd><dt>Definition Classes</dt><dd><a href="Parser$$ParserFollowedByOps.html" name="io.dylemma.spac.Parser.ParserFollowedByOps" id="io.dylemma.spac.Parser.ParserFollowedByOps" class="extype">ParserFollowedByOps</a></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser.ParserFollowedByOps#followedByParser" group="combinators" fullComment="yes" data-isabs="false" visbl="pub"><a id="followedByParser:io.dylemma.spac.Parser.FollowedBy[In,A,io.dylemma.spac.Parser]"></a><a id="followedByParser:FollowedBy[In,Out,Parser]"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#followedByParser:io.dylemma.spac.Parser.FollowedBy[In,A,io.dylemma.spac.Parser]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit shadowed">followedByParser</span><span class="result">: <a href="Parser$$FollowedBy.html" name="io.dylemma.spac.Parser.FollowedBy" id="io.dylemma.spac.Parser.FollowedBy" class="extype">FollowedBy</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>, <a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>]</span></span><p class="shortcomment cmt">Alias for <code>followedBy</code>, for use when Cat's <code>ApplyOps</code> gets in the way with its own useless <code>followedBy</code> method.</p><div class="fullcomment"><div class="comment cmt"><p>Alias for <code>followedBy</code>, for use when Cat's <code>ApplyOps</code> gets in the way with its own useless <code>followedBy</code> method.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="io.dylemma.spac.Parser.Stateless" id="io.dylemma.spac.Parser.Stateless" class="extype">Stateless</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>] to<a href="Parser$$ParserFollowedByOps.html" name="io.dylemma.spac.Parser.ParserFollowedByOps" id="io.dylemma.spac.Parser.ParserFollowedByOps" class="extype">ParserFollowedByOps</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>] performed by method ParserFollowedByOps in <a href="Parser$.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">io.dylemma.spac.Parser</a>.</dd><dt class="implicit">Shadowing</dt><dd>This implicitly inherited member is ambiguous. One or more implicitly inherited members have similar signatures, so calling this member may produce an ambiguous implicit conversion compiler error.<br/>To access this member you can use a <a href="http://stackoverflow.com/questions/2087250/what-is-the-purpose-of-type-ascription-in-scala" target="_blank">type ascription</a>:<br/><div class="cmt"><pre>(stateless: ParserFollowedByOps[In, Out]).followedByParser</pre></div></dd><dt>Definition Classes</dt><dd><a href="Parser$$ParserFollowedByOps.html" name="io.dylemma.spac.Parser.ParserFollowedByOps" id="io.dylemma.spac.Parser.ParserFollowedByOps" class="extype">ParserFollowedByOps</a></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser.ParserFollowedByOps#followedByStream" group="combinators" fullComment="yes" data-isabs="false" visbl="pub"><a id="followedByStream:io.dylemma.spac.Parser.FollowedBy[In,A,io.dylemma.spac.Transformer]"></a><a id="followedByStream:FollowedBy[In,Out,Transformer]"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#followedByStream:io.dylemma.spac.Parser.FollowedBy[In,A,io.dylemma.spac.Transformer]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit shadowed">followedByStream</span><span class="result">: <a href="Parser$$FollowedBy.html" name="io.dylemma.spac.Parser.FollowedBy" id="io.dylemma.spac.Parser.FollowedBy" class="extype">FollowedBy</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>, <a href="Transformer.html" name="io.dylemma.spac.Transformer" id="io.dylemma.spac.Transformer" class="extype">Transformer</a>]</span></span><p class="shortcomment cmt">Intermediate object creating a transformer that depends on this parser.</p><div class="fullcomment"><div class="comment cmt"><p>Intermediate object creating a transformer that depends on this parser.
Particularly useful in cases where one or more specific "info" elements precede
a stream of other elements which require that "info" to be parsed.</p><p>Examples:</p><pre><span class="kw">val</span> p1: Parser[In, A] = <span class="cmt">/* ... */</span>
<span class="kw">def</span> getP2Stream(p1Result: A): Transformer[In, B] = <span class="cmt">/* ... */</span>
<span class="kw">val</span> combined: Transformer[In, B] = p1.andThenStream(getP2Stream)

<span class="cmt">// alternative `flatMap` syntax</span>
<span class="kw">val</span> combined: Transformer[In, B] = <span class="kw">for</span> {
  p1Result <span class="kw">&lt;-</span> p1.andThenStream
  p2Result <span class="kw">&lt;-</span> getP2Stream(p1Result)
} <span class="kw">yield</span> p2Result</pre><p>See <code>followedBy</code> for a general explanation of how the combination works.</p><p>See also, <code>interruptedBy</code>, which is useful when a <code>transformer.parseFirstOption</code>
must be <code>followedBy</code> some other transformer.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="io.dylemma.spac.Parser.Stateless" id="io.dylemma.spac.Parser.Stateless" class="extype">Stateless</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>] to<a href="Parser$$ParserFollowedByOps.html" name="io.dylemma.spac.Parser.ParserFollowedByOps" id="io.dylemma.spac.Parser.ParserFollowedByOps" class="extype">ParserFollowedByOps</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>] performed by method ParserFollowedByOps in <a href="Parser$.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">io.dylemma.spac.Parser</a>.</dd><dt class="implicit">Shadowing</dt><dd>This implicitly inherited member is ambiguous. One or more implicitly inherited members have similar signatures, so calling this member may produce an ambiguous implicit conversion compiler error.<br/>To access this member you can use a <a href="http://stackoverflow.com/questions/2087250/what-is-the-purpose-of-type-ascription-in-scala" target="_blank">type ascription</a>:<br/><div class="cmt"><pre>(stateless: ParserFollowedByOps[In, Out]).followedByStream</pre></div></dd><dt>Definition Classes</dt><dd><a href="Parser$$ParserFollowedByOps.html" name="io.dylemma.spac.Parser.ParserFollowedByOps" id="io.dylemma.spac.Parser.ParserFollowedByOps" class="extype">ParserFollowedByOps</a></dd></dl></div></li><li class="indented0 " name="io.dylemma.spac.Parser.ParserFollowedByOps#followedByStream" group="combinators" fullComment="yes" data-isabs="false" visbl="pub"><a id="followedByStream:io.dylemma.spac.Parser.FollowedBy[In,A,io.dylemma.spac.Transformer]"></a><a id="followedByStream:FollowedBy[In,Out,Transformer]"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#followedByStream:io.dylemma.spac.Parser.FollowedBy[In,A,io.dylemma.spac.Transformer]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit shadowed">followedByStream</span><span class="result">: <a href="Parser$$FollowedBy.html" name="io.dylemma.spac.Parser.FollowedBy" id="io.dylemma.spac.Parser.FollowedBy" class="extype">FollowedBy</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>, <a href="Transformer.html" name="io.dylemma.spac.Transformer" id="io.dylemma.spac.Transformer" class="extype">Transformer</a>]</span></span><p class="shortcomment cmt">Intermediate object creating a transformer that depends on this parser.</p><div class="fullcomment"><div class="comment cmt"><p>Intermediate object creating a transformer that depends on this parser.
Particularly useful in cases where one or more specific "info" elements precede
a stream of other elements which require that "info" to be parsed.</p><p>Examples:</p><pre><span class="kw">val</span> p1: Parser[In, A] = <span class="cmt">/* ... */</span>
<span class="kw">def</span> getP2Stream(p1Result: A): Transformer[In, B] = <span class="cmt">/* ... */</span>
<span class="kw">val</span> combined: Transformer[In, B] = p1.andThenStream(getP2Stream)

<span class="cmt">// alternative `flatMap` syntax</span>
<span class="kw">val</span> combined: Transformer[In, B] = <span class="kw">for</span> {
  p1Result <span class="kw">&lt;-</span> p1.andThenStream
  p2Result <span class="kw">&lt;-</span> getP2Stream(p1Result)
} <span class="kw">yield</span> p2Result</pre><p>See <code>followedBy</code> for a general explanation of how the combination works.</p><p>See also, <code>interruptedBy</code>, which is useful when a <code>transformer.parseFirstOption</code>
must be <code>followedBy</code> some other transformer.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="io.dylemma.spac.Parser.Stateless" id="io.dylemma.spac.Parser.Stateless" class="extype">Stateless</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>] to<a href="Parser$$ParserFollowedByOps.html" name="io.dylemma.spac.Parser.ParserFollowedByOps" id="io.dylemma.spac.Parser.ParserFollowedByOps" class="extype">ParserFollowedByOps</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>] performed by method ParserFollowedByOps in <a href="Parser$.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">io.dylemma.spac.Parser</a>.</dd><dt class="implicit">Shadowing</dt><dd>This implicitly inherited member is ambiguous. One or more implicitly inherited members have similar signatures, so calling this member may produce an ambiguous implicit conversion compiler error.<br/>To access this member you can use a <a href="http://stackoverflow.com/questions/2087250/what-is-the-purpose-of-type-ascription-in-scala" target="_blank">type ascription</a>:<br/><div class="cmt"><pre>(stateless: ParserFollowedByOps[In, Out]).followedByStream</pre></div></dd><dt>Definition Classes</dt><dd><a href="Parser$$ParserFollowedByOps.html" name="io.dylemma.spac.Parser.ParserFollowedByOps" id="io.dylemma.spac.Parser.ParserFollowedByOps" class="extype">ParserFollowedByOps</a></dd></dl></div></li></ol></div><div class="values members"><h3>Deprecated Value Members</h3><ol><li class="indented0 " name="scala.Predef.ArrowAssoc#→" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="→[B](y:B):(A,B)"></a><a id="→[B](B):(Stateless[In,Out],B)"></a> <span class="permalink"><a href="../../../io/dylemma/spac/Parser$$Stateless.html#→[B](y:B):(A,B)" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit deprecated" title="gt4s: $u2192. Deprecated: (Since version 2.13.0) Use -&gt; instead. If you still wish to display it as one character, consider using a font with programming ligatures such as Fira Code.">→</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="y">y: <span name="scala.Predef.ArrowAssoc.→.B" class="extype">B</span></span>)</span><span class="result">: (<a href="" name="io.dylemma.spac.Parser.Stateless" id="io.dylemma.spac.Parser.Stateless" class="extype">Stateless</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>], <span name="scala.Predef.ArrowAssoc.→.B" class="extype">B</span>)</span></span><div class="fullcomment"><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="io.dylemma.spac.Parser.Stateless" id="io.dylemma.spac.Parser.Stateless" class="extype">Stateless</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>] to<span name="scala.Predef.ArrowAssoc" class="extype">ArrowAssoc</span>[<a href="" name="io.dylemma.spac.Parser.Stateless" id="io.dylemma.spac.Parser.Stateless" class="extype">Stateless</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>]] performed by method ArrowAssoc in scala.Predef.</dd><dt>Definition Classes</dt><dd>ArrowAssoc</dd><dt>Annotations</dt><dd><span class="name">@deprecated</span> </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 2.13.0)</i> Use <code>-&gt;</code> instead. If you still wish to display it as one character, consider using a font with programming ligatures such as Fira Code.</p></dd></dl></div></li></ol></div></div><div id="inheritedMembers"><div name="io.dylemma.spac.Parser.Handler" class="parent"><h3>Inherited from <a href="Parser$$Handler.html" name="io.dylemma.spac.Parser.Handler" id="io.dylemma.spac.Parser.Handler" class="extype">Handler</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>]</h3></div><div name="io.dylemma.spac.Parser" class="parent"><h3>Inherited from <a href="Parser.html" name="io.dylemma.spac.Parser" id="io.dylemma.spac.Parser" class="extype">Parser</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>]</h3></div><div name="scala.AnyRef" class="parent"><h3>Inherited from <span name="scala.AnyRef" class="extype">AnyRef</span></h3></div><div name="scala.Any" class="parent"><h3>Inherited from <span name="scala.Any" class="extype">Any</span></h3></div><div name="io.dylemma.spac.Parser.ParserFollowedByOps" class="conversion"><h3>Inherited by implicit conversion ParserFollowedByOps from<a href="" name="io.dylemma.spac.Parser.Stateless" id="io.dylemma.spac.Parser.Stateless" class="extype">Stateless</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>] to <a href="Parser$$ParserFollowedByOps.html" name="io.dylemma.spac.Parser.ParserFollowedByOps" id="io.dylemma.spac.Parser.ParserFollowedByOps" class="extype">ParserFollowedByOps</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>]</h3></div><div name="io.dylemma.spac.Parser.ParserFollowedByOps" class="conversion"><h3>Inherited by implicit conversion ParserFollowedByOps from<a href="" name="io.dylemma.spac.Parser.Stateless" id="io.dylemma.spac.Parser.Stateless" class="extype">Stateless</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>] to <a href="Parser$$ParserFollowedByOps.html" name="io.dylemma.spac.Parser.ParserFollowedByOps" id="io.dylemma.spac.Parser.ParserFollowedByOps" class="extype">ParserFollowedByOps</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>]</h3></div><div name="scala.Predef.any2stringadd" class="conversion"><h3>Inherited by implicit conversion any2stringadd from<a href="" name="io.dylemma.spac.Parser.Stateless" id="io.dylemma.spac.Parser.Stateless" class="extype">Stateless</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>] to <span name="scala.Predef.any2stringadd" class="extype">any2stringadd</span>[<a href="" name="io.dylemma.spac.Parser.Stateless" id="io.dylemma.spac.Parser.Stateless" class="extype">Stateless</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>]]</h3></div><div name="scala.Predef.StringFormat" class="conversion"><h3>Inherited by implicit conversion StringFormat from<a href="" name="io.dylemma.spac.Parser.Stateless" id="io.dylemma.spac.Parser.Stateless" class="extype">Stateless</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>] to <span name="scala.Predef.StringFormat" class="extype">StringFormat</span>[<a href="" name="io.dylemma.spac.Parser.Stateless" id="io.dylemma.spac.Parser.Stateless" class="extype">Stateless</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>]]</h3></div><div name="scala.Predef.Ensuring" class="conversion"><h3>Inherited by implicit conversion Ensuring from<a href="" name="io.dylemma.spac.Parser.Stateless" id="io.dylemma.spac.Parser.Stateless" class="extype">Stateless</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>] to <span name="scala.Predef.Ensuring" class="extype">Ensuring</span>[<a href="" name="io.dylemma.spac.Parser.Stateless" id="io.dylemma.spac.Parser.Stateless" class="extype">Stateless</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>]]</h3></div><div name="scala.Predef.ArrowAssoc" class="conversion"><h3>Inherited by implicit conversion ArrowAssoc from<a href="" name="io.dylemma.spac.Parser.Stateless" id="io.dylemma.spac.Parser.Stateless" class="extype">Stateless</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>] to <span name="scala.Predef.ArrowAssoc" class="extype">ArrowAssoc</span>[<a href="" name="io.dylemma.spac.Parser.Stateless" id="io.dylemma.spac.Parser.Stateless" class="extype">Stateless</a>[<span name="io.dylemma.spac.Parser.Stateless.In" class="extype">In</span>, <span name="io.dylemma.spac.Parser.Stateless.Out" class="extype">Out</span>]]</h3></div></div><div id="groupedMembers"><div name="abstract" class="group"><h3>Abstract Members</h3></div><div name="consumers" class="group"><h3>Consumer Methods</h3></div><div name="combinators" class="group"><h3>Transformation / Combinator Methods</h3></div><div name="Ungrouped" class="group"><h3>Ungrouped</h3></div></div></div><div id="tooltip"></div><div id="footer"></div></body></div></div></div></body></html>

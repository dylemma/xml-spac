package io.dylemma.spac

import cats.data.Chain

/** A `Source[A]` is like an `Iterable[A]` but with a built-in assumption that the iterator may be closeable,
  * intended for use as a convenient argument to a `Parser`'s `parse` method.
  *
  * The spac core library avoids depending on Cats-Effect and FS2 (to avoid introducing "dependency hell"
  * situations for projects that must depend on pre-3.0 versions of those projects), so this class acts as
  * a stand-in for both `cats.effect.Resource` and `fs2.Stream` for non-async usage.
  *
  * @tparam A Type of item emitted by Iterators from this Source
  */
trait Source[+A] {
	/** Lender pattern that opens a new iterator from this source, passes it to the given consumer function `f`,
	  * returns the result of `f`, then closes the iterator.
	  *
	  * @param f A function to consume the iterator provided by this source
	  * @tparam B The consumer function's output type
	  * @return The result generated by passing a new Iterator from this source to the consumer function `f`
	  */
	def iterateWith[B](f: Iterator[A] => B): B = {
		val (itr, close) = open()
		try f(itr) finally close()
	}

	/** Opens a new iterator from this source, returning a tuple containing the iterator and a function
	  * that must eventually be called to release any resources associated with the iterator.
	  *
	  * @return A tuple containing an iterator and a close function
	  */
	def open(): (Iterator[A], () => Unit)
}

/** Note: this companion object provides a few very basic Source-constructor helpers,
  * but the real useful functionality is provided by the "parser backend" modules like
  * `xml-spac-javax` and `json-spac-jackson`, via `JavaxSource` and `JacksonSource`.
  */
object Source {

	private val noop = () => ()
	private def autoClose(x: AnyRef): () => Unit = () => {
		x match {
			case e: AutoCloseable => e.close()
			case _ => ()
		}
	}

	/** Wraps an existing iterator as a `Source` which may only be used once.
	  *
	  * @param itr The wrapped iterator
	  * @tparam A The iterator's item type
	  * @return A new `Source` that will return the given iterator when opened,
	  *         and has a no-op close operation.
	  */
	def singleUse[A](itr: Iterator[A]): Source[A] = new Source[A] {
		private var didOpen = false
		def open() = {
			if (didOpen) throw new IllegalStateException("Single-use source was reused")
			didOpen = true
			itr -> noop
		}
	}

	/** Creates a new Source which delegates to an underlying Source constructed from
	  * a call-by-name parameter, and ensures the new Source can only be opened once.
	  *
	  * @param getUnderlying A call-by-name expression that constructs the underlying source
	  * @tparam A The source item type
	  * @return A new Source
	  */
	def deferOnce[A](getUnderlying: => Source[A]): Source[A] = new Source[A] {
		private var didOpen = false
		def open() = {
			if (didOpen) throw new IllegalStateException("Single-use source was reused")
			didOpen = true
			getUnderlying.open()
		}
	}

	/** Converts an iterable collection to a Source.
	  *
	  * @param collection           The collection
	  * @param shouldCloseIterators If `true`, any AutoCloseable iterators returned by this source's `open` will
	  *                             be closed during the corresponding `close` operation.
	  * @tparam A The Source item type
	  * @return A view of the given `collection` as a `Source`
	  */
	def fromIterable[A](collection: Iterable[A], shouldCloseIterators: Boolean = true): Source[A] = () => {
		val itr = collection.iterator
		val close = if (shouldCloseIterators) autoClose(itr) else noop
		itr -> close
	}

	/** Wraps a `Chain` as a `Source`.
	  *
	  * @param chain The wrapped Chain
	  * @tparam A The Chain item type
	  * @return A new Source which delegates to the Chain
	  */
	def fromChain[A](chain: Chain[A]): Source[A] = () => {
		chain.iterator -> noop
	}

}
